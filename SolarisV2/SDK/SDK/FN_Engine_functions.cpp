#pragma once

// Dumped with Dumper-7!

#include "pch.h"
#include "../SDK.hpp"

namespace SDK
{
	class UEngine* UEngine::GetEngine()
	{
		static UEngine* GEngine = nullptr;

		if (!GEngine)
		{
			for (int i = 0; i < UObject::GObjects->Num(); i++)
			{
				UObject* Obj = UObject::GObjects->GetByIndex(i);

				if (!Obj)
					continue;

				if (Obj->IsA(UEngine::StaticClass()) && !Obj->IsDefaultObject())
				{
					GEngine = static_cast<UEngine*>(Obj);
					break;
				}
			}
		}

		return GEngine; 
	}

	class UWorld* UWorld::GetWorld()
	{
		if (UEngine* Engine = UEngine::GetEngine())
		{
			if (!Engine->GameViewport)
				return nullptr;

			return Engine->GameViewport->World;
		}

		return nullptr;
	}

//---------------------------------------------------------------------------------------------------------------------
// FUNCTIONS
//---------------------------------------------------------------------------------------------------------------------


// Class Engine.BlueprintFunctionLibrary
// (None)

class UClass* UBlueprintFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueprintFunctionLibrary");

	return Clss;
}


// BlueprintFunctionLibrary Engine.Default__BlueprintFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprintFunctionLibrary* UBlueprintFunctionLibrary::GetDefaultObj()
{
	static class UBlueprintFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprintFunctionLibrary*>(UBlueprintFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ActorComponent
// (None)

class UClass* UActorComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ActorComponent");

	return Clss;
}


// ActorComponent Engine.Default__ActorComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UActorComponent* UActorComponent::GetDefaultObj()
{
	static class UActorComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UActorComponent*>(UActorComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ActorComponent.ToggleActive
// (Native, Public, BlueprintCallable)
// Parameters:

void UActorComponent::ToggleActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "ToggleActive");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.SetTickGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ETickingGroup           NewTickGroup                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetTickGroup(enum class ETickingGroup NewTickGroup)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "SetTickGroup");

	Params::UActorComponent_SetTickGroup_Params Parms{};

	Parms.NewTickGroup = NewTickGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.SetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bTickableWhenPaused                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetTickableWhenPaused(bool bTickableWhenPaused)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "SetTickableWhenPaused");

	Params::UActorComponent_SetTickableWhenPaused_Params Parms{};

	Parms.bTickableWhenPaused = bTickableWhenPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.SetIsReplicated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ShouldReplicate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetIsReplicated(bool ShouldReplicate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "SetIsReplicated");

	Params::UActorComponent_SetIsReplicated_Params Parms{};

	Parms.ShouldReplicate = ShouldReplicate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.SetComponentTickInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              TickInterval                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetComponentTickInterval(float TickInterval)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "SetComponentTickInterval");

	Params::UActorComponent_SetComponentTickInterval_Params Parms{};

	Parms.TickInterval = TickInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.SetComponentTickEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetComponentTickEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "SetComponentTickEnabled");

	Params::UActorComponent_SetComponentTickEnabled_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.SetAutoActivate
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewAutoActivate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetAutoActivate(bool bNewAutoActivate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "SetAutoActivate");

	Params::UActorComponent_SetAutoActivate_Params Parms{};

	Parms.bNewAutoActivate = bNewAutoActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.SetActive
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewActive                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bReset                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetActive(bool bNewActive, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "SetActive");

	Params::UActorComponent_SetActive_Params Parms{};

	Parms.bNewActive = bNewActive;
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.RemoveTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*             PrerequisiteComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "RemoveTickPrerequisiteComponent");

	Params::UActorComponent_RemoveTickPrerequisiteComponent_Params Parms{};

	Parms.PrerequisiteComponent = PrerequisiteComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.RemoveTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      PrerequisiteActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "RemoveTickPrerequisiteActor");

	Params::UActorComponent_RemoveTickPrerequisiteActor_Params Parms{};

	Parms.PrerequisiteActor = PrerequisiteActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              DeltaSeconds                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "ReceiveTick");

	Params::UActorComponent_ReceiveTick_Params Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.ActorComponent.ReceiveEndPlay
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class EEndPlayReason          EndPlayReason                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::ReceiveEndPlay(enum class EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "ReceiveEndPlay");

	Params::UActorComponent_ReceiveEndPlay_Params Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.ActorComponent.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)
// Parameters:

void UActorComponent::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "ReceiveBeginPlay");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.ActorComponent.OnRep_IsActive
// (Native, Public)
// Parameters:

void UActorComponent::OnRep_IsActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "OnRep_IsActive");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.K2_DestroyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::K2_DestroyComponent(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "K2_DestroyComponent");

	Params::UActorComponent_K2_DestroyComponent_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.IsComponentTickEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponent::IsComponentTickEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "IsComponentTickEnabled");

	Params::UActorComponent_IsComponentTickEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ActorComponent.IsBeingDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponent::IsBeingDestroyed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "IsBeingDestroyed");

	Params::UActorComponent_IsBeingDestroyed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ActorComponent.IsActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponent::IsActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "IsActive");

	Params::UActorComponent_IsActive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ActorComponent.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UActorComponent::GetOwner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "GetOwner");

	Params::UActorComponent_GetOwner_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ActorComponent.GetComponentTickInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActorComponent::GetComponentTickInterval()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "GetComponentTickInterval");

	Params::UActorComponent_GetComponentTickInterval_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ActorComponent.Deactivate
// (Native, Public, BlueprintCallable)
// Parameters:

void UActorComponent::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "Deactivate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.ComponentHasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Tag                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponent::ComponentHasTag(class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "ComponentHasTag");

	Params::UActorComponent_ComponentHasTag_Params Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ActorComponent.AddTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*             PrerequisiteComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "AddTickPrerequisiteComponent");

	Params::UActorComponent_AddTickPrerequisiteComponent_Params Parms{};

	Parms.PrerequisiteComponent = PrerequisiteComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.AddTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      PrerequisiteActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::AddTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "AddTickPrerequisiteActor");

	Params::UActorComponent_AddTickPrerequisiteActor_Params Parms{};

	Parms.PrerequisiteActor = PrerequisiteActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ActorComponent.Activate
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bReset                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::Activate(bool bReset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ActorComponent", "Activate");

	Params::UActorComponent_Activate_Params Parms{};

	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SceneComponent
// (SceneComponent)

class UClass* USceneComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SceneComponent");

	return Clss;
}


// SceneComponent Engine.Default__SceneComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USceneComponent* USceneComponent::GetDefaultObj()
{
	static class USceneComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USceneComponent*>(USceneComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SceneComponent.ToggleVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bPropagateToChildren                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::ToggleVisibility(bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "ToggleVisibility");

	Params::USceneComponent_ToggleVisibility_Params Parms{};

	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.SnapTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             InParent                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::SnapTo(class USceneComponent* InParent, class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "SnapTo");

	Params::USceneComponent_SnapTo_Params Parms{};

	Parms.InParent = InParent;
	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.SetWorldScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewScale                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetWorldScale3D(const struct FVector& NewScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "SetWorldScale3D");

	Params::USceneComponent_SetWorldScale3D_Params Parms{};

	Parms.NewScale = NewScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.SetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewVisibility                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPropagateToChildren                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "SetVisibility");

	Params::USceneComponent_SetVisibility_Params Parms{};

	Parms.bNewVisibility = bNewVisibility;
	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.SetShouldUpdatePhysicsVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInShouldUpdatePhysicsVolume                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetShouldUpdatePhysicsVolume(bool bInShouldUpdatePhysicsVolume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "SetShouldUpdatePhysicsVolume");

	Params::USceneComponent_SetShouldUpdatePhysicsVolume_Params Parms{};

	Parms.bInShouldUpdatePhysicsVolume = bInShouldUpdatePhysicsVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.SetRelativeScale3D
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewScale3D                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetRelativeScale3D(const struct FVector& NewScale3D)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "SetRelativeScale3D");

	Params::USceneComponent_SetRelativeScale3D_Params Parms{};

	Parms.NewScale3D = NewScale3D;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.SetMobility
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EComponentMobility      NewMobility                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetMobility(enum class EComponentMobility NewMobility)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "SetMobility");

	Params::USceneComponent_SetMobility_Params Parms{};

	Parms.NewMobility = NewMobility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.SetHiddenInGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               NewHidden                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPropagateToChildren                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetHiddenInGame(bool NewHidden, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "SetHiddenInGame");

	Params::USceneComponent_SetHiddenInGame_Params Parms{};

	Parms.NewHidden = NewHidden;
	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.SetAbsolute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewAbsoluteLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNewAbsoluteRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNewAbsoluteScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "SetAbsolute");

	Params::USceneComponent_SetAbsolute_Params Parms{};

	Parms.bNewAbsoluteLocation = bNewAbsoluteLocation;
	Parms.bNewAbsoluteRotation = bNewAbsoluteRotation;
	Parms.bNewAbsoluteScale = bNewAbsoluteScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.ResetRelativeTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USceneComponent::ResetRelativeTransform()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "ResetRelativeTransform");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.OnRep_Visibility
// (Final, Native, Private)
// Parameters:
// bool                               OldValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::OnRep_Visibility(bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "OnRep_Visibility");

	Params::USceneComponent_OnRep_Visibility_Params Parms{};

	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.OnRep_Transform
// (Final, Native, Private)
// Parameters:

void USceneComponent::OnRep_Transform()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "OnRep_Transform");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.OnRep_RelativeRotation
// (Final, Native, Private)
// Parameters:

void USceneComponent::OnRep_RelativeRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "OnRep_RelativeRotation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.OnRep_RelativeLocation
// (Final, Native, Private)
// Parameters:

void USceneComponent::OnRep_RelativeLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "OnRep_RelativeLocation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.OnRep_AttachSocketName
// (Final, Native, Private)
// Parameters:

void USceneComponent::OnRep_AttachSocketName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "OnRep_AttachSocketName");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.OnRep_AttachParent
// (Final, Native, Private)
// Parameters:

void USceneComponent::OnRep_AttachParent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "OnRep_AttachParent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.OnRep_AttachChildren
// (Final, Native, Private)
// Parameters:

void USceneComponent::OnRep_AttachChildren()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "OnRep_AttachChildren");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.K2_SetWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  NewTransform                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetWorldTransform(struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_SetWorldTransform");

	Params::USceneComponent_K2_SetWorldTransform_Params Parms{};

	Parms.NewTransform = NewTransform;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_SetWorldRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetWorldRotation(const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_SetWorldRotation");

	Params::USceneComponent_K2_SetWorldRotation_Params Parms{};

	Parms.NewRotation = NewRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_SetWorldLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetWorldLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_SetWorldLocationAndRotation");

	Params::USceneComponent_K2_SetWorldLocationAndRotation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.NewRotation = NewRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_SetWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetWorldLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_SetWorldLocation");

	Params::USceneComponent_K2_SetWorldLocation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_SetRelativeTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  NewTransform                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetRelativeTransform(struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_SetRelativeTransform");

	Params::USceneComponent_K2_SetRelativeTransform_Params Parms{};

	Parms.NewTransform = NewTransform;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_SetRelativeRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetRelativeRotation(const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_SetRelativeRotation");

	Params::USceneComponent_K2_SetRelativeRotation_Params Parms{};

	Parms.NewRotation = NewRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetRelativeLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_SetRelativeLocationAndRotation");

	Params::USceneComponent_K2_SetRelativeLocationAndRotation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.NewRotation = NewRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_SetRelativeLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetRelativeLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_SetRelativeLocation");

	Params::USceneComponent_K2_SetRelativeLocation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_GetComponentToWorld
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USceneComponent::K2_GetComponentToWorld()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_GetComponentToWorld");

	Params::USceneComponent_K2_GetComponentToWorld_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.K2_GetComponentScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::K2_GetComponentScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_GetComponentScale");

	Params::USceneComponent_K2_GetComponentScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.K2_GetComponentRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USceneComponent::K2_GetComponentRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_GetComponentRotation");

	Params::USceneComponent_K2_GetComponentRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.K2_GetComponentLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::K2_GetComponentLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_GetComponentLocation");

	Params::USceneComponent_K2_GetComponentLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.K2_DetachFromComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EDetachmentRule         LocationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDetachmentRule         RotationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDetachmentRule         ScaleRule                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCallModify                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_DetachFromComponent(enum class EDetachmentRule LocationRule, enum class EDetachmentRule RotationRule, enum class EDetachmentRule ScaleRule, bool bCallModify)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_DetachFromComponent");

	Params::USceneComponent_K2_DetachFromComponent_Params Parms{};

	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bCallModify = bCallModify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneComponent.K2_AttachToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             Parent                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SocketName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         LocationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         RotationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         ScaleRule                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bWeldSimulatedBodies                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::K2_AttachToComponent(class USceneComponent* Parent, class FName SocketName, enum class EAttachmentRule LocationRule, enum class EAttachmentRule RotationRule, enum class EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AttachToComponent");

	Params::USceneComponent_K2_AttachToComponent_Params Parms{};

	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.K2_AttachTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             InParent                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachLocation         AttachType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bWeldSimulatedBodies                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::K2_AttachTo(class USceneComponent* InParent, class FName InSocketName, enum class EAttachLocation AttachType, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AttachTo");

	Params::USceneComponent_K2_AttachTo_Params Parms{};

	Parms.InParent = InParent;
	Parms.InSocketName = InSocketName;
	Parms.AttachType = AttachType;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.K2_AddWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  DeltaTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddWorldTransform(struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AddWorldTransform");

	Params::USceneComponent_K2_AddWorldTransform_Params Parms{};

	Parms.DeltaTransform = DeltaTransform;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_AddWorldRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    DeltaRotation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AddWorldRotation");

	Params::USceneComponent_K2_AddWorldRotation_Params Parms{};

	Parms.DeltaRotation = DeltaRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_AddWorldOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DeltaLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddWorldOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AddWorldOffset");

	Params::USceneComponent_K2_AddWorldOffset_Params Parms{};

	Parms.DeltaLocation = DeltaLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_AddRelativeRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    DeltaRotation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddRelativeRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AddRelativeRotation");

	Params::USceneComponent_K2_AddRelativeRotation_Params Parms{};

	Parms.DeltaRotation = DeltaRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_AddRelativeLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DeltaLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddRelativeLocation(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AddRelativeLocation");

	Params::USceneComponent_K2_AddRelativeLocation_Params Parms{};

	Parms.DeltaLocation = DeltaLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_AddLocalTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  DeltaTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddLocalTransform(struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AddLocalTransform");

	Params::USceneComponent_K2_AddLocalTransform_Params Parms{};

	Parms.DeltaTransform = DeltaTransform;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_AddLocalRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    DeltaRotation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AddLocalRotation");

	Params::USceneComponent_K2_AddLocalRotation_Params Parms{};

	Parms.DeltaRotation = DeltaRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.K2_AddLocalOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DeltaLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddLocalOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "K2_AddLocalOffset");

	Params::USceneComponent_K2_AddLocalOffset_Params Parms{};

	Parms.DeltaLocation = DeltaLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.SceneComponent.IsVisible
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::IsVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "IsVisible");

	Params::USceneComponent_IsVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.IsSimulatingPhysics
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::IsSimulatingPhysics(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "IsSimulatingPhysics");

	Params::USceneComponent_IsSimulatingPhysics_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.IsAnySimulatingPhysics
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::IsAnySimulatingPhysics()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "IsAnySimulatingPhysics");

	Params::USceneComponent_IsAnySimulatingPhysics_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetUpVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetUpVector");

	Params::USceneComponent_GetUpVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetSocketTransform
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERelativeTransformSpace TransformSpace                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USceneComponent::GetSocketTransform(class FName InSocketName, enum class ERelativeTransformSpace TransformSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetSocketTransform");

	Params::USceneComponent_GetSocketTransform_Params Parms{};

	Parms.InSocketName = InSocketName;
	Parms.TransformSpace = TransformSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetSocketRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USceneComponent::GetSocketRotation(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetSocketRotation");

	Params::USceneComponent_GetSocketRotation_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetSocketQuaternion
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat USceneComponent::GetSocketQuaternion(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetSocketQuaternion");

	Params::USceneComponent_GetSocketQuaternion_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetSocketLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetSocketLocation(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetSocketLocation");

	Params::USceneComponent_GetSocketLocation_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetShouldUpdatePhysicsVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::GetShouldUpdatePhysicsVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetShouldUpdatePhysicsVolume");

	Params::USceneComponent_GetShouldUpdatePhysicsVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetRightVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetRightVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetRightVector");

	Params::USceneComponent_GetRightVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetRelativeTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USceneComponent::GetRelativeTransform()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetRelativeTransform");

	Params::USceneComponent_GetRelativeTransform_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetPhysicsVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APhysicsVolume*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APhysicsVolume* USceneComponent::GetPhysicsVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetPhysicsVolume");

	Params::USceneComponent_GetPhysicsVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetParentComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class USceneComponent*>     Parents                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USceneComponent::GetParentComponents(TArray<class USceneComponent*>* Parents)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetParentComponents");

	Params::USceneComponent_GetParentComponents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Parents != nullptr)
		*Parents = std::move(Parms.Parents);

}


// Function Engine.SceneComponent.GetNumChildrenComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USceneComponent::GetNumChildrenComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetNumChildrenComponents");

	Params::USceneComponent_GetNumChildrenComponents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetForwardVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetForwardVector");

	Params::USceneComponent_GetForwardVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetComponentVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetComponentVelocity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetComponentVelocity");

	Params::USceneComponent_GetComponentVelocity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetChildrenComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               bIncludeAllDescendants                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>     Children                                                         (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USceneComponent::GetChildrenComponents(bool bIncludeAllDescendants, TArray<class USceneComponent*>* Children)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetChildrenComponents");

	Params::USceneComponent_GetChildrenComponents_Params Parms{};

	Parms.bIncludeAllDescendants = bIncludeAllDescendants;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Children != nullptr)
		*Children = std::move(Parms.Children);

}


// Function Engine.SceneComponent.GetChildComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ChildIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* USceneComponent::GetChildComponent(int32 ChildIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetChildComponent");

	Params::USceneComponent_GetChildComponent_Params Parms{};

	Parms.ChildIndex = ChildIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetAttachSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USceneComponent::GetAttachSocketName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetAttachSocketName");

	Params::USceneComponent_GetAttachSocketName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetAttachParent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* USceneComponent::GetAttachParent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetAttachParent");

	Params::USceneComponent_GetAttachParent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.GetAllSocketNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> USceneComponent::GetAllSocketNames()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "GetAllSocketNames");

	Params::USceneComponent_GetAllSocketNames_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.DoesSocketExist
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::DoesSocketExist(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "DoesSocketExist");

	Params::USceneComponent_DoesSocketExist_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SceneComponent.DetachFromParent
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bMaintainWorldPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCallModify                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::DetachFromParent(bool bMaintainWorldPosition, bool bCallModify)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneComponent", "DetachFromParent");

	Params::USceneComponent_DetachFromParent_Params Parms{};

	Parms.bMaintainWorldPosition = bMaintainWorldPosition;
	Parms.bCallModify = bCallModify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PrimitiveComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UPrimitiveComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PrimitiveComponent");

	return Clss;
}


// PrimitiveComponent Engine.Default__PrimitiveComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPrimitiveComponent* UPrimitiveComponent::GetDefaultObj()
{
	static class UPrimitiveComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPrimitiveComponent*>(UPrimitiveComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PrimitiveComponent.WakeRigidBody
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::WakeRigidBody(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "WakeRigidBody");

	Params::UPrimitiveComponent_WakeRigidBody_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.WakeAllRigidBodies
// (Native, Public, BlueprintCallable)
// Parameters:

void UPrimitiveComponent::WakeAllRigidBodies()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "WakeAllRigidBodies");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetWalkableSlopeOverride
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FWalkableSlopeOverride      NewOverride                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetWalkableSlopeOverride(struct FWalkableSlopeOverride& NewOverride)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetWalkableSlopeOverride");

	Params::UPrimitiveComponent_SetWalkableSlopeOverride_Params Parms{};

	Parms.NewOverride = NewOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetUseCCD
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               InUseCCD                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetUseCCD(bool InUseCCD, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetUseCCD");

	Params::UPrimitiveComponent_SetUseCCD_Params Parms{};

	Parms.InUseCCD = InUseCCD;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetTranslucentSortPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewTranslucentSortPriority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetTranslucentSortPriority(int32 NewTranslucentSortPriority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetTranslucentSortPriority");

	Params::UPrimitiveComponent_SetTranslucentSortPriority_Params Parms{};

	Parms.NewTranslucentSortPriority = NewTranslucentSortPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetSingleSampleShadowFromStationaryLights
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewSingleSampleShadowFromStationaryLights                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetSingleSampleShadowFromStationaryLights(bool bNewSingleSampleShadowFromStationaryLights)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetSingleSampleShadowFromStationaryLights");

	Params::UPrimitiveComponent_SetSingleSampleShadowFromStationaryLights_Params Parms{};

	Parms.bNewSingleSampleShadowFromStationaryLights = bNewSingleSampleShadowFromStationaryLights;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetSimulatePhysics
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bSimulate                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetSimulatePhysics(bool bSimulate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetSimulatePhysics");

	Params::UPrimitiveComponent_SetSimulatePhysics_Params Parms{};

	Parms.bSimulate = bSimulate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetRenderInMainPass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bValue                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetRenderInMainPass(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetRenderInMainPass");

	Params::UPrimitiveComponent_SetRenderInMainPass_Params Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetRenderCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bValue                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetRenderCustomDepth(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetRenderCustomDepth");

	Params::UPrimitiveComponent_SetRenderCustomDepth_Params Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetReceivesDecals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewReceivesDecals                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetReceivesDecals(bool bNewReceivesDecals)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetReceivesDecals");

	Params::UPrimitiveComponent_SetReceivesDecals_Params Parms{};

	Parms.bNewReceivesDecals = bNewReceivesDecals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetPhysMaterialOverride
// (Native, Public, BlueprintCallable)
// Parameters:
// class UPhysicalMaterial*           NewPhysMaterial                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetPhysMaterialOverride");

	Params::UPrimitiveComponent_SetPhysMaterialOverride_Params Parms{};

	Parms.NewPhysMaterial = NewPhysMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInRadians
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewMaxAngVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsMaxAngularVelocityInRadians(float NewMaxAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetPhysicsMaxAngularVelocityInRadians");

	Params::UPrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians_Params Parms{};

	Parms.NewMaxAngVel = NewMaxAngVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInDegrees
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewMaxAngVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsMaxAngularVelocityInDegrees(float NewMaxAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetPhysicsMaxAngularVelocityInDegrees");

	Params::UPrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees_Params Parms{};

	Parms.NewMaxAngVel = NewMaxAngVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewMaxAngVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsMaxAngularVelocity(float NewMaxAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetPhysicsMaxAngularVelocity");

	Params::UPrimitiveComponent_SetPhysicsMaxAngularVelocity_Params Parms{};

	Parms.NewMaxAngVel = NewMaxAngVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewVel                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetPhysicsLinearVelocity");

	Params::UPrimitiveComponent_SetPhysicsLinearVelocity_Params Parms{};

	Parms.NewVel = NewVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewAngVel                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsAngularVelocityInRadians(const struct FVector& NewAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetPhysicsAngularVelocityInRadians");

	Params::UPrimitiveComponent_SetPhysicsAngularVelocityInRadians_Params Parms{};

	Parms.NewAngVel = NewAngVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewAngVel                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsAngularVelocityInDegrees(const struct FVector& NewAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetPhysicsAngularVelocityInDegrees");

	Params::UPrimitiveComponent_SetPhysicsAngularVelocityInDegrees_Params Parms{};

	Parms.NewAngVel = NewAngVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewAngVel                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsAngularVelocity(const struct FVector& NewAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetPhysicsAngularVelocity");

	Params::UPrimitiveComponent_SetPhysicsAngularVelocity_Params Parms{};

	Parms.NewAngVel = NewAngVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetOwnerNoSee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewOwnerNoSee                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetOwnerNoSee(bool bNewOwnerNoSee)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetOwnerNoSee");

	Params::UPrimitiveComponent_SetOwnerNoSee_Params Parms{};

	Parms.bNewOwnerNoSee = bNewOwnerNoSee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetOnlyOwnerSee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewOnlyOwnerSee                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetOnlyOwnerSee(bool bNewOnlyOwnerSee)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetOnlyOwnerSee");

	Params::UPrimitiveComponent_SetOnlyOwnerSee_Params Parms{};

	Parms.bNewOnlyOwnerSee = bNewOnlyOwnerSee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewNotifyRigidBodyCollision                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetNotifyRigidBodyCollision");

	Params::UPrimitiveComponent_SetNotifyRigidBodyCollision_Params Parms{};

	Parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetMaterialByName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        MaterialSlotName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetMaterialByName(class FName MaterialSlotName, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetMaterialByName");

	Params::UPrimitiveComponent_SetMaterialByName_Params Parms{};

	Parms.MaterialSlotName = MaterialSlotName;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              ElementIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetMaterial(int32 ElementIndex, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetMaterial");

	Params::UPrimitiveComponent_SetMaterial_Params Parms{};

	Parms.ElementIndex = ElementIndex;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetMassScale
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InMassScale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetMassScale(class FName BoneName, float InMassScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetMassScale");

	Params::UPrimitiveComponent_SetMassScale_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.InMassScale = InMassScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetMassOverrideInKg
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MassInKg                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOverrideMass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetMassOverrideInKg(class FName BoneName, float MassInKg, bool bOverrideMass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetMassOverrideInKg");

	Params::UPrimitiveComponent_SetMassOverrideInKg_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.MassInKg = MassInKg;
	Parms.bOverrideMass = bOverrideMass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetLinearDamping
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              InDamping                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetLinearDamping(float InDamping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetLinearDamping");

	Params::UPrimitiveComponent_SetLinearDamping_Params Parms{};

	Parms.InDamping = InDamping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetLightAttachmentsAsGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInLightAttachmentsAsGroup                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetLightAttachmentsAsGroup(bool bInLightAttachmentsAsGroup)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetLightAttachmentsAsGroup");

	Params::UPrimitiveComponent_SetLightAttachmentsAsGroup_Params Parms{};

	Parms.bInLightAttachmentsAsGroup = bInLightAttachmentsAsGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetGenerateOverlapEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInGenerateOverlapEvents                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetGenerateOverlapEvents(bool bInGenerateOverlapEvents)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetGenerateOverlapEvents");

	Params::UPrimitiveComponent_SetGenerateOverlapEvents_Params Parms{};

	Parms.bInGenerateOverlapEvents = bInGenerateOverlapEvents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetEnableGravity
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bGravityEnabled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetEnableGravity(bool bGravityEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetEnableGravity");

	Params::UPrimitiveComponent_SetEnableGravity_Params Parms{};

	Parms.bGravityEnabled = bGravityEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector4
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              DataIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomPrimitiveDataVector4(int32 DataIndex, const struct FVector4& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCustomPrimitiveDataVector4");

	Params::UPrimitiveComponent_SetCustomPrimitiveDataVector4_Params Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector3
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              DataIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomPrimitiveDataVector3(int32 DataIndex, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCustomPrimitiveDataVector3");

	Params::UPrimitiveComponent_SetCustomPrimitiveDataVector3_Params Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector2
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              DataIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomPrimitiveDataVector2(int32 DataIndex, const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCustomPrimitiveDataVector2");

	Params::UPrimitiveComponent_SetCustomPrimitiveDataVector2_Params Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              DataIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomPrimitiveDataFloat(int32 DataIndex, float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCustomPrimitiveDataFloat");

	Params::UPrimitiveComponent_SetCustomPrimitiveDataFloat_Params Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCustomDepthStencilWriteMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ERendererStencilMask    WriteMaskBit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomDepthStencilWriteMask(enum class ERendererStencilMask WriteMaskBit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCustomDepthStencilWriteMask");

	Params::UPrimitiveComponent_SetCustomDepthStencilWriteMask_Params Parms{};

	Parms.WriteMaskBit = WriteMaskBit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCustomDepthStencilValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomDepthStencilValue(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCustomDepthStencilValue");

	Params::UPrimitiveComponent_SetCustomDepthStencilValue_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCullDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewCullDistance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCullDistance(float NewCullDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCullDistance");

	Params::UPrimitiveComponent_SetCullDistance_Params Parms{};

	Parms.NewCullDistance = NewCullDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetConstraintMode
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EDOFMode                ConstraintMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetConstraintMode(enum class EDOFMode ConstraintMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetConstraintMode");

	Params::UPrimitiveComponent_SetConstraintMode_Params Parms{};

	Parms.ConstraintMode = ConstraintMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCollisionResponseToChannel
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class ECollisionChannel       Channel                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECollisionResponse      NewResponse                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionResponseToChannel(enum class ECollisionChannel Channel, enum class ECollisionResponse NewResponse)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCollisionResponseToChannel");

	Params::UPrimitiveComponent_SetCollisionResponseToChannel_Params Parms{};

	Parms.Channel = Channel;
	Parms.NewResponse = NewResponse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class ECollisionResponse      NewResponse                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionResponseToAllChannels(enum class ECollisionResponse NewResponse)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCollisionResponseToAllChannels");

	Params::UPrimitiveComponent_SetCollisionResponseToAllChannels_Params Parms{};

	Parms.NewResponse = NewResponse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCollisionProfileName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InCollisionProfileName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionProfileName(class FName InCollisionProfileName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCollisionProfileName");

	Params::UPrimitiveComponent_SetCollisionProfileName_Params Parms{};

	Parms.InCollisionProfileName = InCollisionProfileName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCollisionObjectType
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class ECollisionChannel       Channel                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionObjectType(enum class ECollisionChannel Channel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCollisionObjectType");

	Params::UPrimitiveComponent_SetCollisionObjectType_Params Parms{};

	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCollisionEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class ECollisionEnabled       NewType                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionEnabled(enum class ECollisionEnabled NewType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCollisionEnabled");

	Params::UPrimitiveComponent_SetCollisionEnabled_Params Parms{};

	Parms.NewType = NewType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     CenterOfMassOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCenterOfMass(const struct FVector& CenterOfMassOffset, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCenterOfMass");

	Params::UPrimitiveComponent_SetCenterOfMass_Params Parms{};

	Parms.CenterOfMassOffset = CenterOfMassOffset;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCastShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               NewCastShadow                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCastShadow(bool NewCastShadow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCastShadow");

	Params::UPrimitiveComponent_SetCastShadow_Params Parms{};

	Parms.NewCastShadow = NewCastShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetCastInsetShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInCastInsetShadow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCastInsetShadow(bool bInCastInsetShadow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetCastInsetShadow");

	Params::UPrimitiveComponent_SetCastInsetShadow_Params Parms{};

	Parms.bInCastInsetShadow = bInCastInsetShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetBoundsScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewBoundsScale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetBoundsScale(float NewBoundsScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetBoundsScale");

	Params::UPrimitiveComponent_SetBoundsScale_Params Parms{};

	Parms.NewBoundsScale = NewBoundsScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetAngularDamping
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              InDamping                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAngularDamping(float InDamping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetAngularDamping");

	Params::UPrimitiveComponent_SetAngularDamping_Params Parms{};

	Parms.InDamping = InDamping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetAllUseCCD
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               InUseCCD                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllUseCCD(bool InUseCCD)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetAllUseCCD");

	Params::UPrimitiveComponent_SetAllUseCCD_Params Parms{};

	Parms.InUseCCD = InUseCCD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewVel                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetAllPhysicsLinearVelocity");

	Params::UPrimitiveComponent_SetAllPhysicsLinearVelocity_Params Parms{};

	Parms.NewVel = NewVel;
	Parms.bAddToCurrent = bAddToCurrent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInRadians
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewAngVel                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllPhysicsAngularVelocityInRadians(struct FVector& NewAngVel, bool bAddToCurrent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetAllPhysicsAngularVelocityInRadians");

	Params::UPrimitiveComponent_SetAllPhysicsAngularVelocityInRadians_Params Parms{};

	Parms.NewAngVel = NewAngVel;
	Parms.bAddToCurrent = bAddToCurrent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewAngVel                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToCurrent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllPhysicsAngularVelocityInDegrees(struct FVector& NewAngVel, bool bAddToCurrent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetAllPhysicsAngularVelocityInDegrees");

	Params::UPrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees_Params Parms{};

	Parms.NewAngVel = NewAngVel;
	Parms.bAddToCurrent = bAddToCurrent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.SetAllMassScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              InMassScale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllMassScale(float InMassScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "SetAllMassScale");

	Params::UPrimitiveComponent_SetAllMassScale_Params Parms{};

	Parms.InMassScale = InMassScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.ScaleByMomentOfInertia
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     InputVector                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::ScaleByMomentOfInertia(const struct FVector& InputVector, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "ScaleByMomentOfInertia");

	Params::UPrimitiveComponent_ScaleByMomentOfInertia_Params Parms{};

	Parms.InputVector = InputVector;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.PutRigidBodyToSleep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::PutRigidBodyToSleep(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "PutRigidBodyToSleep");

	Params::UPrimitiveComponent_PutRigidBodyToSleep_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.K2_SphereTraceComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     TraceStart                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TraceEnd                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SphereRadius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShowTrace                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPersistentShowTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_SphereTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, float SphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "K2_SphereTraceComponent");

	Params::UPrimitiveComponent_K2_SphereTraceComponent_Params Parms{};

	Parms.TraceStart = TraceStart;
	Parms.TraceEnd = TraceEnd;
	Parms.SphereRadius = SphereRadius;
	Parms.bTraceComplex = bTraceComplex;
	Parms.bShowTrace = bShowTrace;
	Parms.bPersistentShowTrace = bPersistentShowTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.K2_SphereOverlapComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InSphereCentre                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InSphereRadius                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShowTrace                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPersistentShowTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_SphereOverlapComponent(const struct FVector& InSphereCentre, float InSphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "K2_SphereOverlapComponent");

	Params::UPrimitiveComponent_K2_SphereOverlapComponent_Params Parms{};

	Parms.InSphereCentre = InSphereCentre;
	Parms.InSphereRadius = InSphereRadius;
	Parms.bTraceComplex = bTraceComplex;
	Parms.bShowTrace = bShowTrace;
	Parms.bPersistentShowTrace = bPersistentShowTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.K2_LineTraceComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     TraceStart                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TraceEnd                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShowTrace                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPersistentShowTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_LineTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "K2_LineTraceComponent");

	Params::UPrimitiveComponent_K2_LineTraceComponent_Params Parms{};

	Parms.TraceStart = TraceStart;
	Parms.TraceEnd = TraceEnd;
	Parms.bTraceComplex = bTraceComplex;
	Parms.bShowTrace = bShowTrace;
	Parms.bPersistentShowTrace = bPersistentShowTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.K2_IsQueryCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_IsQueryCollisionEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "K2_IsQueryCollisionEnabled");

	Params::UPrimitiveComponent_K2_IsQueryCollisionEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.K2_IsPhysicsCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_IsPhysicsCollisionEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "K2_IsPhysicsCollisionEnabled");

	Params::UPrimitiveComponent_K2_IsPhysicsCollisionEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.K2_IsCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_IsCollisionEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "K2_IsCollisionEnabled");

	Params::UPrimitiveComponent_K2_IsCollisionEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.K2_BoxOverlapComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InBoxCentre                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                        InBox                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShowTrace                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPersistentShowTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_BoxOverlapComponent(const struct FVector& InBoxCentre, const struct FBox& InBox, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "K2_BoxOverlapComponent");

	Params::UPrimitiveComponent_K2_BoxOverlapComponent_Params Parms{};

	Parms.InBoxCentre = InBoxCentre;
	Parms.InBox = InBox;
	Parms.bTraceComplex = bTraceComplex;
	Parms.bShowTrace = bShowTrace;
	Parms.bPersistentShowTrace = bPersistentShowTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.IsOverlappingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*         OtherComp                                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::IsOverlappingComponent(class UPrimitiveComponent* OtherComp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "IsOverlappingComponent");

	Params::UPrimitiveComponent_IsOverlappingComponent_Params Parms{};

	Parms.OtherComp = OtherComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.IsOverlappingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      Other                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::IsOverlappingActor(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "IsOverlappingActor");

	Params::UPrimitiveComponent_IsOverlappingActor_Params Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.IsGravityEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::IsGravityEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "IsGravityEnabled");

	Params::UPrimitiveComponent_IsGravityEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.IsAnyRigidBodyAwake
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::IsAnyRigidBodyAwake()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "IsAnyRigidBodyAwake");

	Params::UPrimitiveComponent_IsAnyRigidBodyAwake_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.IgnoreComponentWhenMoving
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::IgnoreComponentWhenMoving(class UPrimitiveComponent* Component, bool bShouldIgnore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "IgnoreComponentWhenMoving");

	Params::UPrimitiveComponent_IgnoreComponentWhenMoving_Params Parms{};

	Parms.Component = Component;
	Parms.bShouldIgnore = bShouldIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.IgnoreActorWhenMoving
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::IgnoreActorWhenMoving(class AActor* Actor, bool bShouldIgnore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "IgnoreActorWhenMoving");

	Params::UPrimitiveComponent_IgnoreActorWhenMoving_Params Parms{};

	Parms.Actor = Actor;
	Parms.bShouldIgnore = bShouldIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.GetWalkableSlopeOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWalkableSlopeOverride      ReturnValue                                                      (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FWalkableSlopeOverride UPrimitiveComponent::GetWalkableSlopeOverride()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetWalkableSlopeOverride");

	Params::UPrimitiveComponent_GetWalkableSlopeOverride_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsLinearVelocityAtPoint(const struct FVector& Point, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetPhysicsLinearVelocityAtPoint");

	Params::UPrimitiveComponent_GetPhysicsLinearVelocityAtPoint_Params Parms{};

	Parms.Point = Point;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsLinearVelocity(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetPhysicsLinearVelocity");

	Params::UPrimitiveComponent_GetPhysicsLinearVelocity_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInRadians
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsAngularVelocityInRadians(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetPhysicsAngularVelocityInRadians");

	Params::UPrimitiveComponent_GetPhysicsAngularVelocityInRadians_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsAngularVelocityInDegrees(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetPhysicsAngularVelocityInDegrees");

	Params::UPrimitiveComponent_GetPhysicsAngularVelocityInDegrees_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsAngularVelocity(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetPhysicsAngularVelocity");

	Params::UPrimitiveComponent_GetPhysicsAngularVelocity_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetOverlappingComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UPrimitiveComponent*> OutOverlappingComponents                                         (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPrimitiveComponent::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* OutOverlappingComponents)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetOverlappingComponents");

	Params::UPrimitiveComponent_GetOverlappingComponents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutOverlappingComponents != nullptr)
		*OutOverlappingComponents = std::move(Parms.OutOverlappingComponents);

}


// Function Engine.PrimitiveComponent.GetOverlappingActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>              OverlappingActors                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>          ClassFilter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::GetOverlappingActors(TArray<class AActor*>* OverlappingActors, TSubclassOf<class AActor> ClassFilter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetOverlappingActors");

	Params::UPrimitiveComponent_GetOverlappingActors_Params Parms{};

	Parms.ClassFilter = ClassFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OverlappingActors != nullptr)
		*OverlappingActors = std::move(Parms.OverlappingActors);

}


// Function Engine.PrimitiveComponent.GetNumMaterials
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPrimitiveComponent::GetNumMaterials()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetNumMaterials");

	Params::UPrimitiveComponent_GetNumMaterials_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetMaterialFromCollisionFaceIndex
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              FaceIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SectionIndex                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UPrimitiveComponent::GetMaterialFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetMaterialFromCollisionFaceIndex");

	Params::UPrimitiveComponent_GetMaterialFromCollisionFaceIndex_Params Parms{};

	Parms.FaceIndex = FaceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SectionIndex != nullptr)
		*SectionIndex = Parms.SectionIndex;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ElementIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UPrimitiveComponent::GetMaterial(int32 ElementIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetMaterial");

	Params::UPrimitiveComponent_GetMaterial_Params Parms{};

	Parms.ElementIndex = ElementIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetMassScale
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetMassScale(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetMassScale");

	Params::UPrimitiveComponent_GetMassScale_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetMass
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetMass()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetMass");

	Params::UPrimitiveComponent_GetMass_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetLinearDamping
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetLinearDamping()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetLinearDamping");

	Params::UPrimitiveComponent_GetLinearDamping_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetInertiaTensor
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetInertiaTensor(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetInertiaTensor");

	Params::UPrimitiveComponent_GetInertiaTensor_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetGenerateOverlapEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::GetGenerateOverlapEvents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetGenerateOverlapEvents");

	Params::UPrimitiveComponent_GetGenerateOverlapEvents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetCollisionResponseToChannel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECollisionChannel       Channel                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECollisionResponse      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECollisionResponse UPrimitiveComponent::GetCollisionResponseToChannel(enum class ECollisionChannel Channel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetCollisionResponseToChannel");

	Params::UPrimitiveComponent_GetCollisionResponseToChannel_Params Parms{};

	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetCollisionProfileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UPrimitiveComponent::GetCollisionProfileName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetCollisionProfileName");

	Params::UPrimitiveComponent_GetCollisionProfileName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetCollisionObjectType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECollisionChannel       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECollisionChannel UPrimitiveComponent::GetCollisionObjectType()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetCollisionObjectType");

	Params::UPrimitiveComponent_GetCollisionObjectType_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetCollisionEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECollisionEnabled       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ECollisionEnabled UPrimitiveComponent::GetCollisionEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetCollisionEnabled");

	Params::UPrimitiveComponent_GetCollisionEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetClosestPointOnCollision
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Point                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutPointOnBody                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetClosestPointOnCollision(struct FVector& Point, struct FVector* OutPointOnBody, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetClosestPointOnCollision");

	Params::UPrimitiveComponent_GetClosestPointOnCollision_Params Parms{};

	Parms.Point = Point;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPointOnBody != nullptr)
		*OutPointOnBody = std::move(Parms.OutPointOnBody);

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetCenterOfMass(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetCenterOfMass");

	Params::UPrimitiveComponent_GetCenterOfMass_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.GetAngularDamping
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetAngularDamping()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "GetAngularDamping");

	Params::UPrimitiveComponent_GetAngularDamping_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              ElementIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          SourceMaterial                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        OptionalName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UPrimitiveComponent::CreateDynamicMaterialInstance(int32 ElementIndex, class UMaterialInterface* SourceMaterial, class FName OptionalName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "CreateDynamicMaterialInstance");

	Params::UPrimitiveComponent_CreateDynamicMaterialInstance_Params Parms{};

	Parms.ElementIndex = ElementIndex;
	Parms.SourceMaterial = SourceMaterial;
	Parms.OptionalName = OptionalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              ElementIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          Parent                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamicFromMaterial(int32 ElementIndex, class UMaterialInterface* Parent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "CreateAndSetMaterialInstanceDynamicFromMaterial");

	Params::UPrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial_Params Parms{};

	Parms.ElementIndex = ElementIndex;
	Parms.Parent = Parent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              ElementIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic(int32 ElementIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "CreateAndSetMaterialInstanceDynamic");

	Params::UPrimitiveComponent_CreateAndSetMaterialInstanceDynamic_Params Parms{};

	Parms.ElementIndex = ElementIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*> ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPrimitiveComponent*> UPrimitiveComponent::CopyArrayOfMoveIgnoreComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "CopyArrayOfMoveIgnoreComponents");

	Params::UPrimitiveComponent_CopyArrayOfMoveIgnoreComponents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UPrimitiveComponent::CopyArrayOfMoveIgnoreActors()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "CopyArrayOfMoveIgnoreActors");

	Params::UPrimitiveComponent_CopyArrayOfMoveIgnoreActors_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.ClearMoveIgnoreComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPrimitiveComponent::ClearMoveIgnoreComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "ClearMoveIgnoreComponents");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.ClearMoveIgnoreActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPrimitiveComponent::ClearMoveIgnoreActors()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "ClearMoveIgnoreActors");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.CanCharacterStepUp
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                       Pawn                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::CanCharacterStepUp(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "CanCharacterStepUp");

	Params::UPrimitiveComponent_CanCharacterStepUp_Params Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PrimitiveComponent.AddTorqueInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Torque                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAccelChange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddTorqueInRadians(const struct FVector& Torque, class FName BoneName, bool bAccelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddTorqueInRadians");

	Params::UPrimitiveComponent_AddTorqueInRadians_Params Parms{};

	Parms.Torque = Torque;
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddTorqueInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Torque                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAccelChange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddTorqueInDegrees(const struct FVector& Torque, class FName BoneName, bool bAccelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddTorqueInDegrees");

	Params::UPrimitiveComponent_AddTorqueInDegrees_Params Parms{};

	Parms.Torque = Torque;
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddTorque
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Torque                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAccelChange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddTorque(const struct FVector& Torque, class FName BoneName, bool bAccelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddTorque");

	Params::UPrimitiveComponent_AddTorque_Params Parms{};

	Parms.Torque = Torque;
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddRadialImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Origin                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Strength                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERadialImpulseFalloff   Falloff                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bVelChange                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, enum class ERadialImpulseFalloff Falloff, bool bVelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddRadialImpulse");

	Params::UPrimitiveComponent_AddRadialImpulse_Params Parms{};

	Parms.Origin = Origin;
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;
	Parms.bVelChange = bVelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddRadialForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Origin                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Strength                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERadialImpulseFalloff   Falloff                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAccelChange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddRadialForce(const struct FVector& Origin, float Radius, float Strength, enum class ERadialImpulseFalloff Falloff, bool bAccelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddRadialForce");

	Params::UPrimitiveComponent_AddRadialForce_Params Parms{};

	Parms.Origin = Origin;
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;
	Parms.bAccelChange = bAccelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddImpulseAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddImpulseAtLocation(const struct FVector& Impulse, const struct FVector& Location, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddImpulseAtLocation");

	Params::UPrimitiveComponent_AddImpulseAtLocation_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.Location = Location;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bVelChange                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddImpulse(const struct FVector& Impulse, class FName BoneName, bool bVelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddImpulse");

	Params::UPrimitiveComponent_AddImpulse_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddForceAtLocationLocal
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddForceAtLocationLocal(const struct FVector& Force, const struct FVector& Location, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddForceAtLocationLocal");

	Params::UPrimitiveComponent_AddForceAtLocationLocal_Params Parms{};

	Parms.Force = Force;
	Parms.Location = Location;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddForceAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddForceAtLocation(const struct FVector& Force, const struct FVector& Location, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddForceAtLocation");

	Params::UPrimitiveComponent_AddForceAtLocation_Params Parms{};

	Parms.Force = Force;
	Parms.Location = Location;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAccelChange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddForce(const struct FVector& Force, class FName BoneName, bool bAccelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddForce");

	Params::UPrimitiveComponent_AddForce_Params Parms{};

	Parms.Force = Force;
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddAngularImpulseInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bVelChange                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddAngularImpulseInRadians(const struct FVector& Impulse, class FName BoneName, bool bVelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddAngularImpulseInRadians");

	Params::UPrimitiveComponent_AddAngularImpulseInRadians_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddAngularImpulseInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bVelChange                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddAngularImpulseInDegrees(const struct FVector& Impulse, class FName BoneName, bool bVelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddAngularImpulseInDegrees");

	Params::UPrimitiveComponent_AddAngularImpulseInDegrees_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PrimitiveComponent.AddAngularImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bVelChange                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddAngularImpulse(const struct FVector& Impulse, class FName BoneName, bool bVelChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PrimitiveComponent", "AddAngularImpulse");

	Params::UPrimitiveComponent_AddAngularImpulse_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.MeshComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MeshComponent");

	return Clss;
}


// MeshComponent Engine.Default__MeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMeshComponent* UMeshComponent::GetDefaultObj()
{
	static class UMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMeshComponent*>(UMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.MeshComponent.SetVectorParameterValueOnMaterials
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ParameterValue                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshComponent::SetVectorParameterValueOnMaterials(class FName ParameterName, const struct FVector& ParameterValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshComponent", "SetVectorParameterValueOnMaterials");

	Params::UMeshComponent_SetVectorParameterValueOnMaterials_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MeshComponent.SetScalarParameterValueOnMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ParameterValue                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshComponent::SetScalarParameterValueOnMaterials(class FName ParameterName, float ParameterValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshComponent", "SetScalarParameterValueOnMaterials");

	Params::UMeshComponent_SetScalarParameterValueOnMaterials_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MeshComponent.PrestreamTextures
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Seconds                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPrioritizeCharacterTextures                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CinematicTextureGroups                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshComponent::PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshComponent", "PrestreamTextures");

	Params::UMeshComponent_PrestreamTextures_Params Parms{};

	Parms.Seconds = Seconds;
	Parms.bPrioritizeCharacterTextures = bPrioritizeCharacterTextures;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MeshComponent.IsMaterialSlotNameValid
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        MaterialSlotName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMeshComponent::IsMaterialSlotNameValid(class FName MaterialSlotName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshComponent", "IsMaterialSlotNameValid");

	Params::UMeshComponent_IsMaterialSlotNameValid_Params Parms{};

	Parms.MaterialSlotName = MaterialSlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MeshComponent.GetMaterialSlotNames
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UMeshComponent::GetMaterialSlotNames()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshComponent", "GetMaterialSlotNames");

	Params::UMeshComponent_GetMaterialSlotNames_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MeshComponent.GetMaterials
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMaterialInterface*>  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInterface*> UMeshComponent::GetMaterials()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshComponent", "GetMaterials");

	Params::UMeshComponent_GetMaterials_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MeshComponent.GetMaterialIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        MaterialSlotName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMeshComponent::GetMaterialIndex(class FName MaterialSlotName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshComponent", "GetMaterialIndex");

	Params::UMeshComponent_GetMaterialIndex_Params Parms{};

	Parms.MaterialSlotName = MaterialSlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.SkinnedMeshComponent
// (SceneComponent, PrimitiveComponent, SkinnedMeshComponent)

class UClass* USkinnedMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkinnedMeshComponent");

	return Clss;
}


// SkinnedMeshComponent Engine.Default__SkinnedMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USkinnedMeshComponent* USkinnedMeshComponent::GetDefaultObj()
{
	static class USkinnedMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USkinnedMeshComponent*>(USkinnedMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SkinnedMeshComponent.UnloadSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InProfileName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::UnloadSkinWeightProfile(class FName InProfileName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "UnloadSkinWeightProfile");

	Params::USkinnedMeshComponent_UnloadSkinWeightProfile_Params Parms{};

	Parms.InProfileName = InProfileName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.UnHideBoneByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::UnHideBoneByName(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "UnHideBoneByName");

	Params::USkinnedMeshComponent_UnHideBoneByName_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.TransformToBoneSpace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InPosition                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    InRotation                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     OutPosition                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    OutRotation                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::TransformToBoneSpace(class FName BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "TransformToBoneSpace");

	Params::USkinnedMeshComponent_TransformToBoneSpace_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.InPosition = InPosition;
	Parms.InRotation = InRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);

}


// Function Engine.SkinnedMeshComponent.TransformFromBoneSpace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InPosition                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    InRotation                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     OutPosition                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    OutRotation                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::TransformFromBoneSpace(class FName BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "TransformFromBoneSpace");

	Params::USkinnedMeshComponent_TransformFromBoneSpace_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.InPosition = InPosition;
	Parms.InRotation = InRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);

}


// Function Engine.SkinnedMeshComponent.ShowMaterialSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              MaterialID                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShow                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::ShowMaterialSection(int32 MaterialID, bool bShow, int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "ShowMaterialSection");

	Params::USkinnedMeshComponent_ShowMaterialSection_Params Parms{};

	Parms.MaterialID = MaterialID;
	Parms.bShow = bShow;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.ShowAllMaterialSections
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::ShowAllMaterialSections(int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "ShowAllMaterialSections");

	Params::USkinnedMeshComponent_ShowAllMaterialSections_Params Parms{};

	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetVertexColorOverride_LinearColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>        VertexColors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetVertexColorOverride_LinearColor(int32 LODIndex, TArray<struct FLinearColor>& VertexColors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetVertexColorOverride_LinearColor");

	Params::USkinnedMeshComponent_SetVertexColorOverride_LinearColor_Params Parms{};

	Parms.LODIndex = LODIndex;
	Parms.VertexColors = VertexColors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InProfileName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::SetSkinWeightProfile(class FName InProfileName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetSkinWeightProfile");

	Params::USkinnedMeshComponent_SetSkinWeightProfile_Params Parms{};

	Parms.InProfileName = InProfileName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.SetSkinWeightOverride
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSkelMeshSkinWeightInfo>SkinWeights                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetSkinWeightOverride(int32 LODIndex, TArray<struct FSkelMeshSkinWeightInfo>& SkinWeights)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetSkinWeightOverride");

	Params::USkinnedMeshComponent_SetSkinWeightOverride_Params Parms{};

	Parms.LODIndex = LODIndex;
	Parms.SkinWeights = SkinWeights;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetSkeletalMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*               NewMesh                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bReinitPose                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetSkeletalMesh(class USkeletalMesh* NewMesh, bool bReinitPose)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetSkeletalMesh");

	Params::USkinnedMeshComponent_SetSkeletalMesh_Params Parms{};

	Parms.NewMesh = NewMesh;
	Parms.bReinitPose = bReinitPose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetRenderStatic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetRenderStatic(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetRenderStatic");

	Params::USkinnedMeshComponent_SetRenderStatic_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetPhysicsAsset
// (Native, Public, BlueprintCallable)
// Parameters:
// class UPhysicsAsset*               NewPhysicsAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForceReInit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetPhysicsAsset");

	Params::USkinnedMeshComponent_SetPhysicsAsset_Params Parms{};

	Parms.NewPhysicsAsset = NewPhysicsAsset;
	Parms.bForceReInit = bForceReInit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetMinLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              InNewMinLOD                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetMinLOD(int32 InNewMinLOD)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetMinLOD");

	Params::USkinnedMeshComponent_SetMinLOD_Params Parms{};

	Parms.InNewMinLOD = InNewMinLOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkinnedMeshComponent*       NewMasterBoneComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForceUpdate                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetMasterPoseComponent(class USkinnedMeshComponent* NewMasterBoneComponent, bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetMasterPoseComponent");

	Params::USkinnedMeshComponent_SetMasterPoseComponent_Params Parms{};

	Parms.NewMasterBoneComponent = NewMasterBoneComponent;
	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetForcedLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              InNewForcedLOD                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetForcedLOD(int32 InNewForcedLOD)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetForcedLOD");

	Params::USkinnedMeshComponent_SetForcedLOD_Params Parms{};

	Parms.InNewForcedLOD = InNewForcedLOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetCastCapsuleIndirectShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetCastCapsuleIndirectShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetCastCapsuleIndirectShadow");

	Params::USkinnedMeshComponent_SetCastCapsuleIndirectShadow_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetCastCapsuleDirectShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetCastCapsuleDirectShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetCastCapsuleDirectShadow");

	Params::USkinnedMeshComponent_SetCastCapsuleDirectShadow_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.SetCapsuleIndirectShadowMinVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetCapsuleIndirectShadowMinVisibility(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "SetCapsuleIndirectShadowMinVisibility");

	Params::USkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.IsUsingSkinWeightProfile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::IsUsingSkinWeightProfile()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "IsUsingSkinWeightProfile");

	Params::USkinnedMeshComponent_IsUsingSkinWeightProfile_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.IsMaterialSectionShown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              MaterialID                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::IsMaterialSectionShown(int32 MaterialID, int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "IsMaterialSectionShown");

	Params::USkinnedMeshComponent_IsMaterialSectionShown_Params Parms{};

	Parms.MaterialID = MaterialID;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.IsBoneHiddenByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::IsBoneHiddenByName(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "IsBoneHiddenByName");

	Params::USkinnedMeshComponent_IsBoneHiddenByName_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.HideBoneByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPhysBodyOp             PhysBodyOption                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::HideBoneByName(class FName BoneName, enum class EPhysBodyOp PhysBodyOption)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "HideBoneByName");

	Params::USkinnedMeshComponent_HideBoneByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.PhysBodyOption = PhysBodyOption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.GetTwistAndSwingAngleOfDeltaRotationFromRefPose
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutTwistAngle                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutSwingAngle                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::GetTwistAndSwingAngleOfDeltaRotationFromRefPose(class FName BoneName, float* OutTwistAngle, float* OutSwingAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetTwistAndSwingAngleOfDeltaRotationFromRefPose");

	Params::USkinnedMeshComponent_GetTwistAndSwingAngleOfDeltaRotationFromRefPose_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTwistAngle != nullptr)
		*OutTwistAngle = Parms.OutTwistAngle;

	if (OutSwingAngle != nullptr)
		*OutSwingAngle = Parms.OutSwingAngle;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetSocketBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::GetSocketBoneName(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetSocketBoneName");

	Params::USkinnedMeshComponent_GetSocketBoneName_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetRefPosePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              BoneIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USkinnedMeshComponent::GetRefPosePosition(int32 BoneIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetRefPosePosition");

	Params::USkinnedMeshComponent_GetRefPosePosition_Params Parms{};

	Parms.BoneIndex = BoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetParentBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::GetParentBone(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetParentBone");

	Params::USkinnedMeshComponent_GetParentBone_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetNumLODs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetNumLODs()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetNumLODs");

	Params::USkinnedMeshComponent_GetNumLODs_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetNumBones
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetNumBones()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetNumBones");

	Params::USkinnedMeshComponent_GetNumBones_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetForcedLOD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetForcedLOD()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetForcedLOD");

	Params::USkinnedMeshComponent_GetForcedLOD_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetDeltaTransformFromRefPose
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BaseName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USkinnedMeshComponent::GetDeltaTransformFromRefPose(class FName BoneName, class FName BaseName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetDeltaTransformFromRefPose");

	Params::USkinnedMeshComponent_GetDeltaTransformFromRefPose_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.BaseName = BaseName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetCurrentSkinWeightProfileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::GetCurrentSkinWeightProfileName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetCurrentSkinWeightProfileName");

	Params::USkinnedMeshComponent_GetCurrentSkinWeightProfileName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              BoneIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::GetBoneName(int32 BoneIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetBoneName");

	Params::USkinnedMeshComponent_GetBoneName_Params Parms{};

	Parms.BoneIndex = BoneIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.GetBoneIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetBoneIndex(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "GetBoneIndex");

	Params::USkinnedMeshComponent_GetBoneIndex_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.FindClosestBone_K2
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     TestLocation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoneLocation                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              IgnoreScale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRequirePhysicsAsset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::FindClosestBone_K2(const struct FVector& TestLocation, struct FVector* BoneLocation, float IgnoreScale, bool bRequirePhysicsAsset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "FindClosestBone_K2");

	Params::USkinnedMeshComponent_FindClosestBone_K2_Params Parms{};

	Parms.TestLocation = TestLocation;
	Parms.IgnoreScale = IgnoreScale;
	Parms.bRequirePhysicsAsset = bRequirePhysicsAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (BoneLocation != nullptr)
		*BoneLocation = std::move(Parms.BoneLocation);

	return Parms.ReturnValue;

}


// Function Engine.SkinnedMeshComponent.ClearVertexColorOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::ClearVertexColorOverride(int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "ClearVertexColorOverride");

	Params::USkinnedMeshComponent_ClearVertexColorOverride_Params Parms{};

	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.ClearSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkinnedMeshComponent::ClearSkinWeightProfile()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "ClearSkinWeightProfile");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.ClearSkinWeightOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::ClearSkinWeightOverride(int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "ClearSkinWeightOverride");

	Params::USkinnedMeshComponent_ClearSkinWeightOverride_Params Parms{};

	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkinnedMeshComponent.BoneIsChildOf
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ParentBoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::BoneIsChildOf(class FName BoneName, class FName ParentBoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkinnedMeshComponent", "BoneIsChildOf");

	Params::USkinnedMeshComponent_BoneIsChildOf_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.ParentBoneName = ParentBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.SkeletalMeshComponent
// (SceneComponent, PrimitiveComponent, SkinnedMeshComponent, SkeletalMeshComponent)

class UClass* USkeletalMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkeletalMeshComponent");

	return Clss;
}


// SkeletalMeshComponent Engine.Default__SkeletalMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USkeletalMeshComponent* USkeletalMeshComponent::GetDefaultObj()
{
	static class USkeletalMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USkeletalMeshComponent*>(USkeletalMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bRestoreSimulationSpace                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::UnbindClothFromMasterPoseComponent(bool bRestoreSimulationSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "UnbindClothFromMasterPoseComponent");

	Params::USkeletalMeshComponent_UnbindClothFromMasterPoseComponent_Params Parms{};

	Parms.bRestoreSimulationSpace = bRestoreSimulationSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.ToggleDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::ToggleDisablePostProcessBlueprint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ToggleDisablePostProcessBlueprint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.TermBodiesBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParentBoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::TermBodiesBelow(class FName ParentBoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "TermBodiesBelow");

	Params::USkeletalMeshComponent_TermBodiesBelow_Params Parms{};

	Parms.ParentBoneName = ParentBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SuspendClothingSimulation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::SuspendClothingSimulation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SuspendClothingSimulation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "Stop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SnapshotPose
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseSnapshot               Snapshot                                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SnapshotPose(struct FPoseSnapshot& Snapshot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SnapshotPose");

	Params::USkeletalMeshComponent_SnapshotPose_Params Parms{};

	Parms.Snapshot = Snapshot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetUpdateAnimationInEditor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               NewUpdateState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetUpdateAnimationInEditor(bool NewUpdateState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetUpdateAnimationInEditor");

	Params::USkeletalMeshComponent_SetUpdateAnimationInEditor_Params Parms{};

	Parms.NewUpdateState = NewUpdateState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetTeleportRotationThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Threshold                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetTeleportRotationThreshold(float Threshold)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetTeleportRotationThreshold");

	Params::USkeletalMeshComponent_SetTeleportRotationThreshold_Params Parms{};

	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetTeleportDistanceThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Threshold                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetTeleportDistanceThreshold(float Threshold)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetTeleportDistanceThreshold");

	Params::USkeletalMeshComponent_SetTeleportDistanceThreshold_Params Parms{};

	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InPos                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFireNotifies                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetPosition(float InPos, bool bFireNotifies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetPosition");

	Params::USkeletalMeshComponent_SetPosition_Params Parms{};

	Parms.InPos = InPos;
	Parms.bFireNotifies = bFireNotifies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Rate                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetPlayRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetPlayRate");

	Params::USkeletalMeshComponent_SetPlayRate_Params Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              PhysicsBlendWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetPhysicsBlendWeight(float PhysicsBlendWeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetPhysicsBlendWeight");

	Params::USkeletalMeshComponent_SetPhysicsBlendWeight_Params Parms{};

	Parms.PhysicsBlendWeight = PhysicsBlendWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetNotifyRigidBodyCollisionBelow
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewNotifyRigidBodyCollision                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludeSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, class FName BoneName, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetNotifyRigidBodyCollisionBelow");

	Params::USkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow_Params Parms{};

	Parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
	Parms.BoneName = BoneName;
	Parms.bIncludeSelf = bIncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetMorphTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        MorphTargetName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRemoveZeroWeight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetMorphTarget(class FName MorphTargetName, float Value, bool bRemoveZeroWeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetMorphTarget");

	Params::USkeletalMeshComponent_SetMorphTarget_Params Parms{};

	Parms.MorphTargetName = MorphTargetName;
	Parms.Value = Value;
	Parms.bRemoveZeroWeight = bRemoveZeroWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetLayerOverlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>   InClass                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetLayerOverlay(TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetLayerOverlay");

	Params::USkeletalMeshComponent_SetLayerOverlay_Params Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewBlendPhysics                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetEnablePhysicsBlending(bool bNewBlendPhysics)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetEnablePhysicsBlending");

	Params::USkeletalMeshComponent_SetEnablePhysicsBlending_Params Parms{};

	Parms.bNewBlendPhysics = bNewBlendPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetEnableGravityOnAllBodiesBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableGravity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludeSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, class FName BoneName, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetEnableGravityOnAllBodiesBelow");

	Params::USkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow_Params Parms{};

	Parms.bEnableGravity = bEnableGravity;
	Parms.BoneName = BoneName;
	Parms.bIncludeSelf = bIncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetEnableBodyGravity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableGravity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetEnableBodyGravity(bool bEnableGravity, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetEnableBodyGravity");

	Params::USkeletalMeshComponent_SetEnableBodyGravity_Params Parms{};

	Parms.bEnableGravity = bEnableGravity;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInDisablePostProcess                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetDisablePostProcessBlueprint(bool bInDisablePostProcess)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetDisablePostProcessBlueprint");

	Params::USkeletalMeshComponent_SetDisablePostProcessBlueprint_Params Parms{};

	Parms.bInDisablePostProcess = bInDisablePostProcess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetDisableAnimCurves
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInDisableAnimCurves                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetDisableAnimCurves(bool bInDisableAnimCurves)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetDisableAnimCurves");

	Params::USkeletalMeshComponent_SetDisableAnimCurves_Params Parms{};

	Parms.bInDisableAnimCurves = bInDisableAnimCurves;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetConstraintProfileForAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDefaultIfNotFound                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetConstraintProfileForAll(class FName ProfileName, bool bDefaultIfNotFound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetConstraintProfileForAll");

	Params::USkeletalMeshComponent_SetConstraintProfileForAll_Params Parms{};

	Parms.ProfileName = ProfileName;
	Parms.bDefaultIfNotFound = bDefaultIfNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetConstraintProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        JointName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDefaultIfNotFound                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetConstraintProfile(class FName JointName, class FName ProfileName, bool bDefaultIfNotFound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetConstraintProfile");

	Params::USkeletalMeshComponent_SetConstraintProfile_Params Parms{};

	Parms.JointName = JointName;
	Parms.ProfileName = ProfileName;
	Parms.bDefaultIfNotFound = bDefaultIfNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetClothMaxDistanceScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetClothMaxDistanceScale");

	Params::USkeletalMeshComponent_SetClothMaxDistanceScale_Params Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetBodyNotifyRigidBodyCollision
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewNotifyRigidBodyCollision                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetBodyNotifyRigidBodyCollision");

	Params::USkeletalMeshComponent_SetBodyNotifyRigidBodyCollision_Params Parms{};

	Parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAnimClass
// (Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                      NewClass                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAnimClass(class UClass* NewClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAnimClass");

	Params::USkeletalMeshComponent_SetAnimClass_Params Parms{};

	Parms.NewClass = NewClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAnimationMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EAnimationMode          InAnimationMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAnimationMode(enum class EAnimationMode InAnimationMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAnimationMode");

	Params::USkeletalMeshComponent_SetAnimationMode_Params Parms{};

	Parms.InAnimationMode = InAnimationMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*             NewAnimToPlay                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAnimation(class UAnimationAsset* NewAnimToPlay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAnimation");

	Params::USkeletalMeshComponent_SetAnimation_Params Parms{};

	Parms.NewAnimToPlay = NewAnimToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAngularLimits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Swing1LimitAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TwistLimitAngle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Swing2LimitAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAngularLimits(class FName InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAngularLimits");

	Params::USkeletalMeshComponent_SetAngularLimits_Params Parms{};

	Parms.InBoneName = InBoneName;
	Parms.Swing1LimitAngle = Swing1LimitAngle;
	Parms.TwistLimitAngle = TwistLimitAngle;
	Parms.Swing2LimitAngle = Swing2LimitAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllowedAnimCurvesEvaluation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                List                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bAllow                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllowedAnimCurvesEvaluation(TArray<class FName>& List, bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllowedAnimCurvesEvaluation");

	Params::USkeletalMeshComponent_SetAllowedAnimCurvesEvaluation_Params Parms{};

	Parms.List = List;
	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllowAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInAllow                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllowAnimCurveEvaluation(bool bInAllow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllowAnimCurveEvaluation");

	Params::USkeletalMeshComponent_SetAllowAnimCurveEvaluation_Params Parms{};

	Parms.bInAllow = bInAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableSwingDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableTwistDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipCustomPhysicsType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllMotorsAngularVelocityDrive");

	Params::USkeletalMeshComponent_SetAllMotorsAngularVelocityDrive_Params Parms{};

	Parms.bEnableSwingDrive = bEnableSwingDrive;
	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableSwingDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableTwistDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipCustomPhysicsType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllMotorsAngularPositionDrive");

	Params::USkeletalMeshComponent_SetAllMotorsAngularPositionDrive_Params Parms{};

	Parms.bEnableSwingDrive = bEnableSwingDrive;
	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InSpring                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDamping                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InForceLimit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipCustomPhysicsType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllMotorsAngularDriveParams");

	Params::USkeletalMeshComponent_SetAllMotorsAngularDriveParams_Params Parms{};

	Parms.InSpring = InSpring;
	Parms.InDamping = InDamping;
	Parms.InForceLimit = InForceLimit;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewSimulate                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesSimulatePhysics(bool bNewSimulate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllBodiesSimulatePhysics");

	Params::USkeletalMeshComponent_SetAllBodiesSimulatePhysics_Params Parms{};

	Parms.bNewSimulate = bNewSimulate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              PhysicsBlendWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipCustomPhysicsType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllBodiesPhysicsBlendWeight");

	Params::USkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight_Params Parms{};

	Parms.PhysicsBlendWeight = PhysicsBlendWeight;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        InBoneName                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNewSimulate                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludeSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesBelowSimulatePhysics(class FName& InBoneName, bool bNewSimulate, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllBodiesBelowSimulatePhysics");

	Params::USkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics_Params Parms{};

	Parms.InBoneName = InBoneName;
	Parms.bNewSimulate = bNewSimulate;
	Parms.bIncludeSelf = bIncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        InBoneName                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PhysicsBlendWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipCustomPhysicsType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludeSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesBelowPhysicsBlendWeight(class FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "SetAllBodiesBelowPhysicsBlendWeight");

	Params::USkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight_Params Parms{};

	Parms.InBoneName = InBoneName;
	Parms.PhysicsBlendWeight = PhysicsBlendWeight;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;
	Parms.bIncludeSelf = bIncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.ResumeClothingSimulation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::ResumeClothingSimulation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ResumeClothingSimulation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.ResetClothTeleportMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::ResetClothTeleportMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ResetClothTeleportMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.ResetAnimInstanceDynamics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ETeleportType           InTeleportType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::ResetAnimInstanceDynamics(enum class ETeleportType InTeleportType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ResetAnimInstanceDynamics");

	Params::USkeletalMeshComponent_ResetAnimInstanceDynamics_Params Parms{};

	Parms.InTeleportType = InTeleportType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.ResetAllowedAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::ResetAllowedAnimCurveEvaluation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ResetAllowedAnimCurveEvaluation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::ResetAllBodiesSimulatePhysics()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ResetAllBodiesSimulatePhysics");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.PlayAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*             NewAnimToPlay                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLooping                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::PlayAnimation(class UAnimationAsset* NewAnimToPlay, bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "PlayAnimation");

	Params::USkeletalMeshComponent_PlayAnimation_Params Parms{};

	Parms.NewAnimToPlay = NewAnimToPlay;
	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bLooping                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::Play(bool bLooping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "Play");

	Params::USkeletalMeshComponent_Play_Params Parms{};

	Parms.bLooping = bLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.OverrideAnimationData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*             InAnimToPlay                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsLooping                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsPlaying                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Position                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PlayRate                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::OverrideAnimationData(class UAnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "OverrideAnimationData");

	Params::USkeletalMeshComponent_OverrideAnimationData_Params Parms{};

	Parms.InAnimToPlay = InAnimToPlay;
	Parms.bIsLooping = bIsLooping;
	Parms.bIsPlaying = bIsPlaying;
	Parms.Position = Position;
	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.K2_GetClosestPointOnPhysicsAsset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldPosition                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ClosestWorldPosition                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Normal                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Distance                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::K2_GetClosestPointOnPhysicsAsset(struct FVector& WorldPosition, struct FVector* ClosestWorldPosition, struct FVector* Normal, class FName* BoneName, float* Distance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "K2_GetClosestPointOnPhysicsAsset");

	Params::USkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset_Params Parms{};

	Parms.WorldPosition = WorldPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ClosestWorldPosition != nullptr)
		*ClosestWorldPosition = std::move(Parms.ClosestWorldPosition);

	if (Normal != nullptr)
		*Normal = std::move(Parms.Normal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::IsPlaying()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "IsPlaying");

	Params::USkeletalMeshComponent_IsPlaying_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.IsClothingSimulationSuspended
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::IsClothingSimulationSuspended()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "IsClothingSimulationSuspended");

	Params::USkeletalMeshComponent_IsClothingSimulationSuspended_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.IsBodyGravityEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::IsBodyGravityEnabled(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "IsBodyGravityEnabled");

	Params::USkeletalMeshComponent_IsBodyGravityEnabled_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.HasValidAnimationInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::HasValidAnimationInstance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "HasValidAnimationInstance");

	Params::USkeletalMeshComponent_HasValidAnimationInstance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetTeleportRotationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetTeleportRotationThreshold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetTeleportRotationThreshold");

	Params::USkeletalMeshComponent_GetTeleportRotationThreshold_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetTeleportDistanceThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetTeleportDistanceThreshold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetTeleportDistanceThreshold");

	Params::USkeletalMeshComponent_GetTeleportDistanceThreshold_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetSubInstancesByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InTag                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimInstance*>       OutSubInstances                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::GetSubInstancesByTag(class FName InTag, TArray<class UAnimInstance*>* OutSubInstances)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetSubInstancesByTag");

	Params::USkeletalMeshComponent_GetSubInstancesByTag_Params Parms{};

	Parms.InTag = InTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSubInstances != nullptr)
		*OutSubInstances = std::move(Parms.OutSubInstances);

}


// Function Engine.SkeletalMeshComponent.GetSubInstanceByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InTag                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetSubInstanceByTag(class FName InTag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetSubInstanceByTag");

	Params::USkeletalMeshComponent_GetSubInstanceByTag_Params Parms{};

	Parms.InTag = InTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetSkeletalCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USkeletalMeshComponent::GetSkeletalCenterOfMass()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetSkeletalCenterOfMass");

	Params::USkeletalMeshComponent_GetSkeletalCenterOfMass_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetPostProcessInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetPostProcessInstance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetPostProcessInstance");

	Params::USkeletalMeshComponent_GetPostProcessInstance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetPosition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetPosition");

	Params::USkeletalMeshComponent_GetPosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetPlayRate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetPlayRate");

	Params::USkeletalMeshComponent_GetPlayRate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetMorphTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        MorphTargetName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetMorphTarget(class FName MorphTargetName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetMorphTarget");

	Params::USkeletalMeshComponent_GetMorphTarget_Params Parms{};

	Parms.MorphTargetName = MorphTargetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetLayerSubInstanceByGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InGroup                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetLayerSubInstanceByGroup(class FName InGroup)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetLayerSubInstanceByGroup");

	Params::USkeletalMeshComponent_GetLayerSubInstanceByGroup_Params Parms{};

	Parms.InGroup = InGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetDisablePostProcessBlueprint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetDisablePostProcessBlueprint");

	Params::USkeletalMeshComponent_GetDisablePostProcessBlueprint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetDisableAnimCurves
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetDisableAnimCurves()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetDisableAnimCurves");

	Params::USkeletalMeshComponent_GetDisableAnimCurves_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetCurrentJointAngles
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Swing1Angle                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TwistAngle                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Swing2Angle                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::GetCurrentJointAngles(class FName InBoneName, float* Swing1Angle, float* TwistAngle, float* Swing2Angle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetCurrentJointAngles");

	Params::USkeletalMeshComponent_GetCurrentJointAngles_Params Parms{};

	Parms.InBoneName = InBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Swing1Angle != nullptr)
		*Swing1Angle = Parms.Swing1Angle;

	if (TwistAngle != nullptr)
		*TwistAngle = Parms.TwistAngle;

	if (Swing2Angle != nullptr)
		*Swing2Angle = Parms.Swing2Angle;

}


// Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetClothMaxDistanceScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetClothMaxDistanceScale");

	Params::USkeletalMeshComponent_GetClothMaxDistanceScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetClothingSimulationInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClothingSimulationInteractor*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClothingSimulationInteractor* USkeletalMeshComponent::GetClothingSimulationInteractor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetClothingSimulationInteractor");

	Params::USkeletalMeshComponent_GetClothingSimulationInteractor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetBoneMass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bScaleMass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetBoneMass(class FName BoneName, bool bScaleMass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetBoneMass");

	Params::USkeletalMeshComponent_GetBoneMass_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.bScaleMass = bScaleMass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetAnimInstance");

	Params::USkeletalMeshComponent_GetAnimInstance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetAnimClass
// (Final, Native, Public)
// Parameters:
// class UClass*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* USkeletalMeshComponent::GetAnimClass()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetAnimClass");

	Params::USkeletalMeshComponent_GetAnimClass_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetAnimationMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAnimationMode          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EAnimationMode USkeletalMeshComponent::GetAnimationMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetAnimationMode");

	Params::USkeletalMeshComponent_GetAnimationMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.GetAllowedAnimCurveEvaluate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetAllowedAnimCurveEvaluate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "GetAllowedAnimCurveEvaluate");

	Params::USkeletalMeshComponent_GetAllowedAnimCurveEvaluate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::ForceClothNextUpdateTeleportAndReset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ForceClothNextUpdateTeleportAndReset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::ForceClothNextUpdateTeleport()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ForceClothNextUpdateTeleport");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.FindConstraintBoneName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ConstraintIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkeletalMeshComponent::FindConstraintBoneName(int32 ConstraintIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "FindConstraintBoneName");

	Params::USkeletalMeshComponent_FindConstraintBoneName_Params Parms{};

	Parms.ConstraintIndex = ConstraintIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMeshComponent.ClearMorphTargets
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::ClearMorphTargets()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "ClearMorphTargets");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.BreakConstraint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, class FName InBoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "BreakConstraint");

	Params::USkeletalMeshComponent_BreakConstraint_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.HitLocation = HitLocation;
	Parms.InBoneName = InBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.BindClothToMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkeletalMeshComponent::BindClothToMasterPoseComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "BindClothToMasterPoseComponent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.AllowAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        NameOfCurve                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAllow                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::AllowAnimCurveEvaluation(class FName NameOfCurve, bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "AllowAnimCurveEvaluation");

	Params::USkeletalMeshComponent_AllowAnimCurveEvaluation_Params Parms{};

	Parms.NameOfCurve = NameOfCurve;
	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.AddImpulseToAllBodiesBelow
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bVelChange                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludeSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::AddImpulseToAllBodiesBelow(const struct FVector& Impulse, class FName BoneName, bool bVelChange, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "AddImpulseToAllBodiesBelow");

	Params::USkeletalMeshComponent_AddImpulseToAllBodiesBelow_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;
	Parms.bIncludeSelf = bIncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.AddForceToAllBodiesBelow
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAccelChange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludeSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::AddForceToAllBodiesBelow(const struct FVector& Force, class FName BoneName, bool bAccelChange, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "AddForceToAllBodiesBelow");

	Params::USkeletalMeshComponent_AddForceToAllBodiesBelow_Params Parms{};

	Parms.Force = Force;
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;
	Parms.bIncludeSelf = bIncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        InBoneName                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AddPhysicsBlendWeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipCustomPhysicsType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::AccumulateAllBodiesBelowPhysicsBlendWeight(class FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshComponent", "AccumulateAllBodiesBelowPhysicsBlendWeight");

	Params::USkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight_Params Parms{};

	Parms.InBoneName = InBoneName;
	Parms.AddPhysicsBlendWeight = AddPhysicsBlendWeight;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.AnimInstance
// (None)

class UClass* UAnimInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimInstance");

	return Clss;
}


// AnimInstance Engine.Default__AnimInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimInstance* UAnimInstance::GetDefaultObj()
{
	static class UAnimInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimInstance*>(UAnimInstance::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AnimInstance.UnlockAIResources
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bUnlockMovement                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               UnlockAILogic                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "UnlockAIResources");

	Params::UAnimInstance_UnlockAIResources_Params Parms{};

	Parms.bUnlockMovement = bUnlockMovement;
	Parms.UnlockAILogic = UnlockAILogic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.TryGetPawnOwner
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UAnimInstance::TryGetPawnOwner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "TryGetPawnOwner");

	Params::UAnimInstance_TryGetPawnOwner_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.StopSlotAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InBlendOutTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SlotNodeName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::StopSlotAnimation(float InBlendOutTime, class FName SlotNodeName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "StopSlotAnimation");

	Params::UAnimInstance_StopSlotAnimation_Params Parms{};

	Parms.InBlendOutTime = InBlendOutTime;
	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.SnapshotPose
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseSnapshot               Snapshot                                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAnimInstance::SnapshotPose(struct FPoseSnapshot& Snapshot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "SnapshotPose");

	Params::UAnimInstance_SnapshotPose_Params Parms{};

	Parms.Snapshot = Snapshot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.SetSubInstanceClassByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InTag                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>   InClass                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetSubInstanceClassByTag(class FName InTag, TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "SetSubInstanceClassByTag");

	Params::UAnimInstance_SetSubInstanceClassByTag_Params Parms{};

	Parms.InTag = InTag;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.SetRootMotionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ERootMotionMode         Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetRootMotionMode(enum class ERootMotionMode Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "SetRootMotionMode");

	Params::UAnimInstance_SetRootMotionMode_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.SetMorphTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        MorphTargetName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetMorphTarget(class FName MorphTargetName, float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "SetMorphTarget");

	Params::UAnimInstance_SetMorphTarget_Params Parms{};

	Parms.MorphTargetName = MorphTargetName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.SetLayerOverlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>   InClass                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetLayerOverlay(TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "SetLayerOverlay");

	Params::UAnimInstance_SetLayerOverlay_Params Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.SavePoseSnapshot
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SnapshotName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SavePoseSnapshot(class FName SnapshotName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "SavePoseSnapshot");

	Params::UAnimInstance_SavePoseSnapshot_Params Parms{};

	Parms.SnapshotName = SnapshotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.ResetDynamics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ETeleportType           InTeleportType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::ResetDynamics(enum class ETeleportType InTeleportType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "ResetDynamics");

	Params::UAnimInstance_ResetDynamics_Params Parms{};

	Parms.InTeleportType = InTeleportType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*           Asset                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SlotNodeName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendInTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendOutTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPlayRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              LoopCount                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendOutTriggerTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InTimeToStartMontageAt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage(class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "PlaySlotAnimationAsDynamicMontage");

	Params::UAnimInstance_PlaySlotAnimationAsDynamicMontage_Params Parms{};

	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.PlaySlotAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*           Asset                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SlotNodeName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendInTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendOutTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPlayRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              LoopCount                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::PlaySlotAnimation(class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "PlaySlotAnimation");

	Params::UAnimInstance_PlaySlotAnimation_Params Parms{};

	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.Montage_Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InBlendOutTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_Stop(float InBlendOutTime, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_Stop");

	Params::UAnimInstance_Montage_Stop_Params Parms{};

	Parms.InBlendOutTime = InBlendOutTime;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.Montage_SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NewPosition                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_SetPosition(class UAnimMontage* Montage, float NewPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_SetPosition");

	Params::UAnimInstance_Montage_SetPosition_Params Parms{};

	Parms.Montage = Montage;
	Parms.NewPosition = NewPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.Montage_SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NewPlayRate                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_SetPlayRate(class UAnimMontage* Montage, float NewPlayRate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_SetPlayRate");

	Params::UAnimInstance_Montage_SetPlayRate_Params Parms{};

	Parms.Montage = Montage;
	Parms.NewPlayRate = NewPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.Montage_SetNextSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SectionNameToChange                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NextSection                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_SetNextSection(class FName SectionNameToChange, class FName NextSection, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_SetNextSection");

	Params::UAnimInstance_Montage_SetNextSection_Params Parms{};

	Parms.SectionNameToChange = SectionNameToChange;
	Parms.NextSection = NextSection;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.Montage_Resume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_Resume(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_Resume");

	Params::UAnimInstance_Montage_Resume_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.Montage_Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                MontageToPlay                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPlayRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMontagePlayReturnType  ReturnValueType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InTimeToStartMontageAt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bStopAllMontages                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_Play(class UAnimMontage* MontageToPlay, float InPlayRate, enum class EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_Play");

	Params::UAnimInstance_Montage_Play_Params Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.InPlayRate = InPlayRate;
	Parms.ReturnValueType = ReturnValueType;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;
	Parms.bStopAllMontages = bStopAllMontages;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.Montage_Pause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_Pause(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_Pause");

	Params::UAnimInstance_Montage_Pause_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.Montage_JumpToSectionsEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SectionName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_JumpToSectionsEnd(class FName SectionName, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_JumpToSectionsEnd");

	Params::UAnimInstance_Montage_JumpToSectionsEnd_Params Parms{};

	Parms.SectionName = SectionName;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.Montage_JumpToSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        SectionName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_JumpToSection(class FName SectionName, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_JumpToSection");

	Params::UAnimInstance_Montage_JumpToSection_Params Parms{};

	Parms.SectionName = SectionName;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.Montage_IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::Montage_IsPlaying(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_IsPlaying");

	Params::UAnimInstance_Montage_IsPlaying_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.Montage_IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::Montage_IsActive(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_IsActive");

	Params::UAnimInstance_Montage_IsActive_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.Montage_GetPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_GetPosition(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_GetPosition");

	Params::UAnimInstance_Montage_GetPosition_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.Montage_GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_GetPlayRate(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_GetPlayRate");

	Params::UAnimInstance_Montage_GetPlayRate_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.Montage_GetIsStopped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::Montage_GetIsStopped(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_GetIsStopped");

	Params::UAnimInstance_Montage_GetIsStopped_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.Montage_GetCurrentSection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAnimInstance::Montage_GetCurrentSection(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_GetCurrentSection");

	Params::UAnimInstance_Montage_GetCurrentSection_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.Montage_GetBlendTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                Montage                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_GetBlendTime(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "Montage_GetBlendTime");

	Params::UAnimInstance_Montage_GetBlendTime_Params Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.LockAIResources
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bLockMovement                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               LockAILogic                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::LockAIResources(bool bLockMovement, bool LockAILogic)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "LockAIResources");

	Params::UAnimInstance_LockAIResources_Params Parms{};

	Parms.bLockMovement = bLockMovement;
	Parms.LockAILogic = LockAILogic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.IsSyncGroupBetweenMarkers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSyncGroupName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PreviousMarker                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NextMarker                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRespectMarkerOrder                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::IsSyncGroupBetweenMarkers(class FName InSyncGroupName, class FName PreviousMarker, class FName NextMarker, bool bRespectMarkerOrder)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "IsSyncGroupBetweenMarkers");

	Params::UAnimInstance_IsSyncGroupBetweenMarkers_Params Parms{};

	Parms.InSyncGroupName = InSyncGroupName;
	Parms.PreviousMarker = PreviousMarker;
	Parms.NextMarker = NextMarker;
	Parms.bRespectMarkerOrder = bRespectMarkerOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.IsPlayingSlotAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*           Asset                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SlotNodeName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::IsPlayingSlotAnimation(class UAnimSequenceBase* Asset, class FName SlotNodeName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "IsPlayingSlotAnimation");

	Params::UAnimInstance_IsPlayingSlotAnimation_Params Parms{};

	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.IsAnyMontagePlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::IsAnyMontagePlaying()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "IsAnyMontagePlaying");

	Params::UAnimInstance_IsAnyMontagePlaying_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.HasMarkerBeenHitThisFrame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        SyncGroup                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        MarkerName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::HasMarkerBeenHitThisFrame(class FName SyncGroup, class FName MarkerName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "HasMarkerBeenHitThisFrame");

	Params::UAnimInstance_HasMarkerBeenHitThisFrame_Params Parms{};

	Parms.SyncGroup = SyncGroup;
	Parms.MarkerName = MarkerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetTimeToClosestMarker
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        SyncGroup                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        MarkerName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutMarkerTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::GetTimeToClosestMarker(class FName SyncGroup, class FName MarkerName, float* OutMarkerTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetTimeToClosestMarker");

	Params::UAnimInstance_GetTimeToClosestMarker_Params Parms{};

	Parms.SyncGroup = SyncGroup;
	Parms.MarkerName = MarkerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutMarkerTime != nullptr)
		*OutMarkerTime = Parms.OutMarkerTime;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetSyncGroupPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSyncGroupName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMarkerSyncAnimPosition     ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMarkerSyncAnimPosition UAnimInstance::GetSyncGroupPosition(class FName InSyncGroupName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetSyncGroupPosition");

	Params::UAnimInstance_GetSyncGroupPosition_Params Parms{};

	Parms.InSyncGroupName = InSyncGroupName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetSubInstancesByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InTag                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimInstance*>       OutSubInstances                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstance::GetSubInstancesByTag(class FName InTag, TArray<class UAnimInstance*>* OutSubInstances)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetSubInstancesByTag");

	Params::UAnimInstance_GetSubInstancesByTag_Params Parms{};

	Parms.InTag = InTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSubInstances != nullptr)
		*OutSubInstances = std::move(Parms.OutSubInstances);

}


// Function Engine.AnimInstance.GetSubInstanceByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InTag                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UAnimInstance::GetSubInstanceByTag(class FName InTag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetSubInstanceByTag");

	Params::UAnimInstance_GetSubInstanceByTag_Params Parms{};

	Parms.InTag = InTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StateIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimTimeRemainingFraction(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetRelevantAnimTimeRemainingFraction");

	Params::UAnimInstance_GetRelevantAnimTimeRemainingFraction_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetRelevantAnimTimeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StateIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimTimeRemaining(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetRelevantAnimTimeRemaining");

	Params::UAnimInstance_GetRelevantAnimTimeRemaining_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetRelevantAnimTimeFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StateIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimTimeFraction(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetRelevantAnimTimeFraction");

	Params::UAnimInstance_GetRelevantAnimTimeFraction_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetRelevantAnimTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StateIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimTime(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetRelevantAnimTime");

	Params::UAnimInstance_GetRelevantAnimTime_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetRelevantAnimLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StateIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimLength(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetRelevantAnimLength");

	Params::UAnimInstance_GetRelevantAnimLength_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetOwningComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*      ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UAnimInstance::GetOwningComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetOwningComponent");

	Params::UAnimInstance_GetOwningComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAnimInstance::GetOwningActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetOwningActor");

	Params::UAnimInstance_GetOwningActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetLayerSubInstanceByGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InGroup                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UAnimInstance::GetLayerSubInstanceByGroup(class FName InGroup)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetLayerSubInstanceByGroup");

	Params::UAnimInstance_GetLayerSubInstanceByGroup_Params Parms{};

	Parms.InGroup = InGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TransitionIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceTransitionTimeElapsedFraction(int32 MachineIndex, int32 TransitionIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceTransitionTimeElapsedFraction");

	Params::UAnimInstance_GetInstanceTransitionTimeElapsedFraction_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.TransitionIndex = TransitionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TransitionIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceTransitionTimeElapsed(int32 MachineIndex, int32 TransitionIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceTransitionTimeElapsed");

	Params::UAnimInstance_GetInstanceTransitionTimeElapsed_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.TransitionIndex = TransitionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TransitionIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceTransitionCrossfadeDuration(int32 MachineIndex, int32 TransitionIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceTransitionCrossfadeDuration");

	Params::UAnimInstance_GetInstanceTransitionCrossfadeDuration_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.TransitionIndex = TransitionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceStateWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StateIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceStateWeight(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceStateWeight");

	Params::UAnimInstance_GetInstanceStateWeight_Params Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceMachineWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceMachineWeight(int32 MachineIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceMachineWeight");

	Params::UAnimInstance_GetInstanceMachineWeight_Params Parms{};

	Parms.MachineIndex = MachineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceCurrentStateElapsedTime(int32 MachineIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceCurrentStateElapsedTime");

	Params::UAnimInstance_GetInstanceCurrentStateElapsedTime_Params Parms{};

	Parms.MachineIndex = MachineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              AssetPlayerIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerTimeFromEndFraction(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceAssetPlayerTimeFromEndFraction");

	Params::UAnimInstance_GetInstanceAssetPlayerTimeFromEndFraction_Params Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              AssetPlayerIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerTimeFromEnd(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceAssetPlayerTimeFromEnd");

	Params::UAnimInstance_GetInstanceAssetPlayerTimeFromEnd_Params Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              AssetPlayerIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerTimeFraction(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceAssetPlayerTimeFraction");

	Params::UAnimInstance_GetInstanceAssetPlayerTimeFraction_Params Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              AssetPlayerIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerTime(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceAssetPlayerTime");

	Params::UAnimInstance_GetInstanceAssetPlayerTime_Params Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetInstanceAssetPlayerLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              AssetPlayerIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerLength(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetInstanceAssetPlayerLength");

	Params::UAnimInstance_GetInstanceAssetPlayerLength_Params Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetCurveValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        CurveName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetCurveValue(class FName CurveName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetCurveValue");

	Params::UAnimInstance_GetCurveValue_Params Parms{};

	Parms.CurveName = CurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetCurrentStateName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              MachineIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAnimInstance::GetCurrentStateName(int32 MachineIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetCurrentStateName");

	Params::UAnimInstance_GetCurrentStateName_Params Parms{};

	Parms.MachineIndex = MachineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetCurrentActiveMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UAnimInstance::GetCurrentActiveMontage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetCurrentActiveMontage");

	Params::UAnimInstance_GetCurrentActiveMontage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.GetAllCurveNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                OutNames                                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstance::GetAllCurveNames(TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetAllCurveNames");

	Params::UAnimInstance_GetAllCurveNames_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);

}


// Function Engine.AnimInstance.GetActiveCurveNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EAnimCurveType          CurveType                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                OutNames                                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstance::GetActiveCurveNames(enum class EAnimCurveType CurveType, TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "GetActiveCurveNames");

	Params::UAnimInstance_GetActiveCurveNames_Params Parms{};

	Parms.CurveType = CurveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);

}


// Function Engine.AnimInstance.ClearMorphTargets
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UAnimInstance::ClearMorphTargets()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "ClearMorphTargets");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimInstance.CalculateDirection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Velocity                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    BaseRotation                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::CalculateDirection(struct FVector& Velocity, struct FRotator& BaseRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "CalculateDirection");

	Params::UAnimInstance_CalculateDirection_Params Parms{};

	Parms.Velocity = Velocity;
	Parms.BaseRotation = BaseRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimInstance.BlueprintUpdateAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              DeltaTimeX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::BlueprintUpdateAnimation(float DeltaTimeX)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "BlueprintUpdateAnimation");

	Params::UAnimInstance_BlueprintUpdateAnimation_Params Parms{};

	Parms.DeltaTimeX = DeltaTimeX;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.AnimInstance.BlueprintPostEvaluateAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void UAnimInstance::BlueprintPostEvaluateAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "BlueprintPostEvaluateAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.AnimInstance.BlueprintInitializeAnimation
// (Event, Public, BlueprintEvent)
// Parameters:

void UAnimInstance::BlueprintInitializeAnimation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "BlueprintInitializeAnimation");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.AnimInstance.BlueprintBeginPlay
// (Event, Public, BlueprintEvent)
// Parameters:

void UAnimInstance::BlueprintBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimInstance", "BlueprintBeginPlay");



	UObject::ProcessEvent(Func, nullptr);

}


// Class Engine.DataAsset
// (None)

class UClass* UDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DataAsset");

	return Clss;
}


// DataAsset Engine.Default__DataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UDataAsset* UDataAsset::GetDefaultObj()
{
	static class UDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UDataAsset*>(UDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Actor
// (Actor)

class UClass* AActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Actor");

	return Clss;
}


// Actor Engine.Default__Actor
// (Public, ClassDefaultObject, ArchetypeObject)

class AActor* AActor::GetDefaultObj()
{
	static class AActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AActor*>(AActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Actor.WasRecentlyRendered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::WasRecentlyRendered(float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "WasRecentlyRendered");

	Params::AActor_WasRecentlyRendered_Params Parms{};

	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.UserConstructionScript
// (Event, Public, BlueprintEvent)
// Parameters:

void AActor::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "UserConstructionScript");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.Actor.TearOff
// (Native, Public, BlueprintCallable)
// Parameters:

void AActor::TearOff()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "TearOff");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SnapRootComponentTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InParentActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SnapRootComponentTo(class AActor* InParentActor, class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SnapRootComponentTo");

	Params::AActor_SnapRootComponentTo_Params Parms{};

	Parms.InParentActor = InParentActor;
	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetTickGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ETickingGroup           NewTickGroup                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetTickGroup(enum class ETickingGroup NewTickGroup)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetTickGroup");

	Params::AActor_SetTickGroup_Params Parms{};

	Parms.NewTickGroup = NewTickGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bTickableWhenPaused                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetTickableWhenPaused(bool bTickableWhenPaused)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetTickableWhenPaused");

	Params::AActor_SetTickableWhenPaused_Params Parms{};

	Parms.bTickableWhenPaused = bTickableWhenPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetReplicates
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInReplicates                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetReplicates(bool bInReplicates)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetReplicates");

	Params::AActor_SetReplicates_Params Parms{};

	Parms.bInReplicates = bInReplicates;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetReplicateMovement
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInReplicateMovement                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetReplicateMovement(bool bInReplicateMovement)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetReplicateMovement");

	Params::AActor_SetReplicateMovement_Params Parms{};

	Parms.bInReplicateMovement = bInReplicateMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetOwner
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      NewOwner                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetOwner(class AActor* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetOwner");

	Params::AActor_SetOwner_Params Parms{};

	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetNetDormancy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// enum class ENetDormancy            NewDormancy                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetNetDormancy(enum class ENetDormancy NewDormancy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetNetDormancy");

	Params::AActor_SetNetDormancy_Params Parms{};

	Parms.NewDormancy = NewDormancy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetLifeSpan
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              InLifespan                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetLifeSpan(float InLifespan)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetLifeSpan");

	Params::AActor_SetLifeSpan_Params Parms{};

	Parms.InLifespan = InLifespan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetActorTickInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              TickInterval                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorTickInterval(float TickInterval)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetActorTickInterval");

	Params::AActor_SetActorTickInterval_Params Parms{};

	Parms.TickInterval = TickInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetActorTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorTickEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetActorTickEnabled");

	Params::AActor_SetActorTickEnabled_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetActorScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewScale3D                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorScale3D(const struct FVector& NewScale3D)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetActorScale3D");

	Params::AActor_SetActorScale3D_Params Parms{};

	Parms.NewScale3D = NewScale3D;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetActorRelativeScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewRelativeScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorRelativeScale3D(const struct FVector& NewRelativeScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetActorRelativeScale3D");

	Params::AActor_SetActorRelativeScale3D_Params Parms{};

	Parms.NewRelativeScale = NewRelativeScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetActorHiddenInGame
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewHidden                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorHiddenInGame(bool bNewHidden)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetActorHiddenInGame");

	Params::AActor_SetActorHiddenInGame_Params Parms{};

	Parms.bNewHidden = bNewHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.SetActorEnableCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewActorEnableCollision                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorEnableCollision(bool bNewActorEnableCollision)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "SetActorEnableCollision");

	Params::AActor_SetActorEnableCollision_Params Parms{};

	Parms.bNewActorEnableCollision = bNewActorEnableCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.RemoveTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*             PrerequisiteComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "RemoveTickPrerequisiteComponent");

	Params::AActor_RemoveTickPrerequisiteComponent_Params Parms{};

	Parms.PrerequisiteComponent = PrerequisiteComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.RemoveTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      PrerequisiteActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "RemoveTickPrerequisiteActor");

	Params::AActor_RemoveTickPrerequisiteActor_Params Parms{};

	Parms.PrerequisiteActor = PrerequisiteActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              DeltaSeconds                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveTick");

	Params::AActor_ReceiveTick_Params Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveRadialDamage
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                              DamageReceived                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                 DamageType                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitInfo                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                 InstigatedBy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveRadialDamage(float DamageReceived, class UDamageType* DamageType, const struct FVector& Origin, struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveRadialDamage");

	Params::AActor_ReceiveRadialDamage_Params Parms{};

	Parms.DamageReceived = DamageReceived;
	Parms.DamageType = DamageType;
	Parms.Origin = Origin;
	Parms.HitInfo = HitInfo;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceivePointDamage
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                              Damage                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                 DamageType                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         HitComponent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ShotFromDirection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 InstigatedBy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitInfo                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActor::ReceivePointDamage(float Damage, class UDamageType* DamageType, const struct FVector& HitLocation, const struct FVector& HitNormal, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& ShotFromDirection, class AController* InstigatedBy, class AActor* DamageCauser, struct FHitResult& HitInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceivePointDamage");

	Params::AActor_ReceivePointDamage_Params Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.HitLocation = HitLocation;
	Parms.HitNormal = HitNormal;
	Parms.HitComponent = HitComponent;
	Parms.BoneName = BoneName;
	Parms.ShotFromDirection = ShotFromDirection;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.HitInfo = HitInfo;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveHit
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*         MyComp                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Other                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSelfMoved                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitNormal                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NormalImpulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActor::ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveHit");

	Params::AActor_ReceiveHit_Params Parms{};

	Parms.MyComp = MyComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.bSelfMoved = bSelfMoved;
	Parms.HitLocation = HitLocation;
	Parms.HitNormal = HitNormal;
	Parms.NormalImpulse = NormalImpulse;
	Parms.Hit = Hit;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// enum class EEndPlayReason          EndPlayReason                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveEndPlay(enum class EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveEndPlay");

	Params::AActor_ReceiveEndPlay_Params Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveDestroyed
// (Event, Public, BlueprintEvent)
// Parameters:

void AActor::ReceiveDestroyed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveDestroyed");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.Actor.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)
// Parameters:

void AActor::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveBeginPlay");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.Actor.ReceiveAnyDamage
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// float                              Damage                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                 DamageType                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 InstigatedBy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveAnyDamage(float Damage, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveAnyDamage");

	Params::AActor_ReceiveAnyDamage_Params Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorOnReleased
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FKey                        ButtonReleased                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnReleased(const struct FKey& ButtonReleased)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorOnReleased");

	Params::AActor_ReceiveActorOnReleased_Params Parms{};

	Parms.ButtonReleased = ButtonReleased;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorOnInputTouchLeave
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ETouchIndex             FingerIndex                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnInputTouchLeave(enum class ETouchIndex FingerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorOnInputTouchLeave");

	Params::AActor_ReceiveActorOnInputTouchLeave_Params Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorOnInputTouchEnter
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ETouchIndex             FingerIndex                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnInputTouchEnter(enum class ETouchIndex FingerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorOnInputTouchEnter");

	Params::AActor_ReceiveActorOnInputTouchEnter_Params Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorOnInputTouchEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ETouchIndex             FingerIndex                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnInputTouchEnd(enum class ETouchIndex FingerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorOnInputTouchEnd");

	Params::AActor_ReceiveActorOnInputTouchEnd_Params Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorOnInputTouchBegin
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ETouchIndex             FingerIndex                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnInputTouchBegin(enum class ETouchIndex FingerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorOnInputTouchBegin");

	Params::AActor_ReceiveActorOnInputTouchBegin_Params Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorOnClicked
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FKey                        ButtonPressed                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnClicked(const struct FKey& ButtonPressed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorOnClicked");

	Params::AActor_ReceiveActorOnClicked_Params Parms{};

	Parms.ButtonPressed = ButtonPressed;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorEndOverlap
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorEndOverlap(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorEndOverlap");

	Params::AActor_ReceiveActorEndOverlap_Params Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorEndCursorOver
// (Event, Public, BlueprintEvent)
// Parameters:

void AActor::ReceiveActorEndCursorOver()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorEndCursorOver");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.Actor.ReceiveActorBeginOverlap
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      OtherActor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorBeginOverlap(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorBeginOverlap");

	Params::AActor_ReceiveActorBeginOverlap_Params Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.ReceiveActorBeginCursorOver
// (Event, Public, BlueprintEvent)
// Parameters:

void AActor::ReceiveActorBeginCursorOver()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ReceiveActorBeginCursorOver");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.Actor.PrestreamTextures
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Seconds                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableStreaming                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CinematicTextureGroups                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::PrestreamTextures(float Seconds, bool bEnableStreaming, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "PrestreamTextures");

	Params::AActor_PrestreamTextures_Params Parms{};

	Parms.Seconds = Seconds;
	Parms.bEnableStreaming = bEnableStreaming;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.OnRep_ReplicateMovement
// (Native, Public)
// Parameters:

void AActor::OnRep_ReplicateMovement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "OnRep_ReplicateMovement");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.OnRep_ReplicatedMovement
// (Native, Public)
// Parameters:

void AActor::OnRep_ReplicatedMovement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "OnRep_ReplicatedMovement");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.OnRep_Owner
// (Native, Protected)
// Parameters:

void AActor::OnRep_Owner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "OnRep_Owner");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.OnRep_Instigator
// (Native, Public)
// Parameters:

void AActor::OnRep_Instigator()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "OnRep_Instigator");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.OnRep_AttachmentReplication
// (Native, Public)
// Parameters:

void AActor::OnRep_AttachmentReplication()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "OnRep_AttachmentReplication");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.MakeNoise
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                              Loudness                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                       NoiseInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NoiseLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxRange                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Tag                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::MakeNoise(float Loudness, class APawn* NoiseInstigator, const struct FVector& NoiseLocation, float MaxRange, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "MakeNoise");

	Params::AActor_MakeNoise_Params Parms{};

	Parms.Loudness = Loudness;
	Parms.NoiseInstigator = NoiseInstigator;
	Parms.NoiseLocation = NoiseLocation;
	Parms.MaxRange = MaxRange;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.MakeMIDForMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          Parent                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* AActor::MakeMIDForMaterial(class UMaterialInterface* Parent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "MakeMIDForMaterial");

	Params::AActor_MakeMIDForMaterial_Params Parms{};

	Parms.Parent = Parent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_TeleportTo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DestLocation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    DestRotation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_TeleportTo");

	Params::AActor_K2_TeleportTo_Params Parms{};

	Parms.DestLocation = DestLocation;
	Parms.DestRotation = DestRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_SetActorTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  NewTransform                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_SetActorTransform(struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_SetActorTransform");

	Params::AActor_K2_SetActorTransform_Params Parms{};

	Parms.NewTransform = NewTransform;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_SetActorRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bTeleportPhysics                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_SetActorRotation(const struct FRotator& NewRotation, bool bTeleportPhysics)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_SetActorRotation");

	Params::AActor_K2_SetActorRotation_Params Parms{};

	Parms.NewRotation = NewRotation;
	Parms.bTeleportPhysics = bTeleportPhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_SetActorRelativeTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  NewRelativeTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_SetActorRelativeTransform(struct FTransform& NewRelativeTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_SetActorRelativeTransform");

	Params::AActor_K2_SetActorRelativeTransform_Params Parms{};

	Parms.NewRelativeTransform = NewRelativeTransform;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.K2_SetActorRelativeRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    NewRelativeRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_SetActorRelativeRotation(const struct FRotator& NewRelativeRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_SetActorRelativeRotation");

	Params::AActor_K2_SetActorRelativeRotation_Params Parms{};

	Parms.NewRelativeRotation = NewRelativeRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.K2_SetActorRelativeLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewRelativeLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_SetActorRelativeLocation(const struct FVector& NewRelativeLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_SetActorRelativeLocation");

	Params::AActor_K2_SetActorRelativeLocation_Params Parms{};

	Parms.NewRelativeLocation = NewRelativeLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.K2_SetActorLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_SetActorLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_SetActorLocationAndRotation");

	Params::AActor_K2_SetActorLocationAndRotation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.NewRotation = NewRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_SetActorLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_SetActorLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_SetActorLocation");

	Params::AActor_K2_SetActorLocation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_OnReset
// (Event, Public, BlueprintEvent)
// Parameters:

void AActor::K2_OnReset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_OnReset");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.Actor.K2_OnEndViewTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*           PC                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_OnEndViewTarget(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_OnEndViewTarget");

	Params::AActor_K2_OnEndViewTarget_Params Parms{};

	Parms.PC = PC;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.K2_OnBecomeViewTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*           PC                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_OnBecomeViewTarget(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_OnBecomeViewTarget");

	Params::AActor_K2_OnBecomeViewTarget_Params Parms{};

	Parms.PC = PC;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Actor.K2_GetRootComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AActor::K2_GetRootComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_GetRootComponent");

	Params::AActor_K2_GetRootComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_GetActorRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AActor::K2_GetActorRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_GetActorRotation");

	Params::AActor_K2_GetActorRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_GetActorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::K2_GetActorLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_GetActorLocation");

	Params::AActor_K2_GetActorLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.K2_DetachFromActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EDetachmentRule         LocationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDetachmentRule         RotationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDetachmentRule         ScaleRule                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_DetachFromActor(enum class EDetachmentRule LocationRule, enum class EDetachmentRule RotationRule, enum class EDetachmentRule ScaleRule)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_DetachFromActor");

	Params::AActor_K2_DetachFromActor_Params Parms{};

	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.K2_DestroyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*             Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_DestroyComponent(class UActorComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_DestroyComponent");

	Params::AActor_K2_DestroyComponent_Params Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.K2_DestroyActor
// (Native, Public, BlueprintCallable)
// Parameters:

void AActor::K2_DestroyActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_DestroyActor");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.K2_AttachToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             Parent                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SocketName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         LocationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         RotationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         ScaleRule                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bWeldSimulatedBodies                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AttachToComponent(class USceneComponent* Parent, class FName SocketName, enum class EAttachmentRule LocationRule, enum class EAttachmentRule RotationRule, enum class EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AttachToComponent");

	Params::AActor_K2_AttachToComponent_Params Parms{};

	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.K2_AttachToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      ParentActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SocketName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         LocationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         RotationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         ScaleRule                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bWeldSimulatedBodies                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AttachToActor(class AActor* ParentActor, class FName SocketName, enum class EAttachmentRule LocationRule, enum class EAttachmentRule RotationRule, enum class EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AttachToActor");

	Params::AActor_K2_AttachToActor_Params Parms{};

	Parms.ParentActor = ParentActor;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.K2_AttachRootComponentToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InParentActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachLocation         AttachLocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bWeldSimulatedBodies                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AttachRootComponentToActor(class AActor* InParentActor, class FName InSocketName, enum class EAttachLocation AttachLocationType, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AttachRootComponentToActor");

	Params::AActor_K2_AttachRootComponentToActor_Params Parms{};

	Parms.InParentActor = InParentActor;
	Parms.InSocketName = InSocketName;
	Parms.AttachLocationType = AttachLocationType;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.K2_AttachRootComponentTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             InParent                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachLocation         AttachLocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bWeldSimulatedBodies                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AttachRootComponentTo(class USceneComponent* InParent, class FName InSocketName, enum class EAttachLocation AttachLocationType, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AttachRootComponentTo");

	Params::AActor_K2_AttachRootComponentTo_Params Parms{};

	Parms.InParent = InParent;
	Parms.InSocketName = InSocketName;
	Parms.AttachLocationType = AttachLocationType;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.K2_AddActorWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  DeltaTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorWorldTransform(struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AddActorWorldTransform");

	Params::AActor_K2_AddActorWorldTransform_Params Parms{};

	Parms.DeltaTransform = DeltaTransform;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.K2_AddActorWorldRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    DeltaRotation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AddActorWorldRotation");

	Params::AActor_K2_AddActorWorldRotation_Params Parms{};

	Parms.DeltaRotation = DeltaRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.K2_AddActorWorldOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DeltaLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorWorldOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AddActorWorldOffset");

	Params::AActor_K2_AddActorWorldOffset_Params Parms{};

	Parms.DeltaLocation = DeltaLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.K2_AddActorLocalTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  NewTransform                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorLocalTransform(struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AddActorLocalTransform");

	Params::AActor_K2_AddActorLocalTransform_Params Parms{};

	Parms.NewTransform = NewTransform;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.K2_AddActorLocalRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    DeltaRotation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AddActorLocalRotation");

	Params::AActor_K2_AddActorLocalRotation_Params Parms{};

	Parms.DeltaRotation = DeltaRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.K2_AddActorLocalOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     DeltaLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepHitResult                                                   (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorLocalOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "K2_AddActorLocalOffset");

	Params::AActor_K2_AddActorLocalOffset_Params Parms{};

	Parms.DeltaLocation = DeltaLocation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

}


// Function Engine.Actor.IsOverlappingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      Other                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::IsOverlappingActor(class AActor* Other)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "IsOverlappingActor");

	Params::AActor_IsOverlappingActor_Params Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.IsChildActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::IsChildActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "IsChildActor");

	Params::AActor_IsChildActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.IsActorTickEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::IsActorTickEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "IsActorTickEnabled");

	Params::AActor_IsActorTickEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.IsActorBeingDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::IsActorBeingDestroyed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "IsActorBeingDestroyed");

	Params::AActor_IsActorBeingDestroyed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.HasAuthority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::HasAuthority()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "HasAuthority");

	Params::AActor_HasAuthority_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetVerticalDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      OtherActor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetVerticalDistanceTo(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetVerticalDistanceTo");

	Params::AActor_GetVerticalDistanceTo_Params Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetVelocity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetVelocity");

	Params::AActor_GetVelocity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AActor::GetTransform()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetTransform");

	Params::AActor_GetTransform_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::GetTickableWhenPaused()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetTickableWhenPaused");

	Params::AActor_GetTickableWhenPaused_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetSquaredDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      OtherActor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetSquaredDistanceTo(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetSquaredDistanceTo");

	Params::AActor_GetSquaredDistanceTo_Params Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetRemoteRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ENetRole                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ENetRole AActor::GetRemoteRole()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetRemoteRole");

	Params::AActor_GetRemoteRole_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetParentComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChildActorComponent*        ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChildActorComponent* AActor::GetParentComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetParentComponent");

	Params::AActor_GetParentComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetParentActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AActor::GetParentActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetParentActor");

	Params::AActor_GetParentActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AActor::GetOwner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetOwner");

	Params::AActor_GetOwner_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetOverlappingComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UPrimitiveComponent*> OverlappingComponents                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActor::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* OverlappingComponents)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetOverlappingComponents");

	Params::AActor_GetOverlappingComponents_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OverlappingComponents != nullptr)
		*OverlappingComponents = std::move(Parms.OverlappingComponents);

}


// Function Engine.Actor.GetOverlappingActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>              OverlappingActors                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>          ClassFilter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::GetOverlappingActors(TArray<class AActor*>* OverlappingActors, TSubclassOf<class AActor> ClassFilter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetOverlappingActors");

	Params::AActor_GetOverlappingActors_Params Parms{};

	Parms.ClassFilter = ClassFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OverlappingActors != nullptr)
		*OverlappingActors = std::move(Parms.OverlappingActors);

}


// Function Engine.Actor.GetLocalRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ENetRole                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ENetRole AActor::GetLocalRole()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetLocalRole");

	Params::AActor_GetLocalRole_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetLifeSpan
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetLifeSpan()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetLifeSpan");

	Params::AActor_GetLifeSpan_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetInstigatorController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* AActor::GetInstigatorController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetInstigatorController");

	Params::AActor_GetInstigatorController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AActor::GetInstigator()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetInstigator");

	Params::AActor_GetInstigator_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetInputVectorAxisValue
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        InputAxisKey                                                     (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetInputVectorAxisValue(const struct FKey& InputAxisKey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetInputVectorAxisValue");

	Params::AActor_GetInputVectorAxisValue_Params Parms{};

	Parms.InputAxisKey = InputAxisKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetInputAxisValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InputAxisName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetInputAxisValue(class FName InputAxisName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetInputAxisValue");

	Params::AActor_GetInputAxisValue_Params Parms{};

	Parms.InputAxisName = InputAxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetInputAxisKeyValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        InputAxisKey                                                     (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetInputAxisKeyValue(const struct FKey& InputAxisKey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetInputAxisKeyValue");

	Params::AActor_GetInputAxisKeyValue_Params Parms{};

	Parms.InputAxisKey = InputAxisKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetHorizontalDotProductTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      OtherActor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetHorizontalDotProductTo(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetHorizontalDotProductTo");

	Params::AActor_GetHorizontalDotProductTo_Params Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetHorizontalDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      OtherActor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetHorizontalDistanceTo(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetHorizontalDistanceTo");

	Params::AActor_GetHorizontalDistanceTo_Params Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetGameTimeSinceCreation
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetGameTimeSinceCreation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetGameTimeSinceCreation");

	Params::AActor_GetGameTimeSinceCreation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetDotProductTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      OtherActor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetDotProductTo(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetDotProductTo");

	Params::AActor_GetDotProductTo_Params Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      OtherActor                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetDistanceTo(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetDistanceTo");

	Params::AActor_GetDistanceTo_Params Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetComponentsByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UActorComponent> ComponentClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Tag                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>     ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> AActor::GetComponentsByTag(TSubclassOf<class UActorComponent> ComponentClass, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetComponentsByTag");

	Params::AActor_GetComponentsByTag_Params Parms{};

	Parms.ComponentClass = ComponentClass;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetComponentsByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UActorComponent> ComponentClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>     ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> AActor::GetComponentsByClass(TSubclassOf<class UActorComponent> ComponentClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetComponentsByClass");

	Params::AActor_GetComponentsByClass_Params Parms{};

	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetComponentByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UActorComponent> ComponentClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* AActor::GetComponentByClass(TSubclassOf<class UActorComponent> ComponentClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetComponentByClass");

	Params::AActor_GetComponentByClass_Params Parms{};

	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetAttachParentSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AActor::GetAttachParentSocketName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetAttachParentSocketName");

	Params::AActor_GetAttachParentSocketName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetAttachParentActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AActor::GetAttachParentActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetAttachParentActor");

	Params::AActor_GetAttachParentActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetAttachedActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               bResetArray                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::GetAttachedActors(TArray<class AActor*>* OutActors, bool bResetArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetAttachedActors");

	Params::AActor_GetAttachedActors_Params Parms{};

	Parms.bResetArray = bResetArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

}


// Function Engine.Actor.GetAllChildActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>              ChildActors                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               bIncludeDescendants                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::GetAllChildActors(TArray<class AActor*>* ChildActors, bool bIncludeDescendants)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetAllChildActors");

	Params::AActor_GetAllChildActors_Params Parms{};

	Parms.bIncludeDescendants = bIncludeDescendants;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ChildActors != nullptr)
		*ChildActors = std::move(Parms.ChildActors);

}


// Function Engine.Actor.GetActorUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorUpVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorUpVector");

	Params::AActor_GetActorUpVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetActorTimeDilation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetActorTimeDilation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorTimeDilation");

	Params::AActor_GetActorTimeDilation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetActorTickInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetActorTickInterval()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorTickInterval");

	Params::AActor_GetActorTickInterval_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetActorScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorScale3D()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorScale3D");

	Params::AActor_GetActorScale3D_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetActorRightVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorRightVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorRightVector");

	Params::AActor_GetActorRightVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetActorRelativeScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorRelativeScale3D()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorRelativeScale3D");

	Params::AActor_GetActorRelativeScale3D_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetActorForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorForwardVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorForwardVector");

	Params::AActor_GetActorForwardVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetActorEyesViewPoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     OutLocation                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    OutRotation                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AActor::GetActorEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorEyesViewPoint");

	Params::AActor_GetActorEyesViewPoint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);

}


// Function Engine.Actor.GetActorEnableCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::GetActorEnableCollision()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorEnableCollision");

	Params::AActor_GetActorEnableCollision_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.GetActorBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               bOnlyCollidingComponents                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxExtent                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::GetActorBounds(bool bOnlyCollidingComponents, struct FVector* Origin, struct FVector* BoxExtent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "GetActorBounds");

	Params::AActor_GetActorBounds_Params Parms{};

	Parms.bOnlyCollidingComponents = bOnlyCollidingComponents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);

}


// Function Engine.Actor.ForceNetUpdate
// (Native, Public, BlueprintCallable)
// Parameters:

void AActor::ForceNetUpdate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ForceNetUpdate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.FlushNetDormancy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:

void AActor::FlushNetDormancy()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "FlushNetDormancy");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.EnableInput
// (Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*           PlayerController                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::EnableInput(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "EnableInput");

	Params::AActor_EnableInput_Params Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.DisableInput
// (Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*           PlayerController                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::DisableInput(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "DisableInput");

	Params::AActor_DisableInput_Params Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.DetachRootComponentFromParent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bMaintainWorldPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::DetachRootComponentFromParent(bool bMaintainWorldPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "DetachRootComponentFromParent");

	Params::AActor_DetachRootComponentFromParent_Params Parms{};

	Parms.bMaintainWorldPosition = bMaintainWorldPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.AddTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*             PrerequisiteComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "AddTickPrerequisiteComponent");

	Params::AActor_AddTickPrerequisiteComponent_Params Parms{};

	Parms.PrerequisiteComponent = PrerequisiteComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.AddTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      PrerequisiteActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::AddTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "AddTickPrerequisiteActor");

	Params::AActor_AddTickPrerequisiteActor_Params Parms{};

	Parms.PrerequisiteActor = PrerequisiteActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Actor.AddComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        TemplateName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bManualAttachment                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  RelativeTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                     ComponentTemplateContext                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* AActor::AddComponent(class FName TemplateName, bool bManualAttachment, struct FTransform& RelativeTransform, class UObject* ComponentTemplateContext)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "AddComponent");

	Params::AActor_AddComponent_Params Parms{};

	Parms.TemplateName = TemplateName;
	Parms.bManualAttachment = bManualAttachment;
	Parms.RelativeTransform = RelativeTransform;
	Parms.ComponentTemplateContext = ComponentTemplateContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Actor.ActorHasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        Tag                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::ActorHasTag(class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Actor", "ActorHasTag");

	Params::AActor_ActorHasTag_Params Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.Info
// (Actor)

class UClass* AInfo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Info");

	return Clss;
}


// Info Engine.Default__Info
// (Public, ClassDefaultObject, ArchetypeObject)

class AInfo* AInfo::GetDefaultObj()
{
	static class AInfo* Default = nullptr;

	if (!Default)
		Default = static_cast<AInfo*>(AInfo::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.GameModeBase
// (Actor)

class UClass* AGameModeBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameModeBase");

	return Clss;
}


// GameModeBase Engine.Default__GameModeBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AGameModeBase* AGameModeBase::GetDefaultObj()
{
	static class AGameModeBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AGameModeBase*>(AGameModeBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.GameModeBase.StartPlay
// (Native, Public, BlueprintCallable)
// Parameters:

void AGameModeBase::StartPlay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "StartPlay");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.SpawnDefaultPawnFor
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      StartSpot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AGameModeBase::SpawnDefaultPawnFor(class AController* NewPlayer, class AActor* StartSpot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "SpawnDefaultPawnFor");

	Params::AGameModeBase_SpawnDefaultPawnFor_Params Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.StartSpot = StartSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.SpawnDefaultPawnAtTransform
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AController*                 NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  SpawnTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class APawn*                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AGameModeBase::SpawnDefaultPawnAtTransform(class AController* NewPlayer, struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "SpawnDefaultPawnAtTransform");

	Params::AGameModeBase_SpawnDefaultPawnAtTransform_Params Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.SpawnTransform = SpawnTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.ShouldReset
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      ActorToReset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::ShouldReset(class AActor* ActorToReset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "ShouldReset");

	Params::AGameModeBase_ShouldReset_Params Parms{};

	Parms.ActorToReset = ActorToReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.ReturnToMainMenuHost
// (Native, Public, BlueprintCallable)
// Parameters:

void AGameModeBase::ReturnToMainMenuHost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "ReturnToMainMenuHost");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.RestartPlayerAtTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AController*                 NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  SpawnTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AGameModeBase::RestartPlayerAtTransform(class AController* NewPlayer, struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "RestartPlayerAtTransform");

	Params::AGameModeBase_RestartPlayerAtTransform_Params Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.SpawnTransform = SpawnTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.RestartPlayerAtPlayerStart
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                 NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      StartSpot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::RestartPlayerAtPlayerStart(class AController* NewPlayer, class AActor* StartSpot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "RestartPlayerAtPlayerStart");

	Params::AGameModeBase_RestartPlayerAtPlayerStart_Params Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.StartSpot = StartSpot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.RestartPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                 NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::RestartPlayer(class AController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "RestartPlayer");

	Params::AGameModeBase_RestartPlayer_Params Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.ResetLevel
// (Native, Public, BlueprintCallable)
// Parameters:

void AGameModeBase::ResetLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "ResetLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.PlayerCanRestart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*           Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::PlayerCanRestart(class APlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "PlayerCanRestart");

	Params::AGameModeBase_PlayerCanRestart_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.MustSpectate
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class APlayerController*           NewPlayerController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::MustSpectate(class APlayerController* NewPlayerController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "MustSpectate");

	Params::AGameModeBase_MustSpectate_Params Parms{};

	Parms.NewPlayerController = NewPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.K2_PostLogin
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*           NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_PostLogin(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "K2_PostLogin");

	Params::AGameModeBase_K2_PostLogin_Params Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.GameModeBase.K2_OnSwapPlayerControllers
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*           OldPC                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*           NewPC                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_OnSwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "K2_OnSwapPlayerControllers");

	Params::AGameModeBase_K2_OnSwapPlayerControllers_Params Parms{};

	Parms.OldPC = OldPC;
	Parms.NewPC = NewPC;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.GameModeBase.K2_OnRestartPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_OnRestartPlayer(class AController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "K2_OnRestartPlayer");

	Params::AGameModeBase_K2_OnRestartPlayer_Params Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.GameModeBase.K2_OnLogout
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 ExitingController                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_OnLogout(class AController* ExitingController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "K2_OnLogout");

	Params::AGameModeBase_K2_OnLogout_Params Parms{};

	Parms.ExitingController = ExitingController;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.GameModeBase.K2_OnChangeName
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 Other                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      NewName                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNameChange                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_OnChangeName(class AController* Other, const class FString& NewName, bool bNameChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "K2_OnChangeName");

	Params::AGameModeBase_K2_OnChangeName_Params Parms{};

	Parms.Other = Other;
	Parms.NewName = NewName;
	Parms.bNameChange = bNameChange;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.GameModeBase.K2_FindPlayerStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                 Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      IncomingName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGameModeBase::K2_FindPlayerStart(class AController* Player, const class FString& IncomingName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "K2_FindPlayerStart");

	Params::AGameModeBase_K2_FindPlayerStart_Params Parms{};

	Parms.Player = Player;
	Parms.IncomingName = IncomingName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.InitStartSpot
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                      StartSpot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::InitStartSpot(class AActor* StartSpot, class AController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "InitStartSpot");

	Params::AGameModeBase_InitStartSpot_Params Parms{};

	Parms.StartSpot = StartSpot;
	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.InitializeHUDForPlayer
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*           NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::InitializeHUDForPlayer(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "InitializeHUDForPlayer");

	Params::AGameModeBase_InitializeHUDForPlayer_Params Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.HasMatchStarted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::HasMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "HasMatchStarted");

	Params::AGameModeBase_HasMatchStarted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.HandleStartingNewPlayer
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*           NewPlayer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::HandleStartingNewPlayer(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "HandleStartingNewPlayer");

	Params::AGameModeBase_HandleStartingNewPlayer_Params Parms{};

	Parms.NewPlayer = NewPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.GetNumSpectators
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeBase::GetNumSpectators()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "GetNumSpectators");

	Params::AGameModeBase_GetNumSpectators_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.GetNumPlayers
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeBase::GetNumPlayers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "GetNumPlayers");

	Params::AGameModeBase_GetNumPlayers_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.GetDefaultPawnClassForController
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AController*                 InController                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* AGameModeBase::GetDefaultPawnClassForController(class AController* InController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "GetDefaultPawnClassForController");

	Params::AGameModeBase_GetDefaultPawnClassForController_Params Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.FindPlayerStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      IncomingName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGameModeBase::FindPlayerStart(class AController* Player, const class FString& IncomingName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "FindPlayerStart");

	Params::AGameModeBase_FindPlayerStart_Params Parms{};

	Parms.Player = Player;
	Parms.IncomingName = IncomingName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.ChoosePlayerStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGameModeBase::ChoosePlayerStart(class AController* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "ChoosePlayerStart");

	Params::AGameModeBase_ChoosePlayerStart_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameModeBase.ChangeName
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                 Controller                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      NewName                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNameChange                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::ChangeName(class AController* Controller, const class FString& NewName, bool bNameChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "ChangeName");

	Params::AGameModeBase_ChangeName_Params Parms{};

	Parms.Controller = Controller;
	Parms.NewName = NewName;
	Parms.bNameChange = bNameChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameModeBase.CanSpectate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*           Viewer                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                ViewTarget                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::CanSpectate(class APlayerController* Viewer, class APlayerState* ViewTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameModeBase", "CanSpectate");

	Params::AGameModeBase_CanSpectate_Params Parms{};

	Parms.Viewer = Viewer;
	Parms.ViewTarget = ViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.Pawn
// (Actor, Pawn)

class UClass* APawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Pawn");

	return Clss;
}


// Pawn Engine.Default__Pawn
// (Public, ClassDefaultObject, ArchetypeObject)

class APawn* APawn::GetDefaultObj()
{
	static class APawn* Default = nullptr;

	if (!Default)
		Default = static_cast<APawn*>(APawn::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Pawn.SpawnDefaultController
// (Native, Public, BlueprintCallable)
// Parameters:

void APawn::SpawnDefaultController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "SpawnDefaultController");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.SetCanAffectNavigationGeneration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForceUpdate                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "SetCanAffectNavigationGeneration");

	Params::APawn_SetCanAffectNavigationGeneration_Params Parms{};

	Parms.bNewValue = bNewValue;
	Parms.bForceUpdate = bForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.ReceiveUnpossessed
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 OldController                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::ReceiveUnpossessed(class AController* OldController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "ReceiveUnpossessed");

	Params::APawn_ReceiveUnpossessed_Params Parms{};

	Parms.OldController = OldController;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Pawn.ReceivePossessed
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                 NewController                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::ReceivePossessed(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "ReceivePossessed");

	Params::APawn_ReceivePossessed_Params Parms{};

	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Pawn.PawnMakeNoise
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                              Loudness                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NoiseLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseNoiseMakerLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      NoiseMaker                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::PawnMakeNoise(float Loudness, const struct FVector& NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "PawnMakeNoise");

	Params::APawn_PawnMakeNoise_Params Parms{};

	Parms.Loudness = Loudness;
	Parms.NoiseLocation = NoiseLocation;
	Parms.bUseNoiseMakerLocation = bUseNoiseMakerLocation;
	Parms.NoiseMaker = NoiseMaker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.OnRep_PlayerState
// (Native, Public)
// Parameters:

void APawn::OnRep_PlayerState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "OnRep_PlayerState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.OnRep_Controller
// (Native, Public)
// Parameters:

void APawn::OnRep_Controller()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "OnRep_Controller");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.LaunchPawn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     LaunchVelocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bXYOverride                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bZOverride                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::LaunchPawn(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "LaunchPawn");

	Params::APawn_LaunchPawn_Params Parms{};

	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bXYOverride = bXYOverride;
	Parms.bZOverride = bZOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.K2_GetMovementInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::K2_GetMovementInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "K2_GetMovementInputVector");

	Params::APawn_K2_GetMovementInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.IsPlayerControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsPlayerControlled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "IsPlayerControlled");

	Params::APawn_IsPlayerControlled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsMoveInputIgnored()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "IsMoveInputIgnored");

	Params::APawn_IsMoveInputIgnored_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.IsLocallyControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsLocallyControlled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "IsLocallyControlled");

	Params::APawn_IsLocallyControlled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.IsControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsControlled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "IsControlled");

	Params::APawn_IsControlled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.IsBotControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsBotControlled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "IsBotControlled");

	Params::APawn_IsBotControlled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.GetPendingMovementInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::GetPendingMovementInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "GetPendingMovementInputVector");

	Params::APawn_GetPendingMovementInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.GetNavAgentLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::GetNavAgentLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "GetNavAgentLocation");

	Params::APawn_GetNavAgentLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.GetMovementComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPawnMovementComponent*      ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPawnMovementComponent* APawn::GetMovementComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "GetMovementComponent");

	Params::APawn_GetMovementComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.GetMovementBaseActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                       Pawn                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* APawn::GetMovementBaseActor(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "GetMovementBaseActor");

	Params::APawn_GetMovementBaseActor_Params Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.GetLastMovementInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::GetLastMovementInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "GetLastMovementInputVector");

	Params::APawn_GetLastMovementInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.GetControlRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator APawn::GetControlRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "GetControlRotation");

	Params::APawn_GetControlRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.GetController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                 ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* APawn::GetController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "GetController");

	Params::APawn_GetController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.GetBaseAimRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator APawn::GetBaseAimRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "GetBaseAimRotation");

	Params::APawn_GetBaseAimRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.DetachFromControllerPendingDestroy
// (Native, Public, BlueprintCallable)
// Parameters:

void APawn::DetachFromControllerPendingDestroy()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "DetachFromControllerPendingDestroy");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.ConsumeMovementInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::ConsumeMovementInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "ConsumeMovementInputVector");

	Params::APawn_ConsumeMovementInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Pawn.AddMovementInput
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     WorldDirection                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScaleValue                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForce                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::AddMovementInput(const struct FVector& WorldDirection, float ScaleValue, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "AddMovementInput");

	Params::APawn_AddMovementInput_Params Parms{};

	Parms.WorldDirection = WorldDirection;
	Parms.ScaleValue = ScaleValue;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.AddControllerYawInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::AddControllerYawInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "AddControllerYawInput");

	Params::APawn_AddControllerYawInput_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.AddControllerRollInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::AddControllerRollInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "AddControllerRollInput");

	Params::APawn_AddControllerRollInput_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Pawn.AddControllerPitchInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::AddControllerPitchInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Pawn", "AddControllerPitchInput");

	Params::APawn_AddControllerPitchInput_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.Controller
// (Actor)

class UClass* AController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Controller");

	return Clss;
}


// Controller Engine.Default__Controller
// (Public, ClassDefaultObject, ArchetypeObject)

class AController* AController::GetDefaultObj()
{
	static class AController* Default = nullptr;

	if (!Default)
		Default = static_cast<AController*>(AController::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Controller.UnPossess
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AController::UnPossess()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "UnPossess");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.StopMovement
// (Native, Public, BlueprintCallable)
// Parameters:

void AController::StopMovement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "StopMovement");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.SetInitialLocationAndRotation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRotation                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AController::SetInitialLocationAndRotation(struct FVector& NewLocation, struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "SetInitialLocationAndRotation");

	Params::AController_SetInitialLocationAndRotation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.NewRotation = NewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.SetIgnoreMoveInput
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewMoveInput                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::SetIgnoreMoveInput(bool bNewMoveInput)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "SetIgnoreMoveInput");

	Params::AController_SetIgnoreMoveInput_Params Parms{};

	Parms.bNewMoveInput = bNewMoveInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.SetIgnoreLookInput
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewLookInput                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::SetIgnoreLookInput(bool bNewLookInput)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "SetIgnoreLookInput");

	Params::AController_SetIgnoreLookInput_Params Parms{};

	Parms.bNewLookInput = bNewLookInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.SetControlRotation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    NewRotation                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AController::SetControlRotation(struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "SetControlRotation");

	Params::AController_SetControlRotation_Params Parms{};

	Parms.NewRotation = NewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.ResetIgnoreMoveInput
// (Native, Public, BlueprintCallable)
// Parameters:

void AController::ResetIgnoreMoveInput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "ResetIgnoreMoveInput");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.ResetIgnoreLookInput
// (Native, Public, BlueprintCallable)
// Parameters:

void AController::ResetIgnoreLookInput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "ResetIgnoreLookInput");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.ResetIgnoreInputFlags
// (Native, Public, BlueprintCallable)
// Parameters:

void AController::ResetIgnoreInputFlags()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "ResetIgnoreInputFlags");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.ReceiveUnPossess
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                       UnpossessedPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::ReceiveUnPossess(class APawn* UnpossessedPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "ReceiveUnPossess");

	Params::AController_ReceiveUnPossess_Params Parms{};

	Parms.UnpossessedPawn = UnpossessedPawn;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Controller.ReceivePossess
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                       PossessedPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::ReceivePossess(class APawn* PossessedPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "ReceivePossess");

	Params::AController_ReceivePossess_Params Parms{};

	Parms.PossessedPawn = PossessedPawn;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Controller.ReceiveInstigatedAnyDamage
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
// Parameters:
// float                              Damage                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                 DamageType                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamagedActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::ReceiveInstigatedAnyDamage(float Damage, class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "ReceiveInstigatedAnyDamage");

	Params::AController_ReceiveInstigatedAnyDamage_Params Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.DamagedActor = DamagedActor;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Controller.Possess
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                       InPawn                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::Possess(class APawn* InPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "Possess");

	Params::AController_Possess_Params Parms{};

	Parms.InPawn = InPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.OnRep_PlayerState
// (Native, Public)
// Parameters:

void AController::OnRep_PlayerState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "OnRep_PlayerState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.OnRep_Pawn
// (Native, Public)
// Parameters:

void AController::OnRep_Pawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "OnRep_Pawn");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.LineOfSightTo
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      Other                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ViewPoint                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAlternateChecks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::LineOfSightTo(class AActor* Other, const struct FVector& ViewPoint, bool bAlternateChecks)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "LineOfSightTo");

	Params::AController_LineOfSightTo_Params Parms{};

	Parms.Other = Other;
	Parms.ViewPoint = ViewPoint;
	Parms.bAlternateChecks = bAlternateChecks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.K2_GetPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AController::K2_GetPawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "K2_GetPawn");

	Params::AController_K2_GetPawn_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.IsPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsPlayerController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "IsPlayerController");

	Params::AController_IsPlayerController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsMoveInputIgnored()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "IsMoveInputIgnored");

	Params::AController_IsMoveInputIgnored_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.IsLookInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsLookInputIgnored()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "IsLookInputIgnored");

	Params::AController_IsLookInputIgnored_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.IsLocalPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsLocalPlayerController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "IsLocalPlayerController");

	Params::AController_IsLocalPlayerController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.IsLocalController
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsLocalController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "IsLocalController");

	Params::AController_IsLocalController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.GetViewTarget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AController::GetViewTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "GetViewTarget");

	Params::AController_GetViewTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.GetDesiredRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AController::GetDesiredRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "GetDesiredRotation");

	Params::AController_GetDesiredRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.GetControlRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AController::GetControlRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "GetControlRotation");

	Params::AController_GetControlRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Controller.ClientSetRotation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bResetCamera                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "ClientSetRotation");

	Params::AController_ClientSetRotation_Params Parms{};

	Parms.NewRotation = NewRotation;
	Parms.bResetCamera = bResetCamera;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.ClientSetLocation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AController::ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "ClientSetLocation");

	Params::AController_ClientSetLocation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.NewRotation = NewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Controller.CastToPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* AController::CastToPlayerController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Controller", "CastToPlayerController");

	Params::AController_CastToPlayerController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.PlayerController
// (Actor, PlayerController)

class UClass* APlayerController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerController");

	return Clss;
}


// PlayerController Engine.Default__PlayerController
// (Public, ClassDefaultObject, ArchetypeObject)

class APlayerController* APlayerController::GetDefaultObj()
{
	static class APlayerController* Default = nullptr;

	if (!Default)
		Default = static_cast<APlayerController*>(APlayerController::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PlayerController.WasInputKeyJustReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::WasInputKeyJustReleased(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "WasInputKeyJustReleased");

	Params::APlayerController_WasInputKeyJustReleased_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.WasInputKeyJustPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::WasInputKeyJustPressed(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "WasInputKeyJustPressed");

	Params::APlayerController_WasInputKeyJustPressed_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.ToggleSpeaking
// (Exec, Native, Public)
// Parameters:
// bool                               bInSpeaking                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ToggleSpeaking(bool bInSpeaking)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ToggleSpeaking");

	Params::APlayerController_ToggleSpeaking_Params Parms{};

	Parms.bInSpeaking = bInSpeaking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SwitchLevel
// (Exec, Native, Public)
// Parameters:
// class FString                      URL                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SwitchLevel(const class FString& URL)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SwitchLevel");

	Params::APlayerController_SwitchLevel_Params Parms{};

	Parms.URL = URL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.StopHapticEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EControllerHand         Hand                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::StopHapticEffect(enum class EControllerHand Hand)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "StopHapticEffect");

	Params::APlayerController_StopHapticEffect_Params Parms{};

	Parms.Hand = Hand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.StartFire
// (Exec, Native, Public)
// Parameters:
// uint8                              FireModeNum                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::StartFire(uint8 FireModeNum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "StartFire");

	Params::APlayerController_StartFire_Params Parms{};

	Parms.FireModeNum = FireModeNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetVirtualJoystickVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bVisible                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetVirtualJoystickVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetVirtualJoystickVisibility");

	Params::APlayerController_SetVirtualJoystickVisibility_Params Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetViewTargetWithBlend
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      NewViewTarget                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EViewTargetBlendFunctionBlendFunc                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendExp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLockOutgoing                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, enum class EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetViewTargetWithBlend");

	Params::APlayerController_SetViewTargetWithBlend_Params Parms{};

	Parms.NewViewTarget = NewViewTarget;
	Parms.BlendTime = BlendTime;
	Parms.BlendFunc = BlendFunc;
	Parms.BlendExp = BlendExp;
	Parms.bLockOutgoing = bLockOutgoing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetName
// (Exec, Native, Public)
// Parameters:
// class FString                      S                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetName(const class FString& S)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetName");

	Params::APlayerController_SetName_Params Parms{};

	Parms.S = S;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetMouseLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              X                                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Y                                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetMouseLocation(int32 X, int32 Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetMouseLocation");

	Params::APlayerController_SetMouseLocation_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetMouseCursorWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EMouseCursor            Cursor                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                 CursorWidget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetMouseCursorWidget(enum class EMouseCursor Cursor, class UUserWidget* CursorWidget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetMouseCursorWidget");

	Params::APlayerController_SetMouseCursorWidget_Params Parms{};

	Parms.Cursor = Cursor;
	Parms.CursorWidget = CursorWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetHapticsByValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Frequency                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Amplitude                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EControllerHand         Hand                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetHapticsByValue(float Frequency, float Amplitude, enum class EControllerHand Hand)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetHapticsByValue");

	Params::APlayerController_SetHapticsByValue_Params Parms{};

	Parms.Frequency = Frequency;
	Parms.Amplitude = Amplitude;
	Parms.Hand = Hand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetDisableHaptics
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewDisabled                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetDisableHaptics(bool bNewDisabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetDisableHaptics");

	Params::APlayerController_SetDisableHaptics_Params Parms{};

	Parms.bNewDisabled = bNewDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetControllerLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                      Color                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetControllerLightColor(const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetControllerLightColor");

	Params::APlayerController_SetControllerLightColor_Params Parms{};

	Parms.Color = Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetCinematicMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInCinematicMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bHidePlayer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsHUD                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsMovement                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsTurning                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetCinematicMode");

	Params::APlayerController_SetCinematicMode_Params Parms{};

	Parms.bInCinematicMode = bInCinematicMode;
	Parms.bHidePlayer = bHidePlayer;
	Parms.bAffectsHUD = bAffectsHUD;
	Parms.bAffectsMovement = bAffectsMovement;
	Parms.bAffectsTurning = bAffectsTurning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetAudioListenerOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*             AttachToComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::SetAudioListenerOverride(class USceneComponent* AttachToComponent, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetAudioListenerOverride");

	Params::APlayerController_SetAudioListenerOverride_Params Parms{};

	Parms.AttachToComponent = AttachToComponent;
	Parms.Location = Location;
	Parms.Rotation = Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SetAudioListenerAttenuationOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*             AttachToComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     AttenuationLocationOVerride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetAudioListenerAttenuationOverride(class USceneComponent* AttachToComponent, const struct FVector& AttenuationLocationOVerride)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SetAudioListenerAttenuationOverride");

	Params::APlayerController_SetAudioListenerAttenuationOverride_Params Parms{};

	Parms.AttachToComponent = AttachToComponent;
	Parms.AttenuationLocationOVerride = AttenuationLocationOVerride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerViewSelf
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FViewTargetTransitionParams TransitionParams                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerViewSelf");

	Params::APlayerController_ServerViewSelf_Params Parms{};

	Parms.TransitionParams = TransitionParams;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerViewPrevPlayer
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerViewPrevPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerViewPrevPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerViewNextPlayer
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerViewNextPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerViewNextPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerVerifyViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerVerifyViewTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerVerifyViewTarget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerUpdateMultipleLevelsVisibility
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<struct FUpdateLevelVisibilityLevelInfo>LevelVisibilities                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ServerUpdateMultipleLevelsVisibility(TArray<struct FUpdateLevelVisibilityLevelInfo>& LevelVisibilities)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerUpdateMultipleLevelsVisibility");

	Params::APlayerController_ServerUpdateMultipleLevelsVisibility_Params Parms{};

	Parms.LevelVisibilities = LevelVisibilities;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerUpdateLevelVisibility
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                        PackageName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsVisible                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerUpdateLevelVisibility(class FName PackageName, bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerUpdateLevelVisibility");

	Params::APlayerController_ServerUpdateLevelVisibility_Params Parms{};

	Parms.PackageName = PackageName;
	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerUpdateCamera
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize         CamLoc                                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                              CamPitchAndYaw                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerUpdateCamera(const struct FVector_NetQuantize& CamLoc, int32 CamPitchAndYaw)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerUpdateCamera");

	Params::APlayerController_ServerUpdateCamera_Params Parms{};

	Parms.CamLoc = CamLoc;
	Parms.CamPitchAndYaw = CamPitchAndYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerUnmutePlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl            PlayerID                                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerUnmutePlayer(const struct FUniqueNetIdRepl& PlayerID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerUnmutePlayer");

	Params::APlayerController_ServerUnmutePlayer_Params Parms{};

	Parms.PlayerID = PlayerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerToggleAILogging
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerToggleAILogging()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerToggleAILogging");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerShortTimeout
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerShortTimeout()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerShortTimeout");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerSetSpectatorWaiting
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                               bWaiting                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerSetSpectatorWaiting(bool bWaiting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerSetSpectatorWaiting");

	Params::APlayerController_ServerSetSpectatorWaiting_Params Parms{};

	Parms.bWaiting = bWaiting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerSetSpectatorLocation
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                     NewLoc                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRot                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ServerSetSpectatorLocation(const struct FVector& NewLoc, const struct FRotator& NewRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerSetSpectatorLocation");

	Params::APlayerController_ServerSetSpectatorLocation_Params Parms{};

	Parms.NewLoc = NewLoc;
	Parms.NewRot = NewRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerRestartPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerRestartPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerRestartPlayer");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerPause
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerPause()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerPause");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerNotifyLoadedWorld
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                        WorldPackageName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerNotifyLoadedWorld(class FName WorldPackageName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerNotifyLoadedWorld");

	Params::APlayerController_ServerNotifyLoadedWorld_Params Parms{};

	Parms.WorldPackageName = WorldPackageName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerMutePlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl            PlayerID                                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerMutePlayer(const struct FUniqueNetIdRepl& PlayerID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerMutePlayer");

	Params::APlayerController_ServerMutePlayer_Params Parms{};

	Parms.PlayerID = PlayerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerCheckClientPossessionReliable
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerCheckClientPossessionReliable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerCheckClientPossessionReliable");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerCheckClientPossession
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void APlayerController::ServerCheckClientPossession()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerCheckClientPossession");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerChangeName
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                      S                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerChangeName(const class FString& S)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerChangeName");

	Params::APlayerController_ServerChangeName_Params Parms{};

	Parms.S = S;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerCamera
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                        NewMode                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerCamera(class FName NewMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerCamera");

	Params::APlayerController_ServerCamera_Params Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ServerAcknowledgePossession
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class APawn*                       P                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerAcknowledgePossession(class APawn* P)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ServerAcknowledgePossession");

	Params::APlayerController_ServerAcknowledgePossession_Params Parms{};

	Parms.P = P;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.SendToConsole
// (Exec, Native, Public)
// Parameters:
// class FString                      Command                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SendToConsole(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "SendToConsole");

	Params::APlayerController_SendToConsole_Params Parms{};

	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.RestartLevel
// (Exec, Native, Public)
// Parameters:

void APlayerController::RestartLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "RestartLevel");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ResetControllerLightColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void APlayerController::ResetControllerLightColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ResetControllerLightColor");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ProjectWorldLocationToScreen
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenLocation                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPlayerViewportRelative                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::ProjectWorldLocationToScreen(const struct FVector& WorldLocation, struct FVector2D* ScreenLocation, bool bPlayerViewportRelative)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ProjectWorldLocationToScreen");

	Params::APlayerController_ProjectWorldLocationToScreen_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.bPlayerViewportRelative = bPlayerViewportRelative;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ScreenLocation != nullptr)
		*ScreenLocation = std::move(Parms.ScreenLocation);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.PlayHapticEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHapticFeedbackEffect_Base*  HapticEffect                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EControllerHand         Hand                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLoop                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::PlayHapticEffect(class UHapticFeedbackEffect_Base* HapticEffect, enum class EControllerHand Hand, float Scale, bool bLoop)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "PlayHapticEffect");

	Params::APlayerController_PlayHapticEffect_Params Parms{};

	Parms.HapticEffect = HapticEffect;
	Parms.Hand = Hand;
	Parms.Scale = Scale;
	Parms.bLoop = bLoop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.PlayDynamicForceFeedback
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// float                              Intensity                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsLeftLarge                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsLeftSmall                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsRightLarge                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsRightSmall                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EDynamicForceFeedbackActionAction                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo           LatentInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, enum class EDynamicForceFeedbackAction Action, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "PlayDynamicForceFeedback");

	Params::APlayerController_PlayDynamicForceFeedback_Params Parms{};

	Parms.Intensity = Intensity;
	Parms.Duration = Duration;
	Parms.bAffectsLeftLarge = bAffectsLeftLarge;
	Parms.bAffectsLeftSmall = bAffectsLeftSmall;
	Parms.bAffectsRightLarge = bAffectsRightLarge;
	Parms.bAffectsRightSmall = bAffectsRightSmall;
	Parms.Action = Action;
	Parms.LatentInfo = LatentInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.Pause
// (Exec, Native, Public)
// Parameters:

void APlayerController::Pause()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "Pause");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.OnServerStartedVisualLogger
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                               bIsLogging                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::OnServerStartedVisualLogger(bool bIsLogging)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "OnServerStartedVisualLogger");

	Params::APlayerController_OnServerStartedVisualLogger_Params Parms{};

	Parms.bIsLogging = bIsLogging;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.LocalTravel
// (Exec, Native, Public)
// Parameters:
// class FString                      URL                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::LocalTravel(const class FString& URL)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "LocalTravel");

	Params::APlayerController_LocalTravel_Params Parms{};

	Parms.URL = URL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.K2_ClientPlayForceFeedback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*        ForceFeedbackEffect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Tag                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLooping                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIgnoreTimeDilation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPlayWhilePaused                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::K2_ClientPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "K2_ClientPlayForceFeedback");

	Params::APlayerController_K2_ClientPlayForceFeedback_Params Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Tag = Tag;
	Parms.bLooping = bLooping;
	Parms.bIgnoreTimeDilation = bIgnoreTimeDilation;
	Parms.bPlayWhilePaused = bPlayWhilePaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.IsInputKeyDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::IsInputKeyDown(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "IsInputKeyDown");

	Params::APlayerController_IsInputKeyDown_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetViewportSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              SizeX                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SizeY                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetViewportSize(int32* SizeX, int32* SizeY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetViewportSize");

	Params::APlayerController_GetViewportSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SizeX != nullptr)
		*SizeX = Parms.SizeX;

	if (SizeY != nullptr)
		*SizeY = Parms.SizeY;

}


// Function Engine.PlayerController.GetSpectatorPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASpectatorPawn*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpectatorPawn* APlayerController::GetSpectatorPawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetSpectatorPawn");

	Params::APlayerController_GetSpectatorPawn_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetMousePosition
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              LocationX                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LocationY                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetMousePosition(float* LocationX, float* LocationY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetMousePosition");

	Params::APlayerController_GetMousePosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (LocationX != nullptr)
		*LocationX = Parms.LocationX;

	if (LocationY != nullptr)
		*LocationY = Parms.LocationY;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetInputVectorKeyState
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APlayerController::GetInputVectorKeyState(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetInputVectorKeyState");

	Params::APlayerController_GetInputVectorKeyState_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetInputTouchState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETouchIndex             FingerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LocationX                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LocationY                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsCurrentlyPressed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetInputTouchState(enum class ETouchIndex FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetInputTouchState");

	Params::APlayerController_GetInputTouchState_Params Parms{};

	Parms.FingerIndex = FingerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (LocationX != nullptr)
		*LocationX = Parms.LocationX;

	if (LocationY != nullptr)
		*LocationY = Parms.LocationY;

	if (bIsCurrentlyPressed != nullptr)
		*bIsCurrentlyPressed = Parms.bIsCurrentlyPressed;

}


// Function Engine.PlayerController.GetInputMouseDelta
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              DeltaX                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaY                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetInputMouseDelta(float* DeltaX, float* DeltaY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetInputMouseDelta");

	Params::APlayerController_GetInputMouseDelta_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (DeltaX != nullptr)
		*DeltaX = Parms.DeltaX;

	if (DeltaY != nullptr)
		*DeltaY = Parms.DeltaY;

}


// Function Engine.PlayerController.GetInputMotionState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Tilt                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     RotationRate                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Gravity                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Acceleration                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetInputMotionState(struct FVector* Tilt, struct FVector* RotationRate, struct FVector* Gravity, struct FVector* Acceleration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetInputMotionState");

	Params::APlayerController_GetInputMotionState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Tilt != nullptr)
		*Tilt = std::move(Parms.Tilt);

	if (RotationRate != nullptr)
		*RotationRate = std::move(Parms.RotationRate);

	if (Gravity != nullptr)
		*Gravity = std::move(Parms.Gravity);

	if (Acceleration != nullptr)
		*Acceleration = std::move(Parms.Acceleration);

}


// Function Engine.PlayerController.GetInputKeyTimeDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerController::GetInputKeyTimeDown(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetInputKeyTimeDown");

	Params::APlayerController_GetInputKeyTimeDown_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetInputAnalogStickState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EControllerAnalogStick  WhichStick                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StickX                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StickY                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetInputAnalogStickState(enum class EControllerAnalogStick WhichStick, float* StickX, float* StickY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetInputAnalogStickState");

	Params::APlayerController_GetInputAnalogStickState_Params Parms{};

	Parms.WhichStick = WhichStick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (StickX != nullptr)
		*StickX = Parms.StickX;

	if (StickY != nullptr)
		*StickY = Parms.StickY;

}


// Function Engine.PlayerController.GetInputAnalogKeyState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerController::GetInputAnalogKeyState(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetInputAnalogKeyState");

	Params::APlayerController_GetInputAnalogKeyState_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHUD*                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHUD* APlayerController::GetHUD()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetHUD");

	Params::APlayerController_GetHUD_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetHitResultUnderFingerForObjects
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETouchIndex             FingerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitResult                                                        (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderFingerForObjects(enum class ETouchIndex FingerIndex, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetHitResultUnderFingerForObjects");

	Params::APlayerController_GetHitResultUnderFingerForObjects_Params Parms{};

	Parms.FingerIndex = FingerIndex;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetHitResultUnderFingerByChannel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETouchIndex             FingerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitResult                                                        (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderFingerByChannel(enum class ETouchIndex FingerIndex, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetHitResultUnderFingerByChannel");

	Params::APlayerController_GetHitResultUnderFingerByChannel_Params Parms{};

	Parms.FingerIndex = FingerIndex;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetHitResultUnderFinger
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETouchIndex             FingerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECollisionChannel       TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitResult                                                        (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderFinger(enum class ETouchIndex FingerIndex, enum class ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetHitResultUnderFinger");

	Params::APlayerController_GetHitResultUnderFinger_Params Parms{};

	Parms.FingerIndex = FingerIndex;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetHitResultUnderCursorForObjects
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitResult                                                        (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderCursorForObjects(TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetHitResultUnderCursorForObjects");

	Params::APlayerController_GetHitResultUnderCursorForObjects_Params Parms{};

	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetHitResultUnderCursorByChannel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitResult                                                        (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderCursorByChannel(enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetHitResultUnderCursorByChannel");

	Params::APlayerController_GetHitResultUnderCursorByChannel_Params Parms{};

	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetHitResultUnderCursor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ECollisionChannel       TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitResult                                                        (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderCursor(enum class ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetHitResultUnderCursor");

	Params::APlayerController_GetHitResultUnderCursor_Params Parms{};

	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.GetFocalLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APlayerController::GetFocalLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "GetFocalLocation");

	Params::APlayerController_GetFocalLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.FOV
// (Exec, Native, Public)
// Parameters:
// float                              NewFOV                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::FOV(float NewFOV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "FOV");

	Params::APlayerController_FOV_Params Parms{};

	Parms.NewFOV = NewFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.EnableCheats
// (Exec, Native, Public)
// Parameters:

void APlayerController::EnableCheats()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "EnableCheats");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.DeprojectScreenPositionToWorld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ScreenX                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenY                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldLocation                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldDirection                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, struct FVector* WorldLocation, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "DeprojectScreenPositionToWorld");

	Params::APlayerController_DeprojectScreenPositionToWorld_Params Parms{};

	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (WorldLocation != nullptr)
		*WorldLocation = std::move(Parms.WorldLocation);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.DeprojectMousePositionToWorld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldDirection                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::DeprojectMousePositionToWorld(struct FVector* WorldLocation, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "DeprojectMousePositionToWorld");

	Params::APlayerController_DeprojectMousePositionToWorld_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (WorldLocation != nullptr)
		*WorldLocation = std::move(Parms.WorldLocation);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.ConsoleKey
// (Exec, Native, Public)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ConsoleKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ConsoleKey");

	Params::APlayerController_ConsoleKey_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientWasKicked
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FText                        KickReason                                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ClientWasKicked(class FText& KickReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientWasKicked");

	Params::APlayerController_ClientWasKicked_Params Parms{};

	Parms.KickReason = KickReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientVoiceHandshakeComplete
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientVoiceHandshakeComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientVoiceHandshakeComplete");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientUpdateMultipleLevelsStreamingStatus
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FUpdateLevelStreamingLevelStatus>LevelStatuses                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ClientUpdateMultipleLevelsStreamingStatus(TArray<struct FUpdateLevelStreamingLevelStatus>& LevelStatuses)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientUpdateMultipleLevelsStreamingStatus");

	Params::APlayerController_ClientUpdateMultipleLevelsStreamingStatus_Params Parms{};

	Parms.LevelStatuses = LevelStatuses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientUpdateLevelStreamingStatus
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                        PackageName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNewShouldBeLoaded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNewShouldBeVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNewShouldBlockOnLoad                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientUpdateLevelStreamingStatus(class FName PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientUpdateLevelStreamingStatus");

	Params::APlayerController_ClientUpdateLevelStreamingStatus_Params Parms{};

	Parms.PackageName = PackageName;
	Parms.bNewShouldBeLoaded = bNewShouldBeLoaded;
	Parms.bNewShouldBeVisible = bNewShouldBeVisible;
	Parms.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientUnmutePlayer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FUniqueNetIdRepl            PlayerID                                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientUnmutePlayer(const struct FUniqueNetIdRepl& PlayerID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientUnmutePlayer");

	Params::APlayerController_ClientUnmutePlayer_Params Parms{};

	Parms.PlayerID = PlayerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientTravelInternal
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class FString                      URL                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETravelType             TravelType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSeamless                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                       MapPackageGuid                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientTravelInternal(const class FString& URL, enum class ETravelType TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientTravelInternal");

	Params::APlayerController_ClientTravelInternal_Params Parms{};

	Parms.URL = URL;
	Parms.TravelType = TravelType;
	Parms.bSeamless = bSeamless;
	Parms.MapPackageGuid = MapPackageGuid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientTravel
// (Final, Native, Public, HasDefaults)
// Parameters:
// class FString                      URL                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETravelType             TravelType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSeamless                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                       MapPackageGuid                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientTravel(const class FString& URL, enum class ETravelType TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientTravel");

	Params::APlayerController_ClientTravel_Params Parms{};

	Parms.URL = URL;
	Parms.TravelType = TravelType;
	Parms.bSeamless = bSeamless;
	Parms.MapPackageGuid = MapPackageGuid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientTeamMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APlayerState*                SenderPlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      S                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MsgLifeTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientTeamMessage(class APlayerState* SenderPlayerState, const class FString& S, class FName Type, float MsgLifeTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientTeamMessage");

	Params::APlayerController_ClientTeamMessage_Params Parms{};

	Parms.SenderPlayerState = SenderPlayerState;
	Parms.S = S;
	Parms.Type = Type;
	Parms.MsgLifeTime = MsgLifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientStopForceFeedback
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*        ForceFeedbackEffect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Tag                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientStopForceFeedback");

	Params::APlayerController_ClientStopForceFeedback_Params Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientStopCameraShake
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShake>    Shake                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bImmediately                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientStopCameraShake(TSubclassOf<class UCameraShake> Shake, bool bImmediately)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientStopCameraShake");

	Params::APlayerController_ClientStopCameraShake_Params Parms{};

	Parms.Shake = Shake;
	Parms.bImmediately = bImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientStopCameraAnim
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UCameraAnim*                 AnimToStop                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientStopCameraAnim(class UCameraAnim* AnimToStop)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientStopCameraAnim");

	Params::APlayerController_ClientStopCameraAnim_Params Parms{};

	Parms.AnimToStop = AnimToStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientStartOnlineSession
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientStartOnlineSession()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientStartOnlineSession");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSpawnCameraLensEffect
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// TSubclassOf<class AEmitterCameraLensEffectBase>LensEffectEmitterClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSpawnCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSpawnCameraLensEffect");

	Params::APlayerController_ClientSpawnCameraLensEffect_Params Parms{};

	Parms.LensEffectEmitterClass = LensEffectEmitterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSetViewTarget
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                      A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FViewTargetTransitionParams TransitionParams                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ClientSetViewTarget(class AActor* A, const struct FViewTargetTransitionParams& TransitionParams)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSetViewTarget");

	Params::APlayerController_ClientSetViewTarget_Params Parms{};

	Parms.A = A;
	Parms.TransitionParams = TransitionParams;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSetSpectatorWaiting
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                               bWaiting                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetSpectatorWaiting(bool bWaiting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSetSpectatorWaiting");

	Params::APlayerController_ClientSetSpectatorWaiting_Params Parms{};

	Parms.bWaiting = bWaiting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSetHUD
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// TSubclassOf<class AHUD>            NewHUDClass                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetHUD(TSubclassOf<class AHUD> NewHUDClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSetHUD");

	Params::APlayerController_ClientSetHUD_Params Parms{};

	Parms.NewHUDClass = NewHUDClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ForceDuration                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CinematicTextureGroups                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSetForceMipLevelsToBeResident");

	Params::APlayerController_ClientSetForceMipLevelsToBeResident_Params Parms{};

	Parms.Material = Material;
	Parms.ForceDuration = ForceDuration;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSetCinematicMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                               bInCinematicMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsMovement                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsTurning                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsHUD                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSetCinematicMode");

	Params::APlayerController_ClientSetCinematicMode_Params Parms{};

	Parms.bInCinematicMode = bInCinematicMode;
	Parms.bAffectsMovement = bAffectsMovement;
	Parms.bAffectsTurning = bAffectsTurning;
	Parms.bAffectsHUD = bAffectsHUD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSetCameraMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                        NewCamMode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetCameraMode(class FName NewCamMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSetCameraMode");

	Params::APlayerController_ClientSetCameraMode_Params Parms{};

	Parms.NewCamMode = NewCamMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSetCameraFade
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// bool                               bEnableFading                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      FadeColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   FadeAlpha                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FadeTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFadeAudio                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSetCameraFade");

	Params::APlayerController_ClientSetCameraFade_Params Parms{};

	Parms.bEnableFading = bEnableFading;
	Parms.FadeColor = FadeColor;
	Parms.FadeAlpha = FadeAlpha;
	Parms.FadeTime = FadeTime;
	Parms.bFadeAudio = bFadeAudio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientSetBlockOnAsyncLoading
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientSetBlockOnAsyncLoading()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientSetBlockOnAsyncLoading");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientReturnToMainMenuWithTextReason
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FText                        ReturnReason                                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ClientReturnToMainMenuWithTextReason(class FText& ReturnReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientReturnToMainMenuWithTextReason");

	Params::APlayerController_ClientReturnToMainMenuWithTextReason_Params Parms{};

	Parms.ReturnReason = ReturnReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientReturnToMainMenu
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                      ReturnReason                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientReturnToMainMenu(const class FString& ReturnReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientReturnToMainMenu");

	Params::APlayerController_ClientReturnToMainMenu_Params Parms{};

	Parms.ReturnReason = ReturnReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientRetryClientRestart
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APawn*                       NewPawn                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientRetryClientRestart(class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientRetryClientRestart");

	Params::APlayerController_ClientRetryClientRestart_Params Parms{};

	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientRestart
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APawn*                       NewPawn                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientRestart(class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientRestart");

	Params::APlayerController_ClientRestart_Params Parms{};

	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientReset
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientReset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientReset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientRepObjRef
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientRepObjRef(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientRepObjRef");

	Params::APlayerController_ClientRepObjRef_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientReceiveLocalizedMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TSubclassOf<class ULocalMessage>   MESSAGE                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Switch                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                RelatedPlayerState_1                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                RelatedPlayerState_2                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     OptionalObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientReceiveLocalizedMessage(TSubclassOf<class ULocalMessage> MESSAGE, int32 Switch, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientReceiveLocalizedMessage");

	Params::APlayerController_ClientReceiveLocalizedMessage_Params Parms{};

	Parms.MESSAGE = MESSAGE;
	Parms.Switch = Switch;
	Parms.RelatedPlayerState_1 = RelatedPlayerState_1;
	Parms.RelatedPlayerState_2 = RelatedPlayerState_2;
	Parms.OptionalObject = OptionalObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientPrestreamTextures
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                      ForcedActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ForceDuration                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableStreaming                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CinematicTextureGroups                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientPrestreamTextures");

	Params::APlayerController_ClientPrestreamTextures_Params Parms{};

	Parms.ForcedActor = ForcedActor;
	Parms.ForceDuration = ForceDuration;
	Parms.bEnableStreaming = bEnableStreaming;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientPrepareMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                        LevelName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFirst                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLast                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientPrepareMapChange(class FName LevelName, bool bFirst, bool bLast)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientPrepareMapChange");

	Params::APlayerController_ClientPrepareMapChange_Params Parms{};

	Parms.LevelName = LevelName;
	Parms.bFirst = bFirst;
	Parms.bLast = bLast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientPlaySoundAtLocation
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class USoundBase*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientPlaySoundAtLocation(class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientPlaySoundAtLocation");

	Params::APlayerController_ClientPlaySoundAtLocation_Params Parms{};

	Parms.Sound = Sound;
	Parms.Location = Location;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientPlaySound
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class USoundBase*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientPlaySound");

	Params::APlayerController_ClientPlaySound_Params Parms{};

	Parms.Sound = Sound;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientPlayForceFeedback_Internal
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class UForceFeedbackEffect*        ForceFeedbackEffect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FForceFeedbackParameters    Params                                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ClientPlayForceFeedback_Internal(class UForceFeedbackEffect* ForceFeedbackEffect, const struct FForceFeedbackParameters& Params)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientPlayForceFeedback_Internal");

	Params::APlayerController_ClientPlayForceFeedback_Internal_Params Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Params = Params;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientPlayCameraShake
// (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShake>    Shake                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECameraAnimPlaySpace    PlaySpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    UserPlaySpaceRot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ClientPlayCameraShake(TSubclassOf<class UCameraShake> Shake, float Scale, enum class ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientPlayCameraShake");

	Params::APlayerController_ClientPlayCameraShake_Params Parms{};

	Parms.Shake = Shake;
	Parms.Scale = Scale;
	Parms.PlaySpace = PlaySpace;
	Parms.UserPlaySpaceRot = UserPlaySpaceRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientPlayCameraAnim
// (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// class UCameraAnim*                 AnimToPlay                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Rate                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendInTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendOutTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLoop                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRandomStartTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECameraAnimPlaySpace    Space                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    CustomPlaySpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, enum class ECameraAnimPlaySpace Space, const struct FRotator& CustomPlaySpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientPlayCameraAnim");

	Params::APlayerController_ClientPlayCameraAnim_Params Parms{};

	Parms.AnimToPlay = AnimToPlay;
	Parms.Scale = Scale;
	Parms.Rate = Rate;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.bLoop = bLoop;
	Parms.bRandomStartTime = bRandomStartTime;
	Parms.Space = Space;
	Parms.CustomPlaySpace = CustomPlaySpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientMutePlayer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FUniqueNetIdRepl            PlayerID                                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientMutePlayer(const struct FUniqueNetIdRepl& PlayerID)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientMutePlayer");

	Params::APlayerController_ClientMutePlayer_Params Parms{};

	Parms.PlayerID = PlayerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                      S                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MsgLifeTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientMessage(const class FString& S, class FName Type, float MsgLifeTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientMessage");

	Params::APlayerController_ClientMessage_Params Parms{};

	Parms.S = S;
	Parms.Type = Type;
	Parms.MsgLifeTime = MsgLifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientIgnoreMoveInput
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                               bIgnore                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientIgnoreMoveInput(bool bIgnore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientIgnoreMoveInput");

	Params::APlayerController_ClientIgnoreMoveInput_Params Parms{};

	Parms.bIgnore = bIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientIgnoreLookInput
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                               bIgnore                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientIgnoreLookInput(bool bIgnore)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientIgnoreLookInput");

	Params::APlayerController_ClientIgnoreLookInput_Params Parms{};

	Parms.bIgnore = bIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientGotoState
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                        NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientGotoState(class FName NewState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientGotoState");

	Params::APlayerController_ClientGotoState_Params Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientGameEnded
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                      EndGameFocus                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsWinner                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientGameEnded");

	Params::APlayerController_ClientGameEnded_Params Parms{};

	Parms.EndGameFocus = EndGameFocus;
	Parms.bIsWinner = bIsWinner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientForceGarbageCollection
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientForceGarbageCollection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientForceGarbageCollection");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientFlushLevelStreaming
// (Final, Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientFlushLevelStreaming()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientFlushLevelStreaming");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientEndOnlineSession
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientEndOnlineSession()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientEndOnlineSession");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientEnableNetworkVoice
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientEnableNetworkVoice(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientEnableNetworkVoice");

	Params::APlayerController_ClientEnableNetworkVoice_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientCommitMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientCommitMapChange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientCommitMapChange");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientClearCameraLensEffects
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:

void APlayerController::ClientClearCameraLensEffects()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientClearCameraLensEffects");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientCapBandwidth
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int32                              Cap                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientCapBandwidth(int32 Cap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientCapBandwidth");

	Params::APlayerController_ClientCapBandwidth_Params Parms{};

	Parms.Cap = Cap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientCancelPendingMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void APlayerController::ClientCancelPendingMapChange()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientCancelPendingMapChange");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClientAddTextureStreamingLoc
// (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                     InLoc                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOverrideLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClientAddTextureStreamingLoc");

	Params::APlayerController_ClientAddTextureStreamingLoc_Params Parms{};

	Parms.InLoc = InLoc;
	Parms.Duration = Duration;
	Parms.bOverrideLocation = bOverrideLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClearAudioListenerOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void APlayerController::ClearAudioListenerOverride()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClearAudioListenerOverride");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ClearAudioListenerAttenuationOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void APlayerController::ClearAudioListenerAttenuationOverride()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ClearAudioListenerAttenuationOverride");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.CanRestartPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::CanRestartPlayer()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "CanRestartPlayer");

	Params::APlayerController_CanRestartPlayer_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerController.Camera
// (Exec, Native, Public)
// Parameters:
// class FName                        NewMode                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::Camera(class FName NewMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "Camera");

	Params::APlayerController_Camera_Params Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.AddYawInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::AddYawInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "AddYawInput");

	Params::APlayerController_AddYawInput_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.AddRollInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::AddRollInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "AddRollInput");

	Params::APlayerController_AddRollInput_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.AddPitchInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::AddPitchInput(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "AddPitchInput");

	Params::APlayerController_AddPitchInput_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerController.ActivateTouchInterface
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTouchInterface*             NewTouchInterface                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ActivateTouchInterface(class UTouchInterface* NewTouchInterface)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerController", "ActivateTouchInterface");

	Params::APlayerController_ActivateTouchInterface_Params Parms{};

	Parms.NewTouchInterface = NewTouchInterface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.OnlineBlueprintCallProxyBase
// (None)

class UClass* UOnlineBlueprintCallProxyBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OnlineBlueprintCallProxyBase");

	return Clss;
}


// OnlineBlueprintCallProxyBase Engine.Default__OnlineBlueprintCallProxyBase
// (Public, ClassDefaultObject, ArchetypeObject, StrongRefOnFrame)

class UOnlineBlueprintCallProxyBase* UOnlineBlueprintCallProxyBase::GetDefaultObj()
{
	static class UOnlineBlueprintCallProxyBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UOnlineBlueprintCallProxyBase*>(UOnlineBlueprintCallProxyBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.OnlineBlueprintCallProxyBase.Activate
// (Native, Public, BlueprintCallable)
// Parameters:

void UOnlineBlueprintCallProxyBase::Activate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("OnlineBlueprintCallProxyBase", "Activate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.Player
// (None)

class UClass* UPlayer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Player");

	return Clss;
}


// Player Engine.Default__Player
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlayer* UPlayer::GetDefaultObj()
{
	static class UPlayer* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayer*>(UPlayer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NetConnection
// (None)

class UClass* UNetConnection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NetConnection");

	return Clss;
}


// NetConnection Engine.Default__NetConnection
// (Public, ClassDefaultObject, ArchetypeObject)

class UNetConnection* UNetConnection::GetDefaultObj()
{
	static class UNetConnection* Default = nullptr;

	if (!Default)
		Default = static_cast<UNetConnection*>(UNetConnection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NetDriver
// (None)

class UClass* UNetDriver::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NetDriver");

	return Clss;
}


// NetDriver Engine.Default__NetDriver
// (Public, ClassDefaultObject, ArchetypeObject)

class UNetDriver* UNetDriver::GetDefaultObj()
{
	static class UNetDriver* Default = nullptr;

	if (!Default)
		Default = static_cast<UNetDriver*>(UNetDriver::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlueprintAsyncActionBase
// (None)

class UClass* UBlueprintAsyncActionBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueprintAsyncActionBase");

	return Clss;
}


// BlueprintAsyncActionBase Engine.Default__BlueprintAsyncActionBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprintAsyncActionBase* UBlueprintAsyncActionBase::GetDefaultObj()
{
	static class UBlueprintAsyncActionBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprintAsyncActionBase*>(UBlueprintAsyncActionBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.BlueprintAsyncActionBase.Activate
// (Native, Public, BlueprintCallable)
// Parameters:

void UBlueprintAsyncActionBase::Activate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintAsyncActionBase", "Activate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.OnlineEngineInterface
// (None)

class UClass* UOnlineEngineInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OnlineEngineInterface");

	return Clss;
}


// OnlineEngineInterface Engine.Default__OnlineEngineInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class UOnlineEngineInterface* UOnlineEngineInterface::GetDefaultObj()
{
	static class UOnlineEngineInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<UOnlineEngineInterface*>(UOnlineEngineInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DeveloperSettings
// (None)

class UClass* UDeveloperSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DeveloperSettings");

	return Clss;
}


// DeveloperSettings Engine.Default__DeveloperSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UDeveloperSettings* UDeveloperSettings::GetDefaultObj()
{
	static class UDeveloperSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UDeveloperSettings*>(UDeveloperSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.OnlineSession
// (None)

class UClass* UOnlineSession::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OnlineSession");

	return Clss;
}


// OnlineSession Engine.Default__OnlineSession
// (Public, ClassDefaultObject, ArchetypeObject)

class UOnlineSession* UOnlineSession::GetDefaultObj()
{
	static class UOnlineSession* Default = nullptr;

	if (!Default)
		Default = static_cast<UOnlineSession*>(UOnlineSession::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Engine
// (None)

class UClass* UEngine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Engine");

	return Clss;
}


// Engine Engine.Default__Engine
// (Public, ClassDefaultObject, ArchetypeObject)

class UEngine* UEngine::GetDefaultObj()
{
	static class UEngine* Default = nullptr;

	if (!Default)
		Default = static_cast<UEngine*>(UEngine::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LocalPlayer
// (None)

class UClass* ULocalPlayer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LocalPlayer");

	return Clss;
}


// LocalPlayer Engine.Default__LocalPlayer
// (Public, ClassDefaultObject, ArchetypeObject)

class ULocalPlayer* ULocalPlayer::GetDefaultObj()
{
	static class ULocalPlayer* Default = nullptr;

	if (!Default)
		Default = static_cast<ULocalPlayer*>(ULocalPlayer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Subsystem
// (None)

class UClass* USubsystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Subsystem");

	return Clss;
}


// Subsystem Engine.Default__Subsystem
// (Public, ClassDefaultObject, ArchetypeObject)

class USubsystem* USubsystem::GetDefaultObj()
{
	static class USubsystem* Default = nullptr;

	if (!Default)
		Default = static_cast<USubsystem*>(USubsystem::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.GameInstance
// (None)

class UClass* UGameInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameInstance");

	return Clss;
}


// GameInstance Engine.Default__GameInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UGameInstance* UGameInstance::GetDefaultObj()
{
	static class UGameInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UGameInstance*>(UGameInstance::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.GameInstance.ReceiveShutdown
// (Event, Public, BlueprintEvent)
// Parameters:

void UGameInstance::ReceiveShutdown()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameInstance", "ReceiveShutdown");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.GameInstance.ReceiveInit
// (Event, Public, BlueprintEvent)
// Parameters:

void UGameInstance::ReceiveInit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameInstance", "ReceiveInit");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.GameInstance.HandleTravelError
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ETravelFailure          FailureType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstance::HandleTravelError(enum class ETravelFailure FailureType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameInstance", "HandleTravelError");

	Params::UGameInstance_HandleTravelError_Params Parms{};

	Parms.FailureType = FailureType;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.GameInstance.HandleNetworkError
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class ENetworkFailure         FailureType                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsServer                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstance::HandleNetworkError(enum class ENetworkFailure FailureType, bool bIsServer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameInstance", "HandleNetworkError");

	Params::UGameInstance_HandleNetworkError_Params Parms{};

	Parms.FailureType = FailureType;
	Parms.bIsServer = bIsServer;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.GameInstance.DebugRemovePlayer
// (Exec, Native, Public)
// Parameters:
// int32                              ControllerId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstance::DebugRemovePlayer(int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameInstance", "DebugRemovePlayer");

	Params::UGameInstance_DebugRemovePlayer_Params Parms{};

	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameInstance.DebugCreatePlayer
// (Exec, Native, Public)
// Parameters:
// int32                              ControllerId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstance::DebugCreatePlayer(int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameInstance", "DebugCreatePlayer");

	Params::UGameInstance_DebugCreatePlayer_Params Parms{};

	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.GameInstanceSubsystem
// (None)

class UClass* UGameInstanceSubsystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameInstanceSubsystem");

	return Clss;
}


// GameInstanceSubsystem Engine.Default__GameInstanceSubsystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UGameInstanceSubsystem* UGameInstanceSubsystem::GetDefaultObj()
{
	static class UGameInstanceSubsystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UGameInstanceSubsystem*>(UGameInstanceSubsystem::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlueprintGeneratedClass
// (Field, Struct, Class)

class UClass* UBlueprintGeneratedClass::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueprintGeneratedClass");

	return Clss;
}


// BlueprintGeneratedClass Engine.Default__BlueprintGeneratedClass
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprintGeneratedClass* UBlueprintGeneratedClass::GetDefaultObj()
{
	static class UBlueprintGeneratedClass* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprintGeneratedClass*>(UBlueprintGeneratedClass::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.HUD
// (Actor)

class UClass* AHUD::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HUD");

	return Clss;
}


// HUD Engine.Default__HUD
// (Public, ClassDefaultObject, ArchetypeObject)

class AHUD* AHUD::GetDefaultObj()
{
	static class AHUD* Default = nullptr;

	if (!Default)
		Default = static_cast<AHUD*>(AHUD::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.HUD.ShowHUD
// (Exec, Native, Public)
// Parameters:

void AHUD::ShowHUD()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ShowHUD");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.ShowDebugToggleSubCategory
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        Category                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ShowDebugToggleSubCategory(class FName Category)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ShowDebugToggleSubCategory");

	Params::AHUD_ShowDebugToggleSubCategory_Params Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.ShowDebugForReticleTargetToggle
// (Final, Exec, Native, Public)
// Parameters:
// TSubclassOf<class AActor>          DesiredClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ShowDebugForReticleTargetToggle(TSubclassOf<class AActor> DesiredClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ShowDebugForReticleTargetToggle");

	Params::AHUD_ShowDebugForReticleTargetToggle_Params Parms{};

	Parms.DesiredClass = DesiredClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.ShowDebug
// (Exec, Native, Public)
// Parameters:
// class FName                        DebugType                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ShowDebug(class FName DebugType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ShowDebug");

	Params::AHUD_ShowDebug_Params Parms{};

	Parms.DebugType = DebugType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.RemoveDebugText
// (Final, Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                      SrcActor                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLeaveDurationText                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::RemoveDebugText(class AActor* SrcActor, bool bLeaveDurationText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "RemoveDebugText");

	Params::AHUD_RemoveDebugText_Params Parms{};

	Parms.SrcActor = SrcActor;
	Parms.bLeaveDurationText = bLeaveDurationText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.RemoveAllDebugStrings
// (Final, Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void AHUD::RemoveAllDebugStrings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "RemoveAllDebugStrings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.ReceiveHitBoxRelease
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class FName                        BoxName                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveHitBoxRelease(class FName BoxName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ReceiveHitBoxRelease");

	Params::AHUD_ReceiveHitBoxRelease_Params Parms{};

	Parms.BoxName = BoxName;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.HUD.ReceiveHitBoxEndCursorOver
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class FName                        BoxName                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveHitBoxEndCursorOver(class FName BoxName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ReceiveHitBoxEndCursorOver");

	Params::AHUD_ReceiveHitBoxEndCursorOver_Params Parms{};

	Parms.BoxName = BoxName;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.HUD.ReceiveHitBoxClick
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class FName                        BoxName                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveHitBoxClick(class FName BoxName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ReceiveHitBoxClick");

	Params::AHUD_ReceiveHitBoxClick_Params Parms{};

	Parms.BoxName = BoxName;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.HUD.ReceiveHitBoxBeginCursorOver
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class FName                        BoxName                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveHitBoxBeginCursorOver(class FName BoxName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ReceiveHitBoxBeginCursorOver");

	Params::AHUD_ReceiveHitBoxBeginCursorOver_Params Parms{};

	Parms.BoxName = BoxName;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.HUD.ReceiveDrawHUD
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// int32                              SizeX                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SizeY                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveDrawHUD(int32 SizeX, int32 SizeY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "ReceiveDrawHUD");

	Params::AHUD_ReceiveDrawHUD_Params Parms{};

	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.HUD.Project
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AHUD::Project(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "Project");

	Params::AHUD_Project_Params Parms{};

	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.HUD.PreviousDebugTarget
// (Exec, Native, Public)
// Parameters:

void AHUD::PreviousDebugTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "PreviousDebugTarget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.NextDebugTarget
// (Exec, Native, Public)
// Parameters:

void AHUD::NextDebugTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "NextDebugTarget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.GetTextSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      Text                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutWidth                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutHeight                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFont*                       Font                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::GetTextSize(const class FString& Text, float* OutWidth, float* OutHeight, class UFont* Font, float Scale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "GetTextSize");

	Params::AHUD_GetTextSize_Params Parms{};

	Parms.Text = Text;
	Parms.Font = Font;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutWidth != nullptr)
		*OutWidth = Parms.OutWidth;

	if (OutHeight != nullptr)
		*OutHeight = Parms.OutHeight;

}


// Function Engine.HUD.GetOwningPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* AHUD::GetOwningPlayerController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "GetOwningPlayerController");

	Params::AHUD_GetOwningPlayerController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.HUD.GetOwningPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AHUD::GetOwningPawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "GetOwningPawn");

	Params::AHUD_GetOwningPawn_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.HUD.GetActorsInSelectionRectangle
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>          ClassFilter                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   FirstPoint                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   SecondPoint                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               bIncludeNonCollidingComponents                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bActorMustBeFullyEnclosed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::GetActorsInSelectionRectangle(TSubclassOf<class AActor> ClassFilter, struct FVector2D& FirstPoint, struct FVector2D& SecondPoint, TArray<class AActor*>* OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "GetActorsInSelectionRectangle");

	Params::AHUD_GetActorsInSelectionRectangle_Params Parms{};

	Parms.ClassFilter = ClassFilter;
	Parms.FirstPoint = FirstPoint;
	Parms.SecondPoint = SecondPoint;
	Parms.bIncludeNonCollidingComponents = bIncludeNonCollidingComponents;
	Parms.bActorMustBeFullyEnclosed = bActorMustBeFullyEnclosed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

}


// Function Engine.HUD.DrawTextureSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                    Texture                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenX                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenY                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bScalePosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawTextureSimple(class UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "DrawTextureSimple");

	Params::AHUD_DrawTextureSimple_Params Parms{};

	Parms.Texture = Texture;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.DrawTexture
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                    Texture                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenX                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenY                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenW                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenH                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TextureU                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TextureV                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TextureUWidth                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TextureVHeight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TintColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBlendMode              BlendMode                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bScalePosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   RotPivot                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawTexture(class UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, const struct FLinearColor& TintColor, enum class EBlendMode BlendMode, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "DrawTexture");

	Params::AHUD_DrawTexture_Params Parms{};

	Parms.Texture = Texture;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;
	Parms.TextureU = TextureU;
	Parms.TextureV = TextureV;
	Parms.TextureUWidth = TextureUWidth;
	Parms.TextureVHeight = TextureVHeight;
	Parms.TintColor = TintColor;
	Parms.BlendMode = BlendMode;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;
	Parms.Rotation = Rotation;
	Parms.RotPivot = RotPivot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.DrawText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                      Text                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TextColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenX                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenY                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFont*                       Font                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bScalePosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawText(const class FString& Text, const struct FLinearColor& TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "DrawText");

	Params::AHUD_DrawText_Params Parms{};

	Parms.Text = Text;
	Parms.TextColor = TextColor;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.Font = Font;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.DrawRect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                RectColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenX                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenY                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenW                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenH                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawRect(const struct FLinearColor& RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "DrawRect");

	Params::AHUD_DrawRect_Params Parms{};

	Parms.RectColor = RectColor;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.DrawMaterialTriangle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   V0_Pos                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   V1_Pos                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   V2_Pos                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   V0_UV                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   V1_UV                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   V2_UV                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                V0_Color                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                V1_Color                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                V2_Color                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawMaterialTriangle(class UMaterialInterface* Material, const struct FVector2D& V0_Pos, const struct FVector2D& V1_Pos, const struct FVector2D& V2_Pos, const struct FVector2D& V0_UV, const struct FVector2D& V1_UV, const struct FVector2D& V2_UV, const struct FLinearColor& V0_Color, const struct FLinearColor& V1_Color, const struct FLinearColor& V2_Color)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "DrawMaterialTriangle");

	Params::AHUD_DrawMaterialTriangle_Params Parms{};

	Parms.Material = Material;
	Parms.V0_Pos = V0_Pos;
	Parms.V1_Pos = V1_Pos;
	Parms.V2_Pos = V2_Pos;
	Parms.V0_UV = V0_UV;
	Parms.V1_UV = V1_UV;
	Parms.V2_UV = V2_UV;
	Parms.V0_Color = V0_Color;
	Parms.V1_Color = V1_Color;
	Parms.V2_Color = V2_Color;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.DrawMaterialSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenX                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenY                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenW                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenH                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bScalePosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawMaterialSimple(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "DrawMaterialSimple");

	Params::AHUD_DrawMaterialSimple_Params Parms{};

	Parms.Material = Material;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.DrawMaterial
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenX                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenY                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenW                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenH                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaterialU                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaterialV                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaterialUWidth                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaterialVHeight                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bScalePosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   RotPivot                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawMaterial(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "DrawMaterial");

	Params::AHUD_DrawMaterial_Params Parms{};

	Parms.Material = Material;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;
	Parms.MaterialU = MaterialU;
	Parms.MaterialV = MaterialV;
	Parms.MaterialUWidth = MaterialUWidth;
	Parms.MaterialVHeight = MaterialVHeight;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;
	Parms.Rotation = Rotation;
	Parms.RotPivot = RotPivot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.DrawLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                              StartScreenX                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartScreenY                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              EndScreenX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              EndScreenY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LineThickness                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, const struct FLinearColor& LineColor, float LineThickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "DrawLine");

	Params::AHUD_DrawLine_Params Parms{};

	Parms.StartScreenX = StartScreenX;
	Parms.StartScreenY = StartScreenY;
	Parms.EndScreenX = EndScreenX;
	Parms.EndScreenY = EndScreenY;
	Parms.LineColor = LineColor;
	Parms.LineThickness = LineThickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.Deproject
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ScreenX                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScreenY                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldPosition                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldDirection                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::Deproject(float ScreenX, float ScreenY, struct FVector* WorldPosition, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "Deproject");

	Params::AHUD_Deproject_Params Parms{};

	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (WorldPosition != nullptr)
		*WorldPosition = std::move(Parms.WorldPosition);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

}


// Function Engine.HUD.AddHitBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   Position                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Size                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bConsumesInput                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Priority                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::AddHitBox(const struct FVector2D& Position, const struct FVector2D& Size, class FName InName, bool bConsumesInput, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "AddHitBox");

	Params::AHUD_AddHitBox_Params Parms{};

	Parms.Position = Position;
	Parms.Size = Size;
	Parms.InName = InName;
	Parms.bConsumesInput = bConsumesInput;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HUD.AddDebugText
// (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class FString                      DebugText                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      SrcActor                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Offset                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     DesiredOffset                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      TextColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSkipOverwriteCheck                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAbsoluteLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bKeepAttachedToActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFont*                       InFont                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FontScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDrawShadow                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::AddDebugText(const class FString& DebugText, class AActor* SrcActor, float Duration, const struct FVector& Offset, const struct FVector& DesiredOffset, const struct FColor& TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont, float FontScale, bool bDrawShadow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HUD", "AddDebugText");

	Params::AHUD_AddDebugText_Params Parms{};

	Parms.DebugText = DebugText;
	Parms.SrcActor = SrcActor;
	Parms.Duration = Duration;
	Parms.Offset = Offset;
	Parms.DesiredOffset = DesiredOffset;
	Parms.TextColor = TextColor;
	Parms.bSkipOverwriteCheck = bSkipOverwriteCheck;
	Parms.bAbsoluteLocation = bAbsoluteLocation;
	Parms.bKeepAttachedToActor = bKeepAttachedToActor;
	Parms.InFont = InFont;
	Parms.FontScale = FontScale;
	Parms.bDrawShadow = bDrawShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.DefaultPawn
// (Actor, Pawn)

class UClass* ADefaultPawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DefaultPawn");

	return Clss;
}


// DefaultPawn Engine.Default__DefaultPawn
// (Public, ClassDefaultObject, ArchetypeObject)

class ADefaultPawn* ADefaultPawn::GetDefaultObj()
{
	static class ADefaultPawn* Default = nullptr;

	if (!Default)
		Default = static_cast<ADefaultPawn*>(ADefaultPawn::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.DefaultPawn.TurnAtRate
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Rate                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::TurnAtRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DefaultPawn", "TurnAtRate");

	Params::ADefaultPawn_TurnAtRate_Params Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DefaultPawn.MoveUp_World
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::MoveUp_World(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DefaultPawn", "MoveUp_World");

	Params::ADefaultPawn_MoveUp_World_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DefaultPawn.MoveRight
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::MoveRight(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DefaultPawn", "MoveRight");

	Params::ADefaultPawn_MoveRight_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DefaultPawn.MoveForward
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Val                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::MoveForward(float Val)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DefaultPawn", "MoveForward");

	Params::ADefaultPawn_MoveForward_Params Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DefaultPawn.LookUpAtRate
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              Rate                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::LookUpAtRate(float Rate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DefaultPawn", "LookUpAtRate");

	Params::ADefaultPawn_LookUpAtRate_Params Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.BlueprintCore
// (None)

class UClass* UBlueprintCore::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueprintCore");

	return Clss;
}


// BlueprintCore Engine.Default__BlueprintCore
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprintCore* UBlueprintCore::GetDefaultObj()
{
	static class UBlueprintCore* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprintCore*>(UBlueprintCore::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Blueprint
// (Blueprint)

class UClass* UBlueprint::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Blueprint");

	return Clss;
}


// Blueprint Engine.Default__Blueprint
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprint* UBlueprint::GetDefaultObj()
{
	static class UBlueprint* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprint*>(UBlueprint::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Channel
// (None)

class UClass* UChannel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Channel");

	return Clss;
}


// Channel Engine.Default__Channel
// (Public, ClassDefaultObject, ArchetypeObject)

class UChannel* UChannel::GetDefaultObj()
{
	static class UChannel* Default = nullptr;

	if (!Default)
		Default = static_cast<UChannel*>(UChannel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VoiceChannel
// (None)

class UClass* UVoiceChannel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VoiceChannel");

	return Clss;
}


// VoiceChannel Engine.Default__VoiceChannel
// (Public, ClassDefaultObject, ArchetypeObject)

class UVoiceChannel* UVoiceChannel::GetDefaultObj()
{
	static class UVoiceChannel* Default = nullptr;

	if (!Default)
		Default = static_cast<UVoiceChannel*>(UVoiceChannel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ReplicationDriver
// (None)

class UClass* UReplicationDriver::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReplicationDriver");

	return Clss;
}


// ReplicationDriver Engine.Default__ReplicationDriver
// (Public, ClassDefaultObject, ArchetypeObject)

class UReplicationDriver* UReplicationDriver::GetDefaultObj()
{
	static class UReplicationDriver* Default = nullptr;

	if (!Default)
		Default = static_cast<UReplicationDriver*>(UReplicationDriver::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ReplicationConnectionDriver
// (None)

class UClass* UReplicationConnectionDriver::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReplicationConnectionDriver");

	return Clss;
}


// ReplicationConnectionDriver Engine.Default__ReplicationConnectionDriver
// (Public, ClassDefaultObject, ArchetypeObject)

class UReplicationConnectionDriver* UReplicationConnectionDriver::GetDefaultObj()
{
	static class UReplicationConnectionDriver* Default = nullptr;

	if (!Default)
		Default = static_cast<UReplicationConnectionDriver*>(UReplicationConnectionDriver::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.FXSystemComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UFXSystemComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FXSystemComponent");

	return Clss;
}


// FXSystemComponent Engine.Default__FXSystemComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UFXSystemComponent* UFXSystemComponent::GetDefaultObj()
{
	static class UFXSystemComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UFXSystemComponent*>(UFXSystemComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.FXSystemComponent.SetVectorParameter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetVectorParameter(class FName ParameterName, const struct FVector& Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FXSystemComponent", "SetVectorParameter");

	Params::UFXSystemComponent_SetVectorParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.FXSystemComponent.SetFloatParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetFloatParameter(class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FXSystemComponent", "SetFloatParameter");

	Params::UFXSystemComponent_SetFloatParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.FXSystemComponent.SetEmitterEnable
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EmitterName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bNewEnableState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetEmitterEnable(class FName EmitterName, bool bNewEnableState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FXSystemComponent", "SetEmitterEnable");

	Params::UFXSystemComponent_SetEmitterEnable_Params Parms{};

	Parms.EmitterName = EmitterName;
	Parms.bNewEnableState = bNewEnableState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.FXSystemComponent.SetColorParameter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetColorParameter(class FName ParameterName, const struct FLinearColor& Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FXSystemComponent", "SetColorParameter");

	Params::UFXSystemComponent_SetColorParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.FXSystemComponent.SetAutoAttachmentParameters
// (Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             Parent                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SocketName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         LocationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         RotationRule                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachmentRule         ScaleRule                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetAutoAttachmentParameters(class USceneComponent* Parent, class FName SocketName, enum class EAttachmentRule LocationRule, enum class EAttachmentRule RotationRule, enum class EAttachmentRule ScaleRule)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FXSystemComponent", "SetAutoAttachmentParameters");

	Params::UFXSystemComponent_SetAutoAttachmentParameters_Params Parms{};

	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.FXSystemComponent.SetActorParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetActorParameter(class FName ParameterName, class AActor* Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("FXSystemComponent", "SetActorParameter");

	Params::UFXSystemComponent_SetActorParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.FXSystemAsset
// (None)

class UClass* UFXSystemAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FXSystemAsset");

	return Clss;
}


// FXSystemAsset Engine.Default__FXSystemAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UFXSystemAsset* UFXSystemAsset::GetDefaultObj()
{
	static class UFXSystemAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UFXSystemAsset*>(UFXSystemAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotify
// (None)

class UClass* UAnimNotify::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotify");

	return Clss;
}


// AnimNotify Engine.Default__AnimNotify
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotify* UAnimNotify::GetDefaultObj()
{
	static class UAnimNotify* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotify*>(UAnimNotify::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AnimNotify.Received_Notify
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*      MeshComp                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*           Animation                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotify::Received_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimNotify", "Received_Notify");

	Params::UAnimNotify_Received_Notify_Params Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function Engine.AnimNotify.GetNotifyName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAnimNotify::GetNotifyName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimNotify", "GetNotifyName");

	Params::UAnimNotify_GetNotifyName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AnimNotifyState
// (None)

class UClass* UAnimNotifyState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotifyState");

	return Clss;
}


// AnimNotifyState Engine.Default__AnimNotifyState
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotifyState* UAnimNotifyState::GetDefaultObj()
{
	static class UAnimNotifyState* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotifyState*>(UAnimNotifyState::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AnimNotifyState.Received_NotifyTick
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*      MeshComp                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*           Animation                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FrameDeltaTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyState::Received_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimNotifyState", "Received_NotifyTick");

	Params::UAnimNotifyState_Received_NotifyTick_Params Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.FrameDeltaTime = FrameDeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function Engine.AnimNotifyState.Received_NotifyEnd
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*      MeshComp                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*           Animation                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyState::Received_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimNotifyState", "Received_NotifyEnd");

	Params::UAnimNotifyState_Received_NotifyEnd_Params Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function Engine.AnimNotifyState.Received_NotifyBegin
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*      MeshComp                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*           Animation                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TotalDuration                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyState::Received_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimNotifyState", "Received_NotifyBegin");

	Params::UAnimNotifyState_Received_NotifyBegin_Params Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.TotalDuration = TotalDuration;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function Engine.AnimNotifyState.GetNotifyName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAnimNotifyState::GetNotifyName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimNotifyState", "GetNotifyName");

	Params::UAnimNotifyState_GetNotifyName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.PrimaryDataAsset
// (None)

class UClass* UPrimaryDataAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PrimaryDataAsset");

	return Clss;
}


// PrimaryDataAsset Engine.Default__PrimaryDataAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UPrimaryDataAsset* UPrimaryDataAsset::GetDefaultObj()
{
	static class UPrimaryDataAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UPrimaryDataAsset*>(UPrimaryDataAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Commandlet
// (None)

class UClass* UCommandlet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Commandlet");

	return Clss;
}


// Commandlet Engine.Default__Commandlet
// (Public, ClassDefaultObject, ArchetypeObject)

class UCommandlet* UCommandlet::GetDefaultObj()
{
	static class UCommandlet* Default = nullptr;

	if (!Default)
		Default = static_cast<UCommandlet*>(UCommandlet::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpression
// (None)

class UClass* UMaterialExpression::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpression");

	return Clss;
}


// MaterialExpression Engine.Default__MaterialExpression
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpression* UMaterialExpression::GetDefaultObj()
{
	static class UMaterialExpression* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpression*>(UMaterialExpression::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureBase
// (None)

class UClass* UMaterialExpressionTextureBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureBase");

	return Clss;
}


// MaterialExpressionTextureBase Engine.Default__MaterialExpressionTextureBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureBase* UMaterialExpressionTextureBase::GetDefaultObj()
{
	static class UMaterialExpressionTextureBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureBase*>(UMaterialExpressionTextureBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureSample
// (None)

class UClass* UMaterialExpressionTextureSample::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureSample");

	return Clss;
}


// MaterialExpressionTextureSample Engine.Default__MaterialExpressionTextureSample
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureSample* UMaterialExpressionTextureSample::GetDefaultObj()
{
	static class UMaterialExpressionTextureSample* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureSample*>(UMaterialExpressionTextureSample::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureSampleParameter
// (None)

class UClass* UMaterialExpressionTextureSampleParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureSampleParameter");

	return Clss;
}


// MaterialExpressionTextureSampleParameter Engine.Default__MaterialExpressionTextureSampleParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureSampleParameter* UMaterialExpressionTextureSampleParameter::GetDefaultObj()
{
	static class UMaterialExpressionTextureSampleParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureSampleParameter*>(UMaterialExpressionTextureSampleParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureSampleParameter2D
// (None)

class UClass* UMaterialExpressionTextureSampleParameter2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureSampleParameter2D");

	return Clss;
}


// MaterialExpressionTextureSampleParameter2D Engine.Default__MaterialExpressionTextureSampleParameter2D
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureSampleParameter2D* UMaterialExpressionTextureSampleParameter2D::GetDefaultObj()
{
	static class UMaterialExpressionTextureSampleParameter2D* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureSampleParameter2D*>(UMaterialExpressionTextureSampleParameter2D::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Character
// (Actor, Pawn)

class UClass* ACharacter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Character");

	return Clss;
}


// Character Engine.Default__Character
// (Public, ClassDefaultObject, ArchetypeObject)

class ACharacter* ACharacter::GetDefaultObj()
{
	static class ACharacter* Default = nullptr;

	if (!Default)
		Default = static_cast<ACharacter*>(ACharacter::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Character.UnCrouch
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bClientSimulation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::UnCrouch(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "UnCrouch");

	Params::ACharacter_UnCrouch_Params Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.StopJumping
// (Native, Public, BlueprintCallable)
// Parameters:

void ACharacter::StopJumping()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "StopJumping");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.StopAnimMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                AnimMontage                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::StopAnimMontage(class UAnimMontage* AnimMontage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "StopAnimMontage");

	Params::ACharacter_StopAnimMontage_Params Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ServerMoveOld
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                              OldTimeStamp                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       OldAccel                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              OldMoveFlags                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, uint8 OldMoveFlags)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ServerMoveOld");

	Params::ACharacter_ServerMoveOld_Params Parms{};

	Parms.OldTimeStamp = OldTimeStamp;
	Parms.OldAccel = OldAccel;
	Parms.OldMoveFlags = OldMoveFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ServerMoveNoBase
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       InAccel                                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100      ClientLoc                                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              CompressedMoveFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientRoll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                             View                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveNoBase(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ServerMoveNoBase");

	Params::ACharacter_ServerMoveNoBase_Params Parms{};

	Parms.Timestamp = Timestamp;
	Parms.InAccel = InAccel;
	Parms.ClientLoc = ClientLoc;
	Parms.CompressedMoveFlags = CompressedMoveFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementMode = ClientMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ServerMoveDualNoBase
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                              TimeStamp0                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       InAccel0                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              PendingFlags                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                             View0                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       InAccel                                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100      ClientLoc                                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              NewFlags                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientRoll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                             View                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveDualNoBase(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ServerMoveDualNoBase");

	Params::ACharacter_ServerMoveDualNoBase_Params Parms{};

	Parms.TimeStamp0 = TimeStamp0;
	Parms.InAccel0 = InAccel0;
	Parms.PendingFlags = PendingFlags;
	Parms.View0 = View0;
	Parms.Timestamp = Timestamp;
	Parms.InAccel = InAccel;
	Parms.ClientLoc = ClientLoc;
	Parms.NewFlags = NewFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementMode = ClientMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ServerMoveDualHybridRootMotion
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                              TimeStamp0                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       InAccel0                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              PendingFlags                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                             View0                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       InAccel                                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100      ClientLoc                                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              NewFlags                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientRoll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                             View                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         ClientMovementBase                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ClientBaseBoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveDualHybridRootMotion(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ServerMoveDualHybridRootMotion");

	Params::ACharacter_ServerMoveDualHybridRootMotion_Params Parms{};

	Parms.TimeStamp0 = TimeStamp0;
	Parms.InAccel0 = InAccel0;
	Parms.PendingFlags = PendingFlags;
	Parms.View0 = View0;
	Parms.Timestamp = Timestamp;
	Parms.InAccel = InAccel;
	Parms.ClientLoc = ClientLoc;
	Parms.NewFlags = NewFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ServerMoveDual
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                              TimeStamp0                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       InAccel0                                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              PendingFlags                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                             View0                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       InAccel                                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100      ClientLoc                                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              NewFlags                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientRoll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                             View                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         ClientMovementBase                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ClientBaseBoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ServerMoveDual");

	Params::ACharacter_ServerMoveDual_Params Parms{};

	Parms.TimeStamp0 = TimeStamp0;
	Parms.InAccel0 = InAccel0;
	Parms.PendingFlags = PendingFlags;
	Parms.View0 = View0;
	Parms.Timestamp = Timestamp;
	Parms.InAccel = InAccel;
	Parms.ClientLoc = ClientLoc;
	Parms.NewFlags = NewFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ServerMove
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10       InAccel                                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100      ClientLoc                                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                              CompressedMoveFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientRoll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                             View                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         ClientMovementBase                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ClientBaseBoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ClientMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMove(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ServerMove");

	Params::ACharacter_ServerMove_Params Parms{};

	Parms.Timestamp = Timestamp;
	Parms.InAccel = InAccel;
	Parms.ClientLoc = ClientLoc;
	Parms.CompressedMoveFlags = CompressedMoveFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.RootMotionDebugClientPrintOnScreen
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::RootMotionDebugClientPrintOnScreen(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "RootMotionDebugClientPrintOnScreen");

	Params::ACharacter_RootMotionDebugClientPrintOnScreen_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.PlayAnimMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                AnimMontage                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPlayRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        StartSectionName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacter::PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, class FName StartSectionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "PlayAnimMontage");

	Params::ACharacter_PlayAnimMontage_Params Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.InPlayRate = InPlayRate;
	Parms.StartSectionName = StartSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.OnWalkingOffLedge
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     PreviousFloorImpactNormal                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PreviousFloorContactNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PreviousLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TimeDelta                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::OnWalkingOffLedge(struct FVector& PreviousFloorImpactNormal, struct FVector& PreviousFloorContactNormal, struct FVector& PreviousLocation, float TimeDelta)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "OnWalkingOffLedge");

	Params::ACharacter_OnWalkingOffLedge_Params Parms{};

	Parms.PreviousFloorImpactNormal = PreviousFloorImpactNormal;
	Parms.PreviousFloorContactNormal = PreviousFloorContactNormal;
	Parms.PreviousLocation = PreviousLocation;
	Parms.TimeDelta = TimeDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.OnRep_RootMotion
// (Final, Native, Public)
// Parameters:

void ACharacter::OnRep_RootMotion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "OnRep_RootMotion");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.OnRep_ReplicatedBasedMovement
// (Native, Public)
// Parameters:

void ACharacter::OnRep_ReplicatedBasedMovement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "OnRep_ReplicatedBasedMovement");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.OnRep_ReplayLastTransformUpdateTimeStamp
// (Final, Native, Public)
// Parameters:

void ACharacter::OnRep_ReplayLastTransformUpdateTimeStamp()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "OnRep_ReplayLastTransformUpdateTimeStamp");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.OnRep_IsCrouched
// (Native, Public)
// Parameters:

void ACharacter::OnRep_IsCrouched()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "OnRep_IsCrouched");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.OnLaunched
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     LaunchVelocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bXYOverride                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bZOverride                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::OnLaunched(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "OnLaunched");

	Params::ACharacter_OnLaunched_Params Parms{};

	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bXYOverride = bXYOverride;
	Parms.bZOverride = bZOverride;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Character.OnLanded
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACharacter::OnLanded(struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "OnLanded");

	Params::ACharacter_OnLanded_Params Parms{};

	Parms.Hit = Hit;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Character.OnJumped
// (Native, Event, Public, BlueprintEvent)
// Parameters:

void ACharacter::OnJumped()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "OnJumped");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.LaunchCharacter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     LaunchVelocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bXYOverride                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bZOverride                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "LaunchCharacter");

	Params::ACharacter_LaunchCharacter_Params Parms{};

	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bXYOverride = bXYOverride;
	Parms.bZOverride = bZOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.K2_UpdateCustomMovement
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::K2_UpdateCustomMovement(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "K2_UpdateCustomMovement");

	Params::ACharacter_K2_UpdateCustomMovement_Params Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Character.K2_OnStartCrouch
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              HalfHeightAdjust                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScaledHalfHeightAdjust                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "K2_OnStartCrouch");

	Params::ACharacter_K2_OnStartCrouch_Params Parms{};

	Parms.HalfHeightAdjust = HalfHeightAdjust;
	Parms.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Character.K2_OnMovementModeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// enum class EMovementMode           PrevMovementMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMovementMode           NewMovementMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              PrevCustomMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              NewCustomMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::K2_OnMovementModeChanged(enum class EMovementMode PrevMovementMode, enum class EMovementMode NewMovementMode, uint8 PrevCustomMode, uint8 NewCustomMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "K2_OnMovementModeChanged");

	Params::ACharacter_K2_OnMovementModeChanged_Params Parms{};

	Parms.PrevMovementMode = PrevMovementMode;
	Parms.NewMovementMode = NewMovementMode;
	Parms.PrevCustomMode = PrevCustomMode;
	Parms.NewCustomMode = NewCustomMode;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Character.K2_OnEndCrouch
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              HalfHeightAdjust                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ScaledHalfHeightAdjust                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "K2_OnEndCrouch");

	Params::ACharacter_K2_OnEndCrouch_Params Parms{};

	Parms.HalfHeightAdjust = HalfHeightAdjust;
	Parms.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.Character.Jump
// (Native, Public, BlueprintCallable)
// Parameters:

void ACharacter::Jump()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "Jump");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.IsPlayingRootMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::IsPlayingRootMotion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "IsPlayingRootMotion");

	Params::ACharacter_IsPlayingRootMotion_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.IsPlayingNetworkedRootMotionMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::IsPlayingNetworkedRootMotionMontage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "IsPlayingNetworkedRootMotionMontage");

	Params::ACharacter_IsPlayingNetworkedRootMotionMontage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.IsJumpProvidingForce
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::IsJumpProvidingForce()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "IsJumpProvidingForce");

	Params::ACharacter_IsJumpProvidingForce_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.HasAnyRootMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::HasAnyRootMotion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "HasAnyRootMotion");

	Params::ACharacter_HasAnyRootMotion_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.GetCurrentMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ACharacter::GetCurrentMontage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "GetCurrentMontage");

	Params::ACharacter_GetCurrentMontage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.GetBaseTranslationOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACharacter::GetBaseTranslationOffset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "GetBaseTranslationOffset");

	Params::ACharacter_GetBaseTranslationOffset_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.GetBaseRotationOffsetRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ACharacter::GetBaseRotationOffsetRotator()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "GetBaseRotationOffsetRotator");

	Params::ACharacter_GetBaseRotationOffsetRotator_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.GetAnimRootMotionTranslationScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacter::GetAnimRootMotionTranslationScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "GetAnimRootMotionTranslationScale");

	Params::ACharacter_GetAnimRootMotionTranslationScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.Crouch
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bClientSimulation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::Crouch(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "Crouch");

	Params::ACharacter_Crouch_Params Parms{};

	Parms.bClientSimulation = bClientSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ClientVeryShortAdjustPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewLoc                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         NewBase                                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NewBaseBoneName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bHasBase                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bBaseRelativePosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ServerMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientVeryShortAdjustPosition(float Timestamp, const struct FVector& NewLoc, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ClientVeryShortAdjustPosition");

	Params::ACharacter_ClientVeryShortAdjustPosition_Params Parms{};

	Parms.Timestamp = Timestamp;
	Parms.NewLoc = NewLoc;
	Parms.NewBase = NewBase;
	Parms.NewBaseBoneName = NewBaseBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ClientCheatWalk
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void ACharacter::ClientCheatWalk()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ClientCheatWalk");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ClientCheatGhost
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void ACharacter::ClientCheatGhost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ClientCheatGhost");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ClientCheatFly
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:

void ACharacter::ClientCheatFly()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ClientCheatFly");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ClientAdjustRootMotionSourcePosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRootMotionSourceGroup      ServerRootMotion                                                 (Parm, NativeAccessSpecifierPublic)
// bool                               bHasAnimRootMotion                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ServerMontageTrackPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ServerLoc                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal   ServerRotation                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                              ServerVelZ                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         ServerBase                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ServerBoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bHasBase                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bBaseRelativePosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ServerMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientAdjustRootMotionSourcePosition(float Timestamp, const struct FRootMotionSourceGroup& ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ClientAdjustRootMotionSourcePosition");

	Params::ACharacter_ClientAdjustRootMotionSourcePosition_Params Parms{};

	Parms.Timestamp = Timestamp;
	Parms.ServerRootMotion = ServerRootMotion;
	Parms.bHasAnimRootMotion = bHasAnimRootMotion;
	Parms.ServerMontageTrackPosition = ServerMontageTrackPosition;
	Parms.ServerLoc = ServerLoc;
	Parms.ServerRotation = ServerRotation;
	Parms.ServerVelZ = ServerVelZ;
	Parms.ServerBase = ServerBase;
	Parms.ServerBoneName = ServerBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ClientAdjustRootMotionPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ServerMontageTrackPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ServerLoc                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal   ServerRotation                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                              ServerVelZ                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         ServerBase                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ServerBoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bHasBase                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bBaseRelativePosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ServerMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientAdjustRootMotionPosition(float Timestamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ClientAdjustRootMotionPosition");

	Params::ACharacter_ClientAdjustRootMotionPosition_Params Parms{};

	Parms.Timestamp = Timestamp;
	Parms.ServerMontageTrackPosition = ServerMontageTrackPosition;
	Parms.ServerLoc = ServerLoc;
	Parms.ServerRotation = ServerRotation;
	Parms.ServerVelZ = ServerVelZ;
	Parms.ServerBase = ServerBase;
	Parms.ServerBoneName = ServerBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ClientAdjustPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewLoc                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewVel                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         NewBase                                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        NewBaseBoneName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bHasBase                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bBaseRelativePosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ServerMovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientAdjustPosition(float Timestamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ClientAdjustPosition");

	Params::ACharacter_ClientAdjustPosition_Params Parms{};

	Parms.Timestamp = Timestamp;
	Parms.NewLoc = NewLoc;
	Parms.NewVel = NewVel;
	Parms.NewBase = NewBase;
	Parms.NewBaseBoneName = NewBaseBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.ClientAckGoodMove
// (Net, Native, Event, Public, NetClient)
// Parameters:
// float                              Timestamp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientAckGoodMove(float Timestamp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "ClientAckGoodMove");

	Params::ACharacter_ClientAckGoodMove_Params Parms{};

	Parms.Timestamp = Timestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Character.CanJumpInternal
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::CanJumpInternal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "CanJumpInternal");

	Params::ACharacter_CanJumpInternal_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.CanJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::CanJump()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "CanJump");

	Params::ACharacter_CanJump_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Character.CacheInitialMeshOffset
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     MeshRelativeLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    MeshRelativeRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACharacter::CacheInitialMeshOffset(const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Character", "CacheInitialMeshOffset");

	Params::ACharacter_CacheInitialMeshOffset_Params Parms{};

	Parms.MeshRelativeLocation = MeshRelativeLocation;
	Parms.MeshRelativeRotation = MeshRelativeRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SplineComponent
// (SceneComponent, PrimitiveComponent)

class UClass* USplineComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SplineComponent");

	return Clss;
}


// SplineComponent Engine.Default__SplineComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USplineComponent* USplineComponent::GetDefaultObj()
{
	static class USplineComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USplineComponent*>(USplineComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SplineComponent.UpdateSpline
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USplineComponent::UpdateSpline()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "UpdateSpline");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetWorldLocationAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InLocation                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetWorldLocationAtSplinePoint(int32 PointIndex, struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetWorldLocationAtSplinePoint");

	Params::USplineComponent_SetWorldLocationAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InLocation = InLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetUpVectorAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InUpVector                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetUpVectorAtSplinePoint(int32 PointIndex, struct FVector& InUpVector, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetUpVectorAtSplinePoint");

	Params::USplineComponent_SetUpVectorAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InUpVector = InUpVector;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetUnselectedSplineSegmentColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                SegmentColor                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetUnselectedSplineSegmentColor(struct FLinearColor& SegmentColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetUnselectedSplineSegmentColor");

	Params::USplineComponent_SetUnselectedSplineSegmentColor_Params Parms{};

	Parms.SegmentColor = SegmentColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetTangentsAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InArriveTangent                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InLeaveTangent                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetTangentsAtSplinePoint(int32 PointIndex, struct FVector& InArriveTangent, struct FVector& InLeaveTangent, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetTangentsAtSplinePoint");

	Params::USplineComponent_SetTangentsAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InArriveTangent = InArriveTangent;
	Parms.InLeaveTangent = InLeaveTangent;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetTangentAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InTangent                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetTangentAtSplinePoint(int32 PointIndex, struct FVector& InTangent, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetTangentAtSplinePoint");

	Params::USplineComponent_SetTangentAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InTangent = InTangent;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetSplineWorldPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>             Points                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USplineComponent::SetSplineWorldPoints(TArray<struct FVector>& Points)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetSplineWorldPoints");

	Params::USplineComponent_SetSplineWorldPoints_Params Parms{};

	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetSplinePointType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplinePointType        Type                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetSplinePointType(int32 PointIndex, enum class ESplinePointType Type, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetSplinePointType");

	Params::USplineComponent_SetSplinePointType_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.Type = Type;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetSplinePoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>             Points                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetSplinePoints(TArray<struct FVector>& Points, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetSplinePoints");

	Params::USplineComponent_SetSplinePoints_Params Parms{};

	Parms.Points = Points;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetSplineLocalPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>             Points                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USplineComponent::SetSplineLocalPoints(TArray<struct FVector>& Points)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetSplineLocalPoints");

	Params::USplineComponent_SetSplineLocalPoints_Params Parms{};

	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetSelectedSplineSegmentColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                SegmentColor                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetSelectedSplineSegmentColor(struct FLinearColor& SegmentColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetSelectedSplineSegmentColor");

	Params::USplineComponent_SetSelectedSplineSegmentColor_Params Parms{};

	Parms.SegmentColor = SegmentColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetLocationAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InLocation                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetLocationAtSplinePoint(int32 PointIndex, struct FVector& InLocation, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetLocationAtSplinePoint");

	Params::USplineComponent_SetLocationAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InLocation = InLocation;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetDrawDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bShow                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetDrawDebug(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetDrawDebug");

	Params::USplineComponent_SetDrawDebug_Params Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetDefaultUpVector
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     UpVector                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetDefaultUpVector(struct FVector& UpVector, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetDefaultUpVector");

	Params::USplineComponent_SetDefaultUpVector_Params Parms{};

	Parms.UpVector = UpVector;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetClosedLoopAtPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInClosedLoop                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Key                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetClosedLoopAtPosition");

	Params::USplineComponent_SetClosedLoopAtPosition_Params Parms{};

	Parms.bInClosedLoop = bInClosedLoop;
	Parms.Key = Key;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.SetClosedLoop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInClosedLoop                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "SetClosedLoop");

	Params::USplineComponent_SetClosedLoop_Params Parms{};

	Parms.bInClosedLoop = bInClosedLoop;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.RemoveSplinePoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::RemoveSplinePoint(int32 Index, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "RemoveSplinePoint");

	Params::USplineComponent_RemoveSplinePoint_Params Parms{};

	Parms.Index = Index;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.IsClosedLoop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USplineComponent::IsClosedLoop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "IsClosedLoop");

	Params::USplineComponent_IsClosedLoop_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldTangentAtDistanceAlongSpline(float Distance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetWorldTangentAtDistanceAlongSpline");

	Params::USplineComponent_GetWorldTangentAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetWorldRotationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetWorldRotationAtTime(float Time, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetWorldRotationAtTime");

	Params::USplineComponent_GetWorldRotationAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetWorldRotationAtDistanceAlongSpline(float Distance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetWorldRotationAtDistanceAlongSpline");

	Params::USplineComponent_GetWorldRotationAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetWorldLocationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldLocationAtTime(float Time, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetWorldLocationAtTime");

	Params::USplineComponent_GetWorldLocationAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetWorldLocationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldLocationAtSplinePoint(int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetWorldLocationAtSplinePoint");

	Params::USplineComponent_GetWorldLocationAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldLocationAtDistanceAlongSpline(float Distance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetWorldLocationAtDistanceAlongSpline");

	Params::USplineComponent_GetWorldLocationAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetWorldDirectionAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetWorldDirectionAtTime");

	Params::USplineComponent_GetWorldDirectionAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldDirectionAtDistanceAlongSpline(float Distance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetWorldDirectionAtDistanceAlongSpline");

	Params::USplineComponent_GetWorldDirectionAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetUpVectorAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetUpVectorAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetUpVectorAtTime");

	Params::USplineComponent_GetUpVectorAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetUpVectorAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetUpVectorAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetUpVectorAtSplinePoint");

	Params::USplineComponent_GetUpVectorAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetUpVectorAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetUpVectorAtDistanceAlongSpline");

	Params::USplineComponent_GetUpVectorAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetTransformAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::GetTransformAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity, bool bUseScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetTransformAtTime");

	Params::USplineComponent_GetTransformAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;
	Parms.bUseScale = bUseScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetTransformAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::GetTransformAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetTransformAtSplinePoint");

	Params::USplineComponent_GetTransformAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::GetTransformAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetTransformAtDistanceAlongSpline");

	Params::USplineComponent_GetTransformAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetTangentAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetTangentAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetTangentAtTime");

	Params::USplineComponent_GetTangentAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetTangentAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetTangentAtSplinePoint");

	Params::USplineComponent_GetTangentAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetTangentAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetTangentAtDistanceAlongSpline");

	Params::USplineComponent_GetTangentAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetSplinePointType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplinePointType        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESplinePointType USplineComponent::GetSplinePointType(int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetSplinePointType");

	Params::USplineComponent_GetSplinePointType_Params Parms{};

	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetSplineLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetSplineLength()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetSplineLength");

	Params::USplineComponent_GetSplineLength_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetScaleAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetScaleAtTime(float Time, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetScaleAtTime");

	Params::USplineComponent_GetScaleAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetScaleAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetScaleAtSplinePoint(int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetScaleAtSplinePoint");

	Params::USplineComponent_GetScaleAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetScaleAtDistanceAlongSpline(float Distance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetScaleAtDistanceAlongSpline");

	Params::USplineComponent_GetScaleAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRotationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetRotationAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRotationAtTime");

	Params::USplineComponent_GetRotationAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRotationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetRotationAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRotationAtSplinePoint");

	Params::USplineComponent_GetRotationAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetRotationAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRotationAtDistanceAlongSpline");

	Params::USplineComponent_GetRotationAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRollAtTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetRollAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRollAtTime");

	Params::USplineComponent_GetRollAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRollAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetRollAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRollAtSplinePoint");

	Params::USplineComponent_GetRollAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRollAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetRollAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRollAtDistanceAlongSpline");

	Params::USplineComponent_GetRollAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRightVectorAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetRightVectorAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRightVectorAtTime");

	Params::USplineComponent_GetRightVectorAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRightVectorAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetRightVectorAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRightVectorAtSplinePoint");

	Params::USplineComponent_GetRightVectorAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetRightVectorAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetRightVectorAtDistanceAlongSpline");

	Params::USplineComponent_GetRightVectorAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetNumberOfSplinePoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USplineComponent::GetNumberOfSplinePoints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetNumberOfSplinePoints");

	Params::USplineComponent_GetNumberOfSplinePoints_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetLocationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLocationAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetLocationAtTime");

	Params::USplineComponent_GetLocationAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetLocationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLocationAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetLocationAtSplinePoint");

	Params::USplineComponent_GetLocationAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLocationAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetLocationAtDistanceAlongSpline");

	Params::USplineComponent_GetLocationAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Tangent                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::GetLocationAndTangentAtSplinePoint(int32 PointIndex, struct FVector* Location, struct FVector* Tangent, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetLocationAndTangentAtSplinePoint");

	Params::USplineComponent_GetLocationAndTangentAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Tangent != nullptr)
		*Tangent = std::move(Parms.Tangent);

}


// Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LocalLocation                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LocalTangent                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::GetLocalLocationAndTangentAtSplinePoint(int32 PointIndex, struct FVector* LocalLocation, struct FVector* LocalTangent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetLocalLocationAndTangentAtSplinePoint");

	Params::USplineComponent_GetLocalLocationAndTangentAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (LocalLocation != nullptr)
		*LocalLocation = std::move(Parms.LocalLocation);

	if (LocalTangent != nullptr)
		*LocalTangent = std::move(Parms.LocalTangent);

}


// Function Engine.SplineComponent.GetLeaveTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLeaveTangentAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetLeaveTangentAtSplinePoint");

	Params::USplineComponent_GetLeaveTangentAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetInputKeyAtDistanceAlongSpline(float Distance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetInputKeyAtDistanceAlongSpline");

	Params::USplineComponent_GetInputKeyAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetFloatPropertyAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetFloatPropertyAtSplinePoint(int32 Index, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetFloatPropertyAtSplinePoint");

	Params::USplineComponent_GetFloatPropertyAtSplinePoint_Params Parms{};

	Parms.Index = Index;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetDistanceAlongSplineAtSplinePoint(int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetDistanceAlongSplineAtSplinePoint");

	Params::USplineComponent_GetDistanceAlongSplineAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetDirectionAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseConstantVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDirectionAtTime(float Time, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetDirectionAtTime");

	Params::USplineComponent_GetDirectionAtTime_Params Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetDirectionAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDirectionAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetDirectionAtSplinePoint");

	Params::USplineComponent_GetDirectionAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDirectionAtDistanceAlongSpline(float Distance, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetDirectionAtDistanceAlongSpline");

	Params::USplineComponent_GetDirectionAtDistanceAlongSpline_Params Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetDefaultUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDefaultUpVector(enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetDefaultUpVector");

	Params::USplineComponent_GetDefaultUpVector_Params Parms{};

	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.GetArriveTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              PointIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetArriveTangentAtSplinePoint(int32 PointIndex, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "GetArriveTangentAtSplinePoint");

	Params::USplineComponent_GetArriveTangentAtSplinePoint_Params Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindUpVectorClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindUpVectorClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindUpVectorClosestToWorldLocation");

	Params::USplineComponent_FindUpVectorClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindTransformClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::FindTransformClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace, bool bUseScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindTransformClosestToWorldLocation");

	Params::USplineComponent_FindTransformClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindTangentClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindTangentClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindTangentClosestToWorldLocation");

	Params::USplineComponent_FindTangentClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindScaleClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindScaleClosestToWorldLocation(struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindScaleClosestToWorldLocation");

	Params::USplineComponent_FindScaleClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindRotationClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::FindRotationClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindRotationClosestToWorldLocation");

	Params::USplineComponent_FindRotationClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindRollClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::FindRollClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindRollClosestToWorldLocation");

	Params::USplineComponent_FindRollClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindRightVectorClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindRightVectorClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindRightVectorClosestToWorldLocation");

	Params::USplineComponent_FindRightVectorClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindLocationClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindLocationClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindLocationClosestToWorldLocation");

	Params::USplineComponent_FindLocationClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::FindInputKeyClosestToWorldLocation(struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindInputKeyClosestToWorldLocation");

	Params::USplineComponent_FindInputKeyClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.FindDirectionClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     WorldLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindDirectionClosestToWorldLocation(struct FVector& WorldLocation, enum class ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "FindDirectionClosestToWorldLocation");

	Params::USplineComponent_FindDirectionClosestToWorldLocation_Params Parms{};

	Parms.WorldLocation = WorldLocation;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineComponent.ClearSplinePoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::ClearSplinePoints(bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "ClearSplinePoints");

	Params::USplineComponent_ClearSplinePoints_Params Parms{};

	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.AddSplineWorldPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Position                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddSplineWorldPoint(struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "AddSplineWorldPoint");

	Params::USplineComponent_AddSplineWorldPoint_Params Parms{};

	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.AddSplinePointAtIndex
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Position                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddSplinePointAtIndex(struct FVector& Position, int32 Index, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "AddSplinePointAtIndex");

	Params::USplineComponent_AddSplinePointAtIndex_Params Parms{};

	Parms.Position = Position;
	Parms.Index = Index;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.AddSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Position                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESplineCoordinateSpace  CoordinateSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddSplinePoint(struct FVector& Position, enum class ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "AddSplinePoint");

	Params::USplineComponent_AddSplinePoint_Params Parms{};

	Parms.Position = Position;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.AddSplineLocalPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Position                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddSplineLocalPoint(struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "AddSplineLocalPoint");

	Params::USplineComponent_AddSplineLocalPoint_Params Parms{};

	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.AddPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSplinePoint>        Points                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddPoints(TArray<struct FSplinePoint>& Points, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "AddPoints");

	Params::USplineComponent_AddPoints_Params Parms{};

	Parms.Points = Points;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineComponent.AddPoint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSplinePoint                Point                                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bUpdateSpline                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddPoint(struct FSplinePoint& Point, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineComponent", "AddPoint");

	Params::USplineComponent_AddPoint_Params Parms{};

	Parms.Point = Point;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.MovementComponent
// (None)

class UClass* UMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MovementComponent");

	return Clss;
}


// MovementComponent Engine.Default__MovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMovementComponent* UMovementComponent::GetDefaultObj()
{
	static class UMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMovementComponent*>(UMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.MovementComponent.StopMovementImmediately
// (Native, Public, BlueprintCallable)
// Parameters:

void UMovementComponent::StopMovementImmediately()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "StopMovementImmediately");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.SnapUpdatedComponentToPlane
// (Native, Public, BlueprintCallable)
// Parameters:

void UMovementComponent::SnapUpdatedComponentToPlane()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "SnapUpdatedComponentToPlane");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.SetUpdatedComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             NewUpdatedComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetUpdatedComponent(class USceneComponent* NewUpdatedComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "SetUpdatedComponent");

	Params::UMovementComponent_SetUpdatedComponent_Params Parms{};

	Parms.NewUpdatedComponent = NewUpdatedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.SetPlaneConstraintOrigin
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     PlaneOrigin                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintOrigin(const struct FVector& PlaneOrigin)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "SetPlaneConstraintOrigin");

	Params::UMovementComponent_SetPlaneConstraintOrigin_Params Parms{};

	Parms.PlaneOrigin = PlaneOrigin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.SetPlaneConstraintNormal
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     PlaneNormal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintNormal(const struct FVector& PlaneNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "SetPlaneConstraintNormal");

	Params::UMovementComponent_SetPlaneConstraintNormal_Params Parms{};

	Parms.PlaneNormal = PlaneNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.SetPlaneConstraintFromVectors
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Forward                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Up                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintFromVectors(const struct FVector& Forward, const struct FVector& Up)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "SetPlaneConstraintFromVectors");

	Params::UMovementComponent_SetPlaneConstraintFromVectors_Params Parms{};

	Parms.Forward = Forward;
	Parms.Up = Up;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.SetPlaneConstraintEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "SetPlaneConstraintEnabled");

	Params::UMovementComponent_SetPlaneConstraintEnabled_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.SetPlaneConstraintAxisSetting
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EPlaneConstraintAxisSettingNewAxisSetting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintAxisSetting(enum class EPlaneConstraintAxisSetting NewAxisSetting)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "SetPlaneConstraintAxisSetting");

	Params::UMovementComponent_SetPlaneConstraintAxisSetting_Params Parms{};

	Parms.NewAxisSetting = NewAxisSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.PhysicsVolumeChanged
// (Native, Public)
// Parameters:
// class APhysicsVolume*              NewVolume                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "PhysicsVolumeChanged");

	Params::UMovementComponent_PhysicsVolumeChanged_Params Parms{};

	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MovementComponent.K2_MoveUpdatedComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Delta                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bSweep                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementComponent::K2_MoveUpdatedComponent(const struct FVector& Delta, const struct FRotator& NewRotation, struct FHitResult* OutHit, bool bSweep, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "K2_MoveUpdatedComponent");

	Params::UMovementComponent_K2_MoveUpdatedComponent_Params Parms{};

	Parms.Delta = Delta;
	Parms.NewRotation = NewRotation;
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.K2_GetModifiedMaxSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementComponent::K2_GetModifiedMaxSpeed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "K2_GetModifiedMaxSpeed");

	Params::UMovementComponent_K2_GetModifiedMaxSpeed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.K2_GetMaxSpeedModifier
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementComponent::K2_GetMaxSpeedModifier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "K2_GetMaxSpeedModifier");

	Params::UMovementComponent_K2_GetMaxSpeedModifier_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.IsExceedingMaxSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              MaxSpeed                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementComponent::IsExceedingMaxSpeed(float MaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "IsExceedingMaxSpeed");

	Params::UMovementComponent_IsExceedingMaxSpeed_Params Parms{};

	Parms.MaxSpeed = MaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.GetPlaneConstraintOrigin
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementComponent::GetPlaneConstraintOrigin()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "GetPlaneConstraintOrigin");

	Params::UMovementComponent_GetPlaneConstraintOrigin_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.GetPlaneConstraintNormal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementComponent::GetPlaneConstraintNormal()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "GetPlaneConstraintNormal");

	Params::UMovementComponent_GetPlaneConstraintNormal_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.GetPlaneConstraintAxisSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EPlaneConstraintAxisSettingReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPlaneConstraintAxisSetting UMovementComponent::GetPlaneConstraintAxisSetting()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "GetPlaneConstraintAxisSetting");

	Params::UMovementComponent_GetPlaneConstraintAxisSetting_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.GetPhysicsVolume
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APhysicsVolume*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APhysicsVolume* UMovementComponent::GetPhysicsVolume()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "GetPhysicsVolume");

	Params::UMovementComponent_GetPhysicsVolume_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.GetMaxSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementComponent::GetMaxSpeed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "GetMaxSpeed");

	Params::UMovementComponent_GetMaxSpeed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.GetGravityZ
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementComponent::GetGravityZ()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "GetGravityZ");

	Params::UMovementComponent_GetGravityZ_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.ConstrainNormalToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Normal                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementComponent::ConstrainNormalToPlane(const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "ConstrainNormalToPlane");

	Params::UMovementComponent_ConstrainNormalToPlane_Params Parms{};

	Parms.Normal = Normal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.ConstrainLocationToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementComponent::ConstrainLocationToPlane(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "ConstrainLocationToPlane");

	Params::UMovementComponent_ConstrainLocationToPlane_Params Parms{};

	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MovementComponent.ConstrainDirectionToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Direction                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementComponent::ConstrainDirectionToPlane(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MovementComponent", "ConstrainDirectionToPlane");

	Params::UMovementComponent_ConstrainDirectionToPlane_Params Parms{};

	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.NavMovementComponent
// (None)

class UClass* UNavMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavMovementComponent");

	return Clss;
}


// NavMovementComponent Engine.Default__NavMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UNavMovementComponent* UNavMovementComponent::GetDefaultObj()
{
	static class UNavMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UNavMovementComponent*>(UNavMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.NavMovementComponent.StopMovementKeepPathing
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UNavMovementComponent::StopMovementKeepPathing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NavMovementComponent", "StopMovementKeepPathing");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.NavMovementComponent.StopActiveMovement
// (Native, Public, BlueprintCallable)
// Parameters:

void UNavMovementComponent::StopActiveMovement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NavMovementComponent", "StopActiveMovement");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.NavMovementComponent.IsSwimming
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsSwimming()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NavMovementComponent", "IsSwimming");

	Params::UNavMovementComponent_IsSwimming_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.NavMovementComponent.IsMovingOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsMovingOnGround()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NavMovementComponent", "IsMovingOnGround");

	Params::UNavMovementComponent_IsMovingOnGround_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.NavMovementComponent.IsFlying
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsFlying()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NavMovementComponent", "IsFlying");

	Params::UNavMovementComponent_IsFlying_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.NavMovementComponent.IsFalling
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsFalling()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NavMovementComponent", "IsFalling");

	Params::UNavMovementComponent_IsFalling_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.NavMovementComponent.IsCrouching
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsCrouching()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("NavMovementComponent", "IsCrouching");

	Params::UNavMovementComponent_IsCrouching_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.PawnMovementComponent
// (None)

class UClass* UPawnMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PawnMovementComponent");

	return Clss;
}


// PawnMovementComponent Engine.Default__PawnMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPawnMovementComponent* UPawnMovementComponent::GetDefaultObj()
{
	static class UPawnMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPawnMovementComponent*>(UPawnMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PawnMovementComponent.K2_GetInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPawnMovementComponent::K2_GetInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PawnMovementComponent", "K2_GetInputVector");

	Params::UPawnMovementComponent_K2_GetInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PawnMovementComponent.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPawnMovementComponent::IsMoveInputIgnored()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PawnMovementComponent", "IsMoveInputIgnored");

	Params::UPawnMovementComponent_IsMoveInputIgnored_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PawnMovementComponent.GetPendingInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPawnMovementComponent::GetPendingInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PawnMovementComponent", "GetPendingInputVector");

	Params::UPawnMovementComponent_GetPendingInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PawnMovementComponent.GetPawnOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UPawnMovementComponent::GetPawnOwner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PawnMovementComponent", "GetPawnOwner");

	Params::UPawnMovementComponent_GetPawnOwner_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PawnMovementComponent.GetLastInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPawnMovementComponent::GetLastInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PawnMovementComponent", "GetLastInputVector");

	Params::UPawnMovementComponent_GetLastInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PawnMovementComponent.ConsumeInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPawnMovementComponent::ConsumeInputVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PawnMovementComponent", "ConsumeInputVector");

	Params::UPawnMovementComponent_ConsumeInputVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PawnMovementComponent.AddInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     WorldVector                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForce                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPawnMovementComponent::AddInputVector(const struct FVector& WorldVector, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PawnMovementComponent", "AddInputVector");

	Params::UPawnMovementComponent_AddInputVector_Params Parms{};

	Parms.WorldVector = WorldVector;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SoundEffectPreset
// (None)

class UClass* USoundEffectPreset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundEffectPreset");

	return Clss;
}


// SoundEffectPreset Engine.Default__SoundEffectPreset
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundEffectPreset* USoundEffectPreset::GetDefaultObj()
{
	static class USoundEffectPreset* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundEffectPreset*>(USoundEffectPreset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundEffectSourcePreset
// (None)

class UClass* USoundEffectSourcePreset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundEffectSourcePreset");

	return Clss;
}


// SoundEffectSourcePreset Engine.Default__SoundEffectSourcePreset
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundEffectSourcePreset* USoundEffectSourcePreset::GetDefaultObj()
{
	static class USoundEffectSourcePreset* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundEffectSourcePreset*>(USoundEffectSourcePreset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundEffectSubmixPreset
// (None)

class UClass* USoundEffectSubmixPreset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundEffectSubmixPreset");

	return Clss;
}


// SoundEffectSubmixPreset Engine.Default__SoundEffectSubmixPreset
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundEffectSubmixPreset* USoundEffectSubmixPreset::GetDefaultObj()
{
	static class USoundEffectSubmixPreset* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundEffectSubmixPreset*>(USoundEffectSubmixPreset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SpectatorPawn
// (Actor, Pawn)

class UClass* ASpectatorPawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpectatorPawn");

	return Clss;
}


// SpectatorPawn Engine.Default__SpectatorPawn
// (Public, ClassDefaultObject, ArchetypeObject)

class ASpectatorPawn* ASpectatorPawn::GetDefaultObj()
{
	static class ASpectatorPawn* Default = nullptr;

	if (!Default)
		Default = static_cast<ASpectatorPawn*>(ASpectatorPawn::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SceneCaptureComponent
// (SceneComponent)

class UClass* USceneCaptureComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SceneCaptureComponent");

	return Clss;
}


// SceneCaptureComponent Engine.Default__SceneCaptureComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USceneCaptureComponent* USceneCaptureComponent::GetDefaultObj()
{
	static class USceneCaptureComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USceneCaptureComponent*>(USceneCaptureComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SceneCaptureComponent.ShowOnlyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         InComponent                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::ShowOnlyComponent(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "ShowOnlyComponent");

	Params::USceneCaptureComponent_ShowOnlyComponent_Params Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent.ShowOnlyActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::ShowOnlyActorComponents(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "ShowOnlyActorComponents");

	Params::USceneCaptureComponent_ShowOnlyActorComponents_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent.SetCaptureSortPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewCaptureSortPriority                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::SetCaptureSortPriority(int32 NewCaptureSortPriority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "SetCaptureSortPriority");

	Params::USceneCaptureComponent_SetCaptureSortPriority_Params Parms{};

	Parms.NewCaptureSortPriority = NewCaptureSortPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent.RemoveShowOnlyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         InComponent                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::RemoveShowOnlyComponent(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "RemoveShowOnlyComponent");

	Params::USceneCaptureComponent_RemoveShowOnlyComponent_Params Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent.RemoveShowOnlyActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::RemoveShowOnlyActorComponents(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "RemoveShowOnlyActorComponents");

	Params::USceneCaptureComponent_RemoveShowOnlyActorComponents_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent.HideComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         InComponent                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::HideComponent(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "HideComponent");

	Params::USceneCaptureComponent_HideComponent_Params Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent.HideActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                      InActor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::HideActorComponents(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "HideActorComponents");

	Params::USceneCaptureComponent_HideActorComponents_Params Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent.ClearShowOnlyComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USceneCaptureComponent::ClearShowOnlyComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "ClearShowOnlyComponents");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent.ClearHiddenComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USceneCaptureComponent::ClearHiddenComponents()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent", "ClearHiddenComponents");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SceneCaptureComponent2D
// (SceneComponent)

class UClass* USceneCaptureComponent2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SceneCaptureComponent2D");

	return Clss;
}


// SceneCaptureComponent2D Engine.Default__SceneCaptureComponent2D
// (Public, ClassDefaultObject, ArchetypeObject)

class USceneCaptureComponent2D* USceneCaptureComponent2D::GetDefaultObj()
{
	static class USceneCaptureComponent2D* Default = nullptr;

	if (!Default)
		Default = static_cast<USceneCaptureComponent2D*>(USceneCaptureComponent2D::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SceneCaptureComponent2D.CaptureScene
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USceneCaptureComponent2D::CaptureScene()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent2D", "CaptureScene");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                              InWeight                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent2D::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponent2D", "AddOrUpdateBlendable");

	Params::USceneCaptureComponent2D_AddOrUpdateBlendable_Params Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.AISystemBase
// (None)

class UClass* UAISystemBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AISystemBase");

	return Clss;
}


// AISystemBase Engine.Default__AISystemBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UAISystemBase* UAISystemBase::GetDefaultObj()
{
	static class UAISystemBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UAISystemBase*>(UAISystemBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AvoidanceManager
// (None)

class UClass* UAvoidanceManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AvoidanceManager");

	return Clss;
}


// AvoidanceManager Engine.Default__AvoidanceManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UAvoidanceManager* UAvoidanceManager::GetDefaultObj()
{
	static class UAvoidanceManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UAvoidanceManager*>(UAvoidanceManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AvoidanceManager.RegisterMovementComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMovementComponent*          MovementComp                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AvoidanceWeight                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAvoidanceManager::RegisterMovementComponent(class UMovementComponent* MovementComp, float AvoidanceWeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AvoidanceManager", "RegisterMovementComponent");

	Params::UAvoidanceManager_RegisterMovementComponent_Params Parms{};

	Parms.MovementComp = MovementComp;
	Parms.AvoidanceWeight = AvoidanceWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AvoidanceManager.GetObjectCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAvoidanceManager::GetObjectCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AvoidanceManager", "GetObjectCount");

	Params::UAvoidanceManager_GetObjectCount_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AvoidanceManager.GetNewAvoidanceUID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAvoidanceManager::GetNewAvoidanceUID()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AvoidanceManager", "GetNewAvoidanceUID");

	Params::UAvoidanceManager_GetNewAvoidanceUID_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovementComponent*          MovementComp                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAvoidanceManager::GetAvoidanceVelocityForComponent(class UMovementComponent* MovementComp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AvoidanceManager", "GetAvoidanceVelocityForComponent");

	Params::UAvoidanceManager_GetAvoidanceVelocityForComponent_Params Parms{};

	Parms.MovementComp = MovementComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.ProjectileMovementComponent
// (None)

class UClass* UProjectileMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ProjectileMovementComponent");

	return Clss;
}


// ProjectileMovementComponent Engine.Default__ProjectileMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UProjectileMovementComponent* UProjectileMovementComponent::GetDefaultObj()
{
	static class UProjectileMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UProjectileMovementComponent*>(UProjectileMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ProjectileMovementComponent.StopSimulating
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                  HitResult                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::StopSimulating(struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "StopSimulating");

	Params::UProjectileMovementComponent_StopSimulating_Params Parms{};

	Parms.HitResult = HitResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewVelocity                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::SetVelocityInLocalSpace(const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "SetVelocityInLocalSpace");

	Params::UProjectileMovementComponent_SetVelocityInLocalSpace_Params Parms{};

	Parms.NewVelocity = NewVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ProjectileMovementComponent.SetInterpolatedComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::SetInterpolatedComponent(class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "SetInterpolatedComponent");

	Params::UProjectileMovementComponent_SetInterpolatedComponent_Params Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ProjectileMovementComponent.ResetInterpolation
// (Native, Public, BlueprintCallable)
// Parameters:

void UProjectileMovementComponent::ResetInterpolation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "ResetInterpolation");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHitResult                  ImpactResult                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::OnProjectileStopDelegate__DelegateSignature(struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "OnProjectileStopDelegate__DelegateSignature");

	Params::UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature_Params Parms{};

	Parms.ImpactResult = ImpactResult;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                  ImpactResult                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                     ImpactVelocity                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::OnProjectileBounceDelegate__DelegateSignature(struct FHitResult& ImpactResult, struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "OnProjectileBounceDelegate__DelegateSignature");

	Params::UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature_Params Parms{};

	Parms.ImpactResult = ImpactResult;
	Parms.ImpactVelocity = ImpactVelocity;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.ProjectileMovementComponent.MoveInterpolationTarget
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRotation                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::MoveInterpolationTarget(struct FVector& NewLocation, struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "MoveInterpolationTarget");

	Params::UProjectileMovementComponent_MoveInterpolationTarget_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.NewRotation = NewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ProjectileMovementComponent.LimitVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     NewVelocity                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UProjectileMovementComponent::LimitVelocity(const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "LimitVelocity");

	Params::UProjectileMovementComponent_LimitVelocity_Params Parms{};

	Parms.NewVelocity = NewVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ProjectileMovementComponent.IsVelocityUnderSimulationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectileMovementComponent::IsVelocityUnderSimulationThreshold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "IsVelocityUnderSimulationThreshold");

	Params::UProjectileMovementComponent_IsVelocityUnderSimulationThreshold_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ProjectileMovementComponent.IsInterpolationComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectileMovementComponent::IsInterpolationComplete()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ProjectileMovementComponent", "IsInterpolationComplete");

	Params::UProjectileMovementComponent_IsInterpolationComplete_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.ChildActorComponent
// (SceneComponent)

class UClass* UChildActorComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ChildActorComponent");

	return Clss;
}


// ChildActorComponent Engine.Default__ChildActorComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UChildActorComponent* UChildActorComponent::GetDefaultObj()
{
	static class UChildActorComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UChildActorComponent*>(UChildActorComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ChildActorComponent.SetChildActorClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>          InClass                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChildActorComponent::SetChildActorClass(TSubclassOf<class AActor> InClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ChildActorComponent", "SetChildActorClass");

	Params::UChildActorComponent_SetChildActorClass_Params Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.Brush
// (Actor)

class UClass* ABrush::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Brush");

	return Clss;
}


// Brush Engine.Default__Brush
// (Public, ClassDefaultObject, ArchetypeObject)

class ABrush* ABrush::GetDefaultObj()
{
	static class ABrush* Default = nullptr;

	if (!Default)
		Default = static_cast<ABrush*>(ABrush::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Volume
// (Actor)

class UClass* AVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Volume");

	return Clss;
}


// Volume Engine.Default__Volume
// (Public, ClassDefaultObject, ArchetypeObject)

class AVolume* AVolume::GetDefaultObj()
{
	static class AVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AVolume*>(AVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.World
// (None)

class UClass* UWorld::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("World");

	return Clss;
}


// World Engine.Default__World
// (Public, ClassDefaultObject, ArchetypeObject)

class UWorld* UWorld::GetDefaultObj()
{
	static class UWorld* Default = nullptr;

	if (!Default)
		Default = static_cast<UWorld*>(UWorld::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.World.K2_GetWorldSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWorldSettings*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWorldSettings* UWorld::K2_GetWorldSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("World", "K2_GetWorldSettings");

	Params::UWorld_K2_GetWorldSettings_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.World.HandleTimelineScrubbed
// (Final, Native, Public)
// Parameters:

void UWorld::HandleTimelineScrubbed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("World", "HandleTimelineScrubbed");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.NavigationSystemBase
// (None)

class UClass* UNavigationSystemBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavigationSystemBase");

	return Clss;
}


// NavigationSystemBase Engine.Default__NavigationSystemBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UNavigationSystemBase* UNavigationSystemBase::GetDefaultObj()
{
	static class UNavigationSystemBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UNavigationSystemBase*>(UNavigationSystemBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavigationSystemConfig
// (None)

class UClass* UNavigationSystemConfig::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavigationSystemConfig");

	return Clss;
}


// NavigationSystemConfig Engine.Default__NavigationSystemConfig
// (Public, ClassDefaultObject, ArchetypeObject)

class UNavigationSystemConfig* UNavigationSystemConfig::GetDefaultObj()
{
	static class UNavigationSystemConfig* Default = nullptr;

	if (!Default)
		Default = static_cast<UNavigationSystemConfig*>(UNavigationSystemConfig::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavAreaBase
// (None)

class UClass* UNavAreaBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavAreaBase");

	return Clss;
}


// NavAreaBase Engine.Default__NavAreaBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UNavAreaBase* UNavAreaBase::GetDefaultObj()
{
	static class UNavAreaBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UNavAreaBase*>(UNavAreaBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.StaticMeshComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UStaticMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StaticMeshComponent");

	return Clss;
}


// StaticMeshComponent Engine.Default__StaticMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UStaticMeshComponent* UStaticMeshComponent::GetDefaultObj()
{
	static class UStaticMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UStaticMeshComponent*>(UStaticMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.StaticMeshComponent.SetStaticMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                 NewMesh                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaticMeshComponent::SetStaticMesh(class UStaticMesh* NewMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMeshComponent", "SetStaticMesh");

	Params::UStaticMeshComponent_SetStaticMesh_Params Parms{};

	Parms.NewMesh = NewMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StaticMeshComponent.SetReverseCulling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReverseCulling                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::SetReverseCulling(bool ReverseCulling)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMeshComponent", "SetReverseCulling");

	Params::UStaticMeshComponent_SetReverseCulling_Params Parms{};

	Parms.ReverseCulling = ReverseCulling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StaticMeshComponent.SetForcedLodModel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewForcedLodModel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::SetForcedLodModel(int32 NewForcedLodModel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMeshComponent", "SetForcedLodModel");

	Params::UStaticMeshComponent_SetForcedLodModel_Params Parms{};

	Parms.NewForcedLodModel = NewForcedLodModel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StaticMeshComponent.SetDistanceFieldSelfShadowBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::SetDistanceFieldSelfShadowBias(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMeshComponent", "SetDistanceFieldSelfShadowBias");

	Params::UStaticMeshComponent_SetDistanceFieldSelfShadowBias_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StaticMeshComponent.OnRep_StaticMesh
// (Final, Native, Public)
// Parameters:
// class UStaticMesh*                 OldStaticMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::OnRep_StaticMesh(class UStaticMesh* OldStaticMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMeshComponent", "OnRep_StaticMesh");

	Params::UStaticMeshComponent_OnRep_StaticMesh_Params Parms{};

	Parms.OldStaticMesh = OldStaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StaticMeshComponent.GetLocalBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Min                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Max                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::GetLocalBounds(struct FVector* Min, struct FVector* Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMeshComponent", "GetLocalBounds");

	Params::UStaticMeshComponent_GetLocalBounds_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Min != nullptr)
		*Min = std::move(Parms.Min);

	if (Max != nullptr)
		*Max = std::move(Parms.Max);

}


// Class Engine.ParticleModule
// (None)

class UClass* UParticleModule::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModule");

	return Clss;
}


// ParticleModule Engine.Default__ParticleModule
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModule* UParticleModule::GetDefaultObj()
{
	static class UParticleModule* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModule*>(UParticleModule::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotify_PlaySound
// (None)

class UClass* UAnimNotify_PlaySound::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotify_PlaySound");

	return Clss;
}


// AnimNotify_PlaySound Engine.Default__AnimNotify_PlaySound
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotify_PlaySound* UAnimNotify_PlaySound::GetDefaultObj()
{
	static class UAnimNotify_PlaySound* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotify_PlaySound*>(UAnimNotify_PlaySound::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotify_PlayParticleEffect
// (None)

class UClass* UAnimNotify_PlayParticleEffect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotify_PlayParticleEffect");

	return Clss;
}


// AnimNotify_PlayParticleEffect Engine.Default__AnimNotify_PlayParticleEffect
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotify_PlayParticleEffect* UAnimNotify_PlayParticleEffect::GetDefaultObj()
{
	static class UAnimNotify_PlayParticleEffect* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotify_PlayParticleEffect*>(UAnimNotify_PlayParticleEffect::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CameraActor
// (Actor)

class UClass* ACameraActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CameraActor");

	return Clss;
}


// CameraActor Engine.Default__CameraActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ACameraActor* ACameraActor::GetDefaultObj()
{
	static class ACameraActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ACameraActor*>(ACameraActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CameraActor.GetAutoActivatePlayerIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACameraActor::GetAutoActivatePlayerIndex()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraActor", "GetAutoActivatePlayerIndex");

	Params::ACameraActor_GetAutoActivatePlayerIndex_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AssetManager
// (None)

class UClass* UAssetManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AssetManager");

	return Clss;
}


// AssetManager Engine.Default__AssetManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UAssetManager* UAssetManager::GetDefaultObj()
{
	static class UAssetManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UAssetManager*>(UAssetManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.StaticMeshActor
// (Actor)

class UClass* AStaticMeshActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StaticMeshActor");

	return Clss;
}


// StaticMeshActor Engine.Default__StaticMeshActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AStaticMeshActor* AStaticMeshActor::GetDefaultObj()
{
	static class AStaticMeshActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AStaticMeshActor*>(AStaticMeshActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.StaticMeshActor.SetMobility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EComponentMobility      InMobility                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStaticMeshActor::SetMobility(enum class EComponentMobility InMobility)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMeshActor", "SetMobility");

	Params::AStaticMeshActor_SetMobility_Params Parms{};

	Parms.InMobility = InMobility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.CheatManager
// (None)

class UClass* UCheatManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CheatManager");

	return Clss;
}


// CheatManager Engine.Default__CheatManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UCheatManager* UCheatManager::GetDefaultObj()
{
	static class UCheatManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UCheatManager*>(UCheatManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CheatManager.Walk
// (Exec, Native, Public, BlueprintCallable)
// Parameters:

void UCheatManager::Walk()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "Walk");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ViewSelf
// (Exec, Native, Public)
// Parameters:

void UCheatManager::ViewSelf()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ViewSelf");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ViewPlayer
// (Exec, Native, Public)
// Parameters:
// class FString                      S                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::ViewPlayer(const class FString& S)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ViewPlayer");

	Params::UCheatManager_ViewPlayer_Params Parms{};

	Parms.S = S;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ViewClass
// (Exec, Native, Public)
// Parameters:
// TSubclassOf<class AActor>          DesiredClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::ViewClass(TSubclassOf<class AActor> DesiredClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ViewClass");

	Params::UCheatManager_ViewClass_Params Parms{};

	Parms.DesiredClass = DesiredClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ViewActor
// (Exec, Native, Public)
// Parameters:
// class FName                        ActorName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::ViewActor(class FName ActorName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ViewActor");

	Params::UCheatManager_ViewActor_Params Parms{};

	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.UpdateSafeArea
// (Final, Exec, Native, Public)
// Parameters:

void UCheatManager::UpdateSafeArea()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "UpdateSafeArea");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ToggleServerStatReplicatorUpdateStatNet
// (Final, Exec, Native, Public)
// Parameters:

void UCheatManager::ToggleServerStatReplicatorUpdateStatNet()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ToggleServerStatReplicatorUpdateStatNet");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ToggleServerStatReplicatorClientOverwrite
// (Final, Exec, Native, Public)
// Parameters:

void UCheatManager::ToggleServerStatReplicatorClientOverwrite()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ToggleServerStatReplicatorClientOverwrite");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ToggleDebugCamera
// (Exec, Native, Public)
// Parameters:

void UCheatManager::ToggleDebugCamera()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ToggleDebugCamera");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ToggleAILogging
// (Exec, Native, Public)
// Parameters:

void UCheatManager::ToggleAILogging()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ToggleAILogging");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.TestCollisionDistance
// (Exec, Native, Public)
// Parameters:

void UCheatManager::TestCollisionDistance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "TestCollisionDistance");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.Teleport
// (Exec, Native, Public, BlueprintCallable)
// Parameters:

void UCheatManager::Teleport()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "Teleport");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.Summon
// (Exec, Native, Public)
// Parameters:
// class FString                      ClassName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::Summon(const class FString& ClassName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "Summon");

	Params::UCheatManager_Summon_Params Parms{};

	Parms.ClassName = ClassName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.StreamLevelOut
// (Exec, Native, Public)
// Parameters:
// class FName                        PackageName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::StreamLevelOut(class FName PackageName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "StreamLevelOut");

	Params::UCheatManager_StreamLevelOut_Params Parms{};

	Parms.PackageName = PackageName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.StreamLevelIn
// (Exec, Native, Public)
// Parameters:
// class FName                        PackageName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::StreamLevelIn(class FName PackageName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "StreamLevelIn");

	Params::UCheatManager_StreamLevelIn_Params Parms{};

	Parms.PackageName = PackageName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.SpawnServerStatReplicator
// (Final, Exec, Native, Public)
// Parameters:

void UCheatManager::SpawnServerStatReplicator()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "SpawnServerStatReplicator");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.Slomo
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewTimeDilation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::Slomo(float NewTimeDilation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "Slomo");

	Params::UCheatManager_Slomo_Params Parms{};

	Parms.NewTimeDilation = NewTimeDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.SetWorldOrigin
// (Final, Exec, Native, Public)
// Parameters:

void UCheatManager::SetWorldOrigin()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "SetWorldOrigin");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.SetMouseSensitivityToDefault
// (Exec, Native, Public)
// Parameters:

void UCheatManager::SetMouseSensitivityToDefault()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "SetMouseSensitivityToDefault");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ServerToggleAILogging
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:

void UCheatManager::ServerToggleAILogging()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ServerToggleAILogging");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ReceiveInitCheatManager
// (Event, Public, BlueprintEvent)
// Parameters:

void UCheatManager::ReceiveInitCheatManager()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ReceiveInitCheatManager");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.CheatManager.ReceiveEndPlay
// (Event, Public, BlueprintEvent)
// Parameters:

void UCheatManager::ReceiveEndPlay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ReceiveEndPlay");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.CheatManager.PlayersOnly
// (Exec, Native, Public, BlueprintCallable)
// Parameters:

void UCheatManager::PlayersOnly()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "PlayersOnly");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.OnlyLoadLevel
// (Exec, Native, Public)
// Parameters:
// class FName                        PackageName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::OnlyLoadLevel(class FName PackageName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "OnlyLoadLevel");

	Params::UCheatManager_OnlyLoadLevel_Params Parms{};

	Parms.PackageName = PackageName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.LogLoc
// (Exec, Native, Public)
// Parameters:

void UCheatManager::LogLoc()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "LogLoc");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.InvertMouse
// (Exec, Native, Public)
// Parameters:

void UCheatManager::InvertMouse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "InvertMouse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.God
// (Exec, Native, Public, BlueprintCallable)
// Parameters:

void UCheatManager::God()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "God");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.Ghost
// (Exec, Native, Public, BlueprintCallable)
// Parameters:

void UCheatManager::Ghost()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "Ghost");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.FreezeFrame
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              Delay                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::FreezeFrame(float Delay)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "FreezeFrame");

	Params::UCheatManager_FreezeFrame_Params Parms{};

	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.Fly
// (Exec, Native, Public, BlueprintCallable)
// Parameters:

void UCheatManager::Fly()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "Fly");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.FlushLog
// (Exec, Native, Public)
// Parameters:

void UCheatManager::FlushLog()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "FlushLog");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.EnableDebugCamera
// (Native, Protected, BlueprintCallable)
// Parameters:

void UCheatManager::EnableDebugCamera()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "EnableDebugCamera");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DumpVoiceMutingState
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DumpVoiceMutingState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DumpVoiceMutingState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DumpPartyState
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DumpPartyState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DumpPartyState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DumpOnlineSessionState
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DumpOnlineSessionState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DumpOnlineSessionState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DumpChatState
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DumpChatState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DumpChatState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DisableDebugCamera
// (Native, Protected, BlueprintCallable)
// Parameters:

void UCheatManager::DisableDebugCamera()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DisableDebugCamera");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DestroyTarget
// (Exec, Native, Public, BlueprintCallable)
// Parameters:

void UCheatManager::DestroyTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DestroyTarget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DestroyServerStatReplicator
// (Final, Exec, Native, Public)
// Parameters:

void UCheatManager::DestroyServerStatReplicator()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DestroyServerStatReplicator");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DestroyPawns
// (Exec, Native, Public)
// Parameters:
// TSubclassOf<class APawn>           AClass                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DestroyPawns(TSubclassOf<class APawn> AClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DestroyPawns");

	Params::UCheatManager_DestroyPawns_Params Parms{};

	Parms.AClass = AClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DestroyAllPawnsExceptTarget
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DestroyAllPawnsExceptTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DestroyAllPawnsExceptTarget");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DestroyAll
// (Exec, Native, Public)
// Parameters:
// TSubclassOf<class AActor>          AClass                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DestroyAll(TSubclassOf<class AActor> AClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DestroyAll");

	Params::UCheatManager_DestroyAll_Params Parms{};

	Parms.AClass = AClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DebugCapsuleSweepSize
// (Exec, Native, Public)
// Parameters:
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DebugCapsuleSweepSize(float HalfHeight, float Radius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DebugCapsuleSweepSize");

	Params::UCheatManager_DebugCapsuleSweepSize_Params Parms{};

	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DebugCapsuleSweepPawn
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DebugCapsuleSweepPawn()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DebugCapsuleSweepPawn");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DebugCapsuleSweepComplex
// (Exec, Native, Public)
// Parameters:
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DebugCapsuleSweepComplex(bool bTraceComplex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DebugCapsuleSweepComplex");

	Params::UCheatManager_DebugCapsuleSweepComplex_Params Parms{};

	Parms.bTraceComplex = bTraceComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DebugCapsuleSweepClear
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DebugCapsuleSweepClear()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DebugCapsuleSweepClear");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DebugCapsuleSweepChannel
// (Exec, Native, Public)
// Parameters:
// enum class ECollisionChannel       Channel                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DebugCapsuleSweepChannel(enum class ECollisionChannel Channel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DebugCapsuleSweepChannel");

	Params::UCheatManager_DebugCapsuleSweepChannel_Params Parms{};

	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DebugCapsuleSweepCapture
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DebugCapsuleSweepCapture()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DebugCapsuleSweepCapture");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DebugCapsuleSweep
// (Exec, Native, Public)
// Parameters:

void UCheatManager::DebugCapsuleSweep()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DebugCapsuleSweep");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.DamageTarget
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              DamageAmount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DamageTarget(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "DamageTarget");

	Params::UCheatManager_DamageTarget_Params Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.CheatScript
// (Final, Exec, Native, Public)
// Parameters:
// class FString                      ScriptName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::CheatScript(const class FString& ScriptName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "CheatScript");

	Params::UCheatManager_CheatScript_Params Parms{};

	Parms.ScriptName = ScriptName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.ChangeSize
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                              F                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::ChangeSize(float F)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "ChangeSize");

	Params::UCheatManager_ChangeSize_Params Parms{};

	Parms.F = F;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.BugItStringCreator
// (Exec, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                     ViewLocation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ViewRotation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                      GoString                                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      LocString                                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::BugItStringCreator(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, class FString* GoString, class FString* LocString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "BugItStringCreator");

	Params::UCheatManager_BugItStringCreator_Params Parms{};

	Parms.ViewLocation = ViewLocation;
	Parms.ViewRotation = ViewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (GoString != nullptr)
		*GoString = std::move(Parms.GoString);

	if (LocString != nullptr)
		*LocString = std::move(Parms.LocString);

}


// Function Engine.CheatManager.BugItGo
// (Exec, Native, Public)
// Parameters:
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Pitch                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Yaw                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Roll                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "BugItGo");

	Params::UCheatManager_BugItGo_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CheatManager.BugIt
// (Exec, Native, Public)
// Parameters:
// class FString                      ScreenShotDescription                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::BugIt(const class FString& ScreenShotDescription)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CheatManager", "BugIt");

	Params::UCheatManager_BugIt_Params Parms{};

	Parms.ScreenShotDescription = ScreenShotDescription;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.ScriptViewportClient
// (None)

class UClass* UScriptViewportClient::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ScriptViewportClient");

	return Clss;
}


// ScriptViewportClient Engine.Default__ScriptViewportClient
// (Public, ClassDefaultObject, ArchetypeObject)

class UScriptViewportClient* UScriptViewportClient::GetDefaultObj()
{
	static class UScriptViewportClient* Default = nullptr;

	if (!Default)
		Default = static_cast<UScriptViewportClient*>(UScriptViewportClient::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.GameViewportClient
// (None)

class UClass* UGameViewportClient::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameViewportClient");

	return Clss;
}


// GameViewportClient Engine.Default__GameViewportClient
// (Public, ClassDefaultObject, ArchetypeObject)

class UGameViewportClient* UGameViewportClient::GetDefaultObj()
{
	static class UGameViewportClient* Default = nullptr;

	if (!Default)
		Default = static_cast<UGameViewportClient*>(UGameViewportClient::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.GameViewportClient.SSSwapControllers
// (Exec, Native, Public)
// Parameters:

void UGameViewportClient::SSSwapControllers()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameViewportClient", "SSSwapControllers");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameViewportClient.ShowTitleSafeArea
// (Exec, Native, Public)
// Parameters:

void UGameViewportClient::ShowTitleSafeArea()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameViewportClient", "ShowTitleSafeArea");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameViewportClient.SetConsoleTarget
// (Exec, Native, Public)
// Parameters:
// int32                              PlayerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameViewportClient::SetConsoleTarget(int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameViewportClient", "SetConsoleTarget");

	Params::UGameViewportClient_SetConsoleTarget_Params Parms{};

	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.Console
// (None)

class UClass* UConsole::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Console");

	return Clss;
}


// Console Engine.Default__Console
// (Public, ClassDefaultObject, ArchetypeObject)

class UConsole* UConsole::GetDefaultObj()
{
	static class UConsole* Default = nullptr;

	if (!Default)
		Default = static_cast<UConsole*>(UConsole::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LocalPlayerSubsystem
// (None)

class UClass* ULocalPlayerSubsystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LocalPlayerSubsystem");

	return Clss;
}


// LocalPlayerSubsystem Engine.Default__LocalPlayerSubsystem
// (Public, ClassDefaultObject, ArchetypeObject)

class ULocalPlayerSubsystem* ULocalPlayerSubsystem::GetDefaultObj()
{
	static class ULocalPlayerSubsystem* Default = nullptr;

	if (!Default)
		Default = static_cast<ULocalPlayerSubsystem*>(ULocalPlayerSubsystem::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Emitter
// (Actor)

class UClass* AEmitter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Emitter");

	return Clss;
}


// Emitter Engine.Default__Emitter
// (Public, ClassDefaultObject, ArchetypeObject)

class AEmitter* AEmitter::GetDefaultObj()
{
	static class AEmitter* Default = nullptr;

	if (!Default)
		Default = static_cast<AEmitter*>(AEmitter::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Emitter.ToggleActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AEmitter::ToggleActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "ToggleActive");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.SetVectorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetVectorParameter(class FName ParameterName, const struct FVector& Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "SetVectorParameter");

	Params::AEmitter_SetVectorParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.SetTemplate
// (Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystem*             NewTemplate                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetTemplate(class UParticleSystem* NewTemplate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "SetTemplate");

	Params::AEmitter_SetTemplate_Params Parms{};

	Parms.NewTemplate = NewTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.SetMaterialParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetMaterialParameter(class FName ParameterName, class UMaterialInterface* Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "SetMaterialParameter");

	Params::AEmitter_SetMaterialParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.SetFloatParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetFloatParameter(class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "SetFloatParameter");

	Params::AEmitter_SetFloatParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.SetColorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetColorParameter(class FName ParameterName, const struct FLinearColor& Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "SetColorParameter");

	Params::AEmitter_SetColorParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.SetActorParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetActorParameter(class FName ParameterName, class AActor* Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "SetActorParameter");

	Params::AEmitter_SetActorParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.OnRep_bCurrentlyActive
// (Native, Public)
// Parameters:

void AEmitter::OnRep_bCurrentlyActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "OnRep_bCurrentlyActive");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.OnParticleSystemFinished
// (Native, Public)
// Parameters:
// class UParticleSystemComponent*    FinishedComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "OnParticleSystemFinished");

	Params::AEmitter_OnParticleSystemFinished_Params Parms{};

	Parms.FinishedComponent = FinishedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEmitter::IsActive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "IsActive");

	Params::AEmitter_IsActive_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Emitter.Deactivate
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AEmitter::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "Deactivate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Emitter.Activate
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AEmitter::Activate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Emitter", "Activate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.EmitterCameraLensEffectBase
// (Actor)

class UClass* AEmitterCameraLensEffectBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EmitterCameraLensEffectBase");

	return Clss;
}


// EmitterCameraLensEffectBase Engine.Default__EmitterCameraLensEffectBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AEmitterCameraLensEffectBase* AEmitterCameraLensEffectBase::GetDefaultObj()
{
	static class AEmitterCameraLensEffectBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AEmitterCameraLensEffectBase*>(AEmitterCameraLensEffectBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.GameEngine
// (None)

class UClass* UGameEngine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameEngine");

	return Clss;
}


// GameEngine Engine.Default__GameEngine
// (Public, ClassDefaultObject, ArchetypeObject)

class UGameEngine* UGameEngine::GetDefaultObj()
{
	static class UGameEngine* Default = nullptr;

	if (!Default)
		Default = static_cast<UGameEngine*>(UGameEngine::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PlayerCameraManager
// (Actor)

class UClass* APlayerCameraManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerCameraManager");

	return Clss;
}


// PlayerCameraManager Engine.Default__PlayerCameraManager
// (Public, ClassDefaultObject, ArchetypeObject)

class APlayerCameraManager* APlayerCameraManager::GetDefaultObj()
{
	static class APlayerCameraManager* Default = nullptr;

	if (!Default)
		Default = static_cast<APlayerCameraManager*>(APlayerCameraManager::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PlayerCameraManager.StopCameraShake
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraShake*                ShakeInstance                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bImmediately                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopCameraShake(class UCameraShake* ShakeInstance, bool bImmediately)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "StopCameraShake");

	Params::APlayerCameraManager_StopCameraShake_Params Parms{};

	Parms.ShakeInstance = ShakeInstance;
	Parms.bImmediately = bImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.StopCameraFade
// (Native, Public, BlueprintCallable)
// Parameters:

void APlayerCameraManager::StopCameraFade()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "StopCameraFade");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.StopCameraAnimInst
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraAnimInst*             AnimInst                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bImmediate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopCameraAnimInst(class UCameraAnimInst* AnimInst, bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "StopCameraAnimInst");

	Params::APlayerCameraManager_StopCameraAnimInst_Params Parms{};

	Parms.AnimInst = AnimInst;
	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShake>    Shake                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bImmediately                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllInstancesOfCameraShake(TSubclassOf<class UCameraShake> Shake, bool bImmediately)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "StopAllInstancesOfCameraShake");

	Params::APlayerCameraManager_StopAllInstancesOfCameraShake_Params Parms{};

	Parms.Shake = Shake;
	Parms.bImmediately = bImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraAnim*                 Anim                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bImmediate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllInstancesOfCameraAnim(class UCameraAnim* Anim, bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "StopAllInstancesOfCameraAnim");

	Params::APlayerCameraManager_StopAllInstancesOfCameraAnim_Params Parms{};

	Parms.Anim = Anim;
	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.StopAllCameraShakes
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bImmediately                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllCameraShakes(bool bImmediately)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "StopAllCameraShakes");

	Params::APlayerCameraManager_StopAllCameraShakes_Params Parms{};

	Parms.bImmediately = bImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.StopAllCameraAnims
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bImmediate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllCameraAnims(bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "StopAllCameraAnims");

	Params::APlayerCameraManager_StopAllCameraAnims_Params Parms{};

	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.StartCameraFade
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                              FromAlpha                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ToAlpha                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                Color                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldFadeAudio                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bHoldWhenFinished                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StartCameraFade(float FromAlpha, float ToAlpha, float Duration, const struct FLinearColor& Color, bool bShouldFadeAudio, bool bHoldWhenFinished)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "StartCameraFade");

	Params::APlayerCameraManager_StartCameraFade_Params Parms{};

	Parms.FromAlpha = FromAlpha;
	Parms.ToAlpha = ToAlpha;
	Parms.Duration = Duration;
	Parms.Color = Color;
	Parms.bShouldFadeAudio = bShouldFadeAudio;
	Parms.bHoldWhenFinished = bHoldWhenFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.SetManualCameraFade
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                              InFadeAmount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                Color                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInFadeAudio                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::SetManualCameraFade(float InFadeAmount, const struct FLinearColor& Color, bool bInFadeAudio)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "SetManualCameraFade");

	Params::APlayerCameraManager_SetManualCameraFade_Params Parms{};

	Parms.InFadeAmount = InFadeAmount;
	Parms.Color = Color;
	Parms.bInFadeAudio = bInFadeAudio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.RemoveCameraModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraModifier*             ModifierToRemove                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCameraManager::RemoveCameraModifier(class UCameraModifier* ModifierToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "RemoveCameraModifier");

	Params::APlayerCameraManager_RemoveCameraModifier_Params Parms{};

	Parms.ModifierToRemove = ModifierToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.RemoveCameraLensEffect
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEmitterCameraLensEffectBase*Emitter                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "RemoveCameraLensEffect");

	Params::APlayerCameraManager_RemoveCameraLensEffect_Params Parms{};

	Parms.Emitter = Emitter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.PlayCameraShake
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShake>    ShakeClass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECameraAnimPlaySpace    PlaySpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    UserPlaySpaceRot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UCameraShake*                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraShake* APlayerCameraManager::PlayCameraShake(TSubclassOf<class UCameraShake> ShakeClass, float Scale, enum class ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "PlayCameraShake");

	Params::APlayerCameraManager_PlayCameraShake_Params Parms{};

	Parms.ShakeClass = ShakeClass;
	Parms.Scale = Scale;
	Parms.PlaySpace = PlaySpace;
	Parms.UserPlaySpaceRot = UserPlaySpaceRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.PlayCameraAnim
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UCameraAnim*                 Anim                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Rate                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendInTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendOutTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLoop                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRandomStartTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECameraAnimPlaySpace    PlaySpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    UserPlaySpaceRot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UCameraAnimInst*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraAnimInst* APlayerCameraManager::PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, enum class ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "PlayCameraAnim");

	Params::APlayerCameraManager_PlayCameraAnim_Params Parms{};

	Parms.Anim = Anim;
	Parms.Rate = Rate;
	Parms.Scale = Scale;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.bLoop = bLoop;
	Parms.bRandomStartTime = bRandomStartTime;
	Parms.Duration = Duration;
	Parms.PlaySpace = PlaySpace;
	Parms.UserPlaySpaceRot = UserPlaySpaceRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.PhotographyCameraModify
// (BlueprintCosmetic, Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                     NewCameraLocation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PreviousCameraLocation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OriginalCameraLocation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ResultCameraLocation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::PhotographyCameraModify(const struct FVector& NewCameraLocation, const struct FVector& PreviousCameraLocation, const struct FVector& OriginalCameraLocation, struct FVector* ResultCameraLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "PhotographyCameraModify");

	Params::APlayerCameraManager_PhotographyCameraModify_Params Parms{};

	Parms.NewCameraLocation = NewCameraLocation;
	Parms.PreviousCameraLocation = PreviousCameraLocation;
	Parms.OriginalCameraLocation = OriginalCameraLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ResultCameraLocation != nullptr)
		*ResultCameraLocation = std::move(Parms.ResultCameraLocation);

}


// Function Engine.PlayerCameraManager.OnPhotographySessionStart
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)
// Parameters:

void APlayerCameraManager::OnPhotographySessionStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "OnPhotographySessionStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.OnPhotographySessionEnd
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)
// Parameters:

void APlayerCameraManager::OnPhotographySessionEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "OnPhotographySessionEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureStart
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)
// Parameters:

void APlayerCameraManager::OnPhotographyMultiPartCaptureStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "OnPhotographyMultiPartCaptureStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureEnd
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)
// Parameters:

void APlayerCameraManager::OnPhotographyMultiPartCaptureEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "OnPhotographyMultiPartCaptureEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.GetOwningPlayerController
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* APlayerCameraManager::GetOwningPlayerController()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "GetOwningPlayerController");

	Params::APlayerCameraManager_GetOwningPlayerController_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.GetFOVAngle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerCameraManager::GetFOVAngle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "GetFOVAngle");

	Params::APlayerCameraManager_GetFOVAngle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.GetCameraRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator APlayerCameraManager::GetCameraRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "GetCameraRotation");

	Params::APlayerCameraManager_GetCameraRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.GetCameraLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APlayerCameraManager::GetCameraLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "GetCameraLocation");

	Params::APlayerCameraManager_GetCameraLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.FindCameraModifierByClass
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraModifier> ModifierClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraModifier*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraModifier* APlayerCameraManager::FindCameraModifierByClass(TSubclassOf<class UCameraModifier> ModifierClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "FindCameraModifierByClass");

	Params::APlayerCameraManager_FindCameraModifierByClass_Params Parms{};

	Parms.ModifierClass = ModifierClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.ClearCameraLensEffects
// (Native, Public, BlueprintCallable)
// Parameters:

void APlayerCameraManager::ClearCameraLensEffects()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "ClearCameraLensEffects");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerCameraManager.BlueprintUpdateCamera
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                      CameraTarget                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewCameraLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewCameraRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              NewCameraFOV                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCameraManager::BlueprintUpdateCamera(class AActor* CameraTarget, struct FVector* NewCameraLocation, struct FRotator* NewCameraRotation, float* NewCameraFOV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "BlueprintUpdateCamera");

	Params::APlayerCameraManager_BlueprintUpdateCamera_Params Parms{};

	Parms.CameraTarget = CameraTarget;

	UObject::ProcessEvent(Func, &Parms);

	if (NewCameraLocation != nullptr)
		*NewCameraLocation = std::move(Parms.NewCameraLocation);

	if (NewCameraRotation != nullptr)
		*NewCameraRotation = std::move(Parms.NewCameraRotation);

	if (NewCameraFOV != nullptr)
		*NewCameraFOV = Parms.NewCameraFOV;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.AddNewCameraModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraModifier> ModifierClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraModifier*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraModifier* APlayerCameraManager::AddNewCameraModifier(TSubclassOf<class UCameraModifier> ModifierClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "AddNewCameraModifier");

	Params::APlayerCameraManager_AddNewCameraModifier_Params Parms{};

	Parms.ModifierClass = ModifierClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlayerCameraManager.AddCameraLensEffect
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AEmitterCameraLensEffectBase>LensEffectEmitterClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEmitterCameraLensEffectBase*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEmitterCameraLensEffectBase* APlayerCameraManager::AddCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerCameraManager", "AddCameraLensEffect");

	Params::APlayerCameraManager_AddCameraLensEffect_Params Parms{};

	Parms.LensEffectEmitterClass = LensEffectEmitterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.GameMode
// (Actor)

class UClass* AGameMode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameMode");

	return Clss;
}


// GameMode Engine.Default__GameMode
// (Public, ClassDefaultObject, ArchetypeObject)

class AGameMode* AGameMode::GetDefaultObj()
{
	static class AGameMode* Default = nullptr;

	if (!Default)
		Default = static_cast<AGameMode*>(AGameMode::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.GameMode.StartMatch
// (Native, Public, BlueprintCallable)
// Parameters:

void AGameMode::StartMatch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "StartMatch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameMode.SetBandwidthLimit
// (Exec, Native, Public)
// Parameters:
// float                              AsyncIOBandwidthLimit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameMode::SetBandwidthLimit(float AsyncIOBandwidthLimit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "SetBandwidthLimit");

	Params::AGameMode_SetBandwidthLimit_Params Parms{};

	Parms.AsyncIOBandwidthLimit = AsyncIOBandwidthLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameMode.Say
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Msg                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameMode::Say(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "Say");

	Params::AGameMode_Say_Params Parms{};

	Parms.Msg = Msg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameMode.RestartGame
// (Native, Public, BlueprintCallable)
// Parameters:

void AGameMode::RestartGame()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "RestartGame");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameMode.ReadyToStartMatch
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameMode::ReadyToStartMatch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "ReadyToStartMatch");

	Params::AGameMode_ReadyToStartMatch_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameMode.ReadyToEndMatch
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameMode::ReadyToEndMatch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "ReadyToEndMatch");

	Params::AGameMode_ReadyToEndMatch_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameMode.K2_OnSetMatchState
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                        NewState                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameMode::K2_OnSetMatchState(class FName NewState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "K2_OnSetMatchState");

	Params::AGameMode_K2_OnSetMatchState_Params Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.GameMode.IsMatchInProgress
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameMode::IsMatchInProgress()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "IsMatchInProgress");

	Params::AGameMode_IsMatchInProgress_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameMode.HasMatchEnded
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameMode::HasMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "HasMatchEnded");

	Params::AGameMode_HasMatchEnded_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameMode.GetMatchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AGameMode::GetMatchState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "GetMatchState");

	Params::AGameMode_GetMatchState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameMode.EndMatch
// (Native, Public, BlueprintCallable)
// Parameters:

void AGameMode::EndMatch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "EndMatch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameMode.AbortMatch
// (Native, Public, BlueprintCallable)
// Parameters:

void AGameMode::AbortMatch()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameMode", "AbortMatch");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.GameSession
// (Actor)

class UClass* AGameSession::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameSession");

	return Clss;
}


// GameSession Engine.Default__GameSession
// (Public, ClassDefaultObject, ArchetypeObject)

class AGameSession* AGameSession::GetDefaultObj()
{
	static class AGameSession* Default = nullptr;

	if (!Default)
		Default = static_cast<AGameSession*>(AGameSession::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.GameStateBase
// (Actor)

class UClass* AGameStateBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameStateBase");

	return Clss;
}


// GameStateBase Engine.Default__GameStateBase
// (Public, ClassDefaultObject, ArchetypeObject)

class AGameStateBase* AGameStateBase::GetDefaultObj()
{
	static class AGameStateBase* Default = nullptr;

	if (!Default)
		Default = static_cast<AGameStateBase*>(AGameStateBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.GameStateBase.OnRep_SpectatorClass
// (Native, Protected)
// Parameters:

void AGameStateBase::OnRep_SpectatorClass()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "OnRep_SpectatorClass");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameStateBase.OnRep_ReplicatedWorldTimeSeconds
// (Native, Protected)
// Parameters:

void AGameStateBase::OnRep_ReplicatedWorldTimeSeconds()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "OnRep_ReplicatedWorldTimeSeconds");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameStateBase.OnRep_ReplicatedHasBegunPlay
// (Native, Protected)
// Parameters:

void AGameStateBase::OnRep_ReplicatedHasBegunPlay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "OnRep_ReplicatedHasBegunPlay");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameStateBase.OnRep_GameModeClass
// (Native, Protected)
// Parameters:

void AGameStateBase::OnRep_GameModeClass()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "OnRep_GameModeClass");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameStateBase.HasMatchStarted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameStateBase::HasMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "HasMatchStarted");

	Params::AGameStateBase_HasMatchStarted_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameStateBase.HasBegunPlay
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameStateBase::HasBegunPlay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "HasBegunPlay");

	Params::AGameStateBase_HasBegunPlay_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameStateBase.GetServerWorldTimeSeconds
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGameStateBase::GetServerWorldTimeSeconds()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "GetServerWorldTimeSeconds");

	Params::AGameStateBase_GetServerWorldTimeSeconds_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameStateBase.GetPlayerStartTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                 Controller                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGameStateBase::GetPlayerStartTime(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "GetPlayerStartTime");

	Params::AGameStateBase_GetPlayerStartTime_Params Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameStateBase.GetPlayerRespawnDelay
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                 Controller                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGameStateBase::GetPlayerRespawnDelay(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameStateBase", "GetPlayerRespawnDelay");

	Params::AGameStateBase_GetPlayerRespawnDelay_Params Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.GameState
// (Actor)

class UClass* AGameState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameState");

	return Clss;
}


// GameState Engine.Default__GameState
// (Public, ClassDefaultObject, ArchetypeObject)

class AGameState* AGameState::GetDefaultObj()
{
	static class AGameState* Default = nullptr;

	if (!Default)
		Default = static_cast<AGameState*>(AGameState::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.GameState.OnRep_MatchState
// (Native, Public)
// Parameters:

void AGameState::OnRep_MatchState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameState", "OnRep_MatchState");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameState.OnRep_ElapsedTime
// (Native, Public)
// Parameters:

void AGameState::OnRep_ElapsedTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameState", "OnRep_ElapsedTime");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.GameUserSettings
// (None)

class UClass* UGameUserSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameUserSettings");

	return Clss;
}


// GameUserSettings Engine.Default__GameUserSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UGameUserSettings* UGameUserSettings::GetDefaultObj()
{
	static class UGameUserSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UGameUserSettings*>(UGameUserSettings::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.GameUserSettings.ValidateSettings
// (Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::ValidateSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "ValidateSettings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SupportsHDRDisplayOutput
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::SupportsHDRDisplayOutput()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SupportsHDRDisplayOutput");

	Params::UGameUserSettings_SupportsHDRDisplayOutput_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.SetVSyncEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetVSyncEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetVSyncEnabled");

	Params::UGameUserSettings_SetVSyncEnabled_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetVisualEffectQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetVisualEffectQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetVisualEffectQuality");

	Params::UGameUserSettings_SetVisualEffectQuality_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetViewDistanceQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetViewDistanceQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetViewDistanceQuality");

	Params::UGameUserSettings_SetViewDistanceQuality_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetToDefaults
// (Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::SetToDefaults()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetToDefaults");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetTextureQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetTextureQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetTextureQuality");

	Params::UGameUserSettings_SetTextureQuality_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetShadowQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetShadowQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetShadowQuality");

	Params::UGameUserSettings_SetShadowQuality_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                   Resolution                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetScreenResolution(const struct FIntPoint& Resolution)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetScreenResolution");

	Params::UGameUserSettings_SetScreenResolution_Params Parms{};

	Parms.Resolution = Resolution;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetResolutionScaleValueEx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewScaleValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetResolutionScaleValueEx(float NewScaleValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetResolutionScaleValueEx");

	Params::UGameUserSettings_SetResolutionScaleValueEx_Params Parms{};

	Parms.NewScaleValue = NewScaleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetResolutionScaleValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewScaleValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetResolutionScaleValue(int32 NewScaleValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetResolutionScaleValue");

	Params::UGameUserSettings_SetResolutionScaleValue_Params Parms{};

	Parms.NewScaleValue = NewScaleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetResolutionScaleNormalized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewScaleNormalized                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetResolutionScaleNormalized(float NewScaleNormalized)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetResolutionScaleNormalized");

	Params::UGameUserSettings_SetResolutionScaleNormalized_Params Parms{};

	Parms.NewScaleNormalized = NewScaleNormalized;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetPostProcessingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetPostProcessingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetPostProcessingQuality");

	Params::UGameUserSettings_SetPostProcessingQuality_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetOverallScalabilityLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetOverallScalabilityLevel(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetOverallScalabilityLevel");

	Params::UGameUserSettings_SetOverallScalabilityLevel_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetFullscreenMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EWindowMode             InFullscreenMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetFullscreenMode(enum class EWindowMode InFullscreenMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetFullscreenMode");

	Params::UGameUserSettings_SetFullscreenMode_Params Parms{};

	Parms.InFullscreenMode = InFullscreenMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetFrameRateLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewLimit                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetFrameRateLimit(float NewLimit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetFrameRateLimit");

	Params::UGameUserSettings_SetFrameRateLimit_Params Parms{};

	Parms.NewLimit = NewLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetFoliageQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetFoliageQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetFoliageQuality");

	Params::UGameUserSettings_SetFoliageQuality_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetDynamicResolutionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetDynamicResolutionEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetDynamicResolutionEnabled");

	Params::UGameUserSettings_SetDynamicResolutionEnabled_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetBenchmarkFallbackValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::SetBenchmarkFallbackValues()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetBenchmarkFallbackValues");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetAudioQualityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              QualityLevel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetAudioQualityLevel(int32 QualityLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetAudioQualityLevel");

	Params::UGameUserSettings_SetAudioQualityLevel_Params Parms{};

	Parms.QualityLevel = QualityLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SetAntiAliasingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetAntiAliasingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SetAntiAliasingQuality");

	Params::UGameUserSettings_SetAntiAliasingQuality_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.SaveSettings
// (Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::SaveSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "SaveSettings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.RunHardwareBenchmark
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              WorkScale                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CPUMultiplier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              GPUMultiplier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::RunHardwareBenchmark(int32 WorkScale, float CPUMultiplier, float GPUMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "RunHardwareBenchmark");

	Params::UGameUserSettings_RunHardwareBenchmark_Params Parms{};

	Parms.WorkScale = WorkScale;
	Parms.CPUMultiplier = CPUMultiplier;
	Parms.GPUMultiplier = GPUMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.RevertVideoMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::RevertVideoMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "RevertVideoMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.ResetToCurrentSettings
// (Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::ResetToCurrentSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "ResetToCurrentSettings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.LoadSettings
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bForceReload                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::LoadSettings(bool bForceReload)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "LoadSettings");

	Params::UGameUserSettings_LoadSettings_Params Parms{};

	Parms.bForceReload = bForceReload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.IsVSyncEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsVSyncEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "IsVSyncEnabled");

	Params::UGameUserSettings_IsVSyncEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.IsVSyncDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsVSyncDirty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "IsVSyncDirty");

	Params::UGameUserSettings_IsVSyncDirty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.IsScreenResolutionDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsScreenResolutionDirty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "IsScreenResolutionDirty");

	Params::UGameUserSettings_IsScreenResolutionDirty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.IsHDREnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsHDREnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "IsHDREnabled");

	Params::UGameUserSettings_IsHDREnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.IsFullscreenModeDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsFullscreenModeDirty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "IsFullscreenModeDirty");

	Params::UGameUserSettings_IsFullscreenModeDirty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.IsDynamicResolutionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsDynamicResolutionEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "IsDynamicResolutionEnabled");

	Params::UGameUserSettings_IsDynamicResolutionEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.IsDynamicResolutionDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsDynamicResolutionDirty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "IsDynamicResolutionDirty");

	Params::UGameUserSettings_IsDynamicResolutionDirty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.IsDirty
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsDirty()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "IsDirty");

	Params::UGameUserSettings_IsDirty_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetVisualEffectQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetVisualEffectQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetVisualEffectQuality");

	Params::UGameUserSettings_GetVisualEffectQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetViewDistanceQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetViewDistanceQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetViewDistanceQuality");

	Params::UGameUserSettings_GetViewDistanceQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetTextureQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetTextureQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetTextureQuality");

	Params::UGameUserSettings_GetTextureQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetSyncInterval
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetSyncInterval()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetSyncInterval");

	Params::UGameUserSettings_GetSyncInterval_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetShadowQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetShadowQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetShadowQuality");

	Params::UGameUserSettings_GetShadowQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetScreenResolution()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetScreenResolution");

	Params::UGameUserSettings_GetScreenResolution_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetResolutionScaleNormalized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameUserSettings::GetResolutionScaleNormalized()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetResolutionScaleNormalized");

	Params::UGameUserSettings_GetResolutionScaleNormalized_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetResolutionScaleInformationEx
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              CurrentScaleNormalized                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CurrentScaleValue                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MinScaleValue                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxScaleValue                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::GetResolutionScaleInformationEx(float* CurrentScaleNormalized, float* CurrentScaleValue, float* MinScaleValue, float* MaxScaleValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetResolutionScaleInformationEx");

	Params::UGameUserSettings_GetResolutionScaleInformationEx_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (CurrentScaleNormalized != nullptr)
		*CurrentScaleNormalized = Parms.CurrentScaleNormalized;

	if (CurrentScaleValue != nullptr)
		*CurrentScaleValue = Parms.CurrentScaleValue;

	if (MinScaleValue != nullptr)
		*MinScaleValue = Parms.MinScaleValue;

	if (MaxScaleValue != nullptr)
		*MaxScaleValue = Parms.MaxScaleValue;

}


// Function Engine.GameUserSettings.GetResolutionScaleInformation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              CurrentScaleNormalized                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CurrentScaleValue                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinScaleValue                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaxScaleValue                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::GetResolutionScaleInformation(float* CurrentScaleNormalized, int32* CurrentScaleValue, int32* MinScaleValue, int32* MaxScaleValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetResolutionScaleInformation");

	Params::UGameUserSettings_GetResolutionScaleInformation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (CurrentScaleNormalized != nullptr)
		*CurrentScaleNormalized = Parms.CurrentScaleNormalized;

	if (CurrentScaleValue != nullptr)
		*CurrentScaleValue = Parms.CurrentScaleValue;

	if (MinScaleValue != nullptr)
		*MinScaleValue = Parms.MinScaleValue;

	if (MaxScaleValue != nullptr)
		*MaxScaleValue = Parms.MaxScaleValue;

}


// Function Engine.GameUserSettings.GetRecommendedResolutionScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameUserSettings::GetRecommendedResolutionScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetRecommendedResolutionScale");

	Params::UGameUserSettings_GetRecommendedResolutionScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetPreferredFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EWindowMode             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWindowMode UGameUserSettings::GetPreferredFullscreenMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetPreferredFullscreenMode");

	Params::UGameUserSettings_GetPreferredFullscreenMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetPostProcessingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetPostProcessingQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetPostProcessingQuality");

	Params::UGameUserSettings_GetPostProcessingQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetOverallScalabilityLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetOverallScalabilityLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetOverallScalabilityLevel");

	Params::UGameUserSettings_GetOverallScalabilityLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetLastConfirmedScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetLastConfirmedScreenResolution()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetLastConfirmedScreenResolution");

	Params::UGameUserSettings_GetLastConfirmedScreenResolution_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetLastConfirmedFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EWindowMode             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWindowMode UGameUserSettings::GetLastConfirmedFullscreenMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetLastConfirmedFullscreenMode");

	Params::UGameUserSettings_GetLastConfirmedFullscreenMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameUserSettings*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameUserSettings* UGameUserSettings::GetGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetGameUserSettings");

	Params::UGameUserSettings_GetGameUserSettings_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EWindowMode             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWindowMode UGameUserSettings::GetFullscreenMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetFullscreenMode");

	Params::UGameUserSettings_GetFullscreenMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetFrameRateLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameUserSettings::GetFrameRateLimit()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetFrameRateLimit");

	Params::UGameUserSettings_GetFrameRateLimit_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetFoliageQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetFoliageQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetFoliageQuality");

	Params::UGameUserSettings_GetFoliageQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetDesktopResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetDesktopResolution()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetDesktopResolution");

	Params::UGameUserSettings_GetDesktopResolution_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetDefaultWindowPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetDefaultWindowPosition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetDefaultWindowPosition");

	Params::UGameUserSettings_GetDefaultWindowPosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetDefaultWindowMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// enum class EWindowMode             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EWindowMode UGameUserSettings::GetDefaultWindowMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetDefaultWindowMode");

	Params::UGameUserSettings_GetDefaultWindowMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetDefaultResolutionScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameUserSettings::GetDefaultResolutionScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetDefaultResolutionScale");

	Params::UGameUserSettings_GetDefaultResolutionScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetDefaultResolution
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetDefaultResolution()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetDefaultResolution");

	Params::UGameUserSettings_GetDefaultResolution_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetCurrentHDRDisplayNits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetCurrentHDRDisplayNits()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetCurrentHDRDisplayNits");

	Params::UGameUserSettings_GetCurrentHDRDisplayNits_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetAudioQualityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetAudioQualityLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetAudioQualityLevel");

	Params::UGameUserSettings_GetAudioQualityLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.GetAntiAliasingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetAntiAliasingQuality()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "GetAntiAliasingQuality");

	Params::UGameUserSettings_GetAntiAliasingQuality_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameUserSettings.EnableHDRDisplayOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              DisplayNits                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::EnableHDRDisplayOutput(bool bEnable, int32 DisplayNits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "EnableHDRDisplayOutput");

	Params::UGameUserSettings_EnableHDRDisplayOutput_Params Parms{};

	Parms.bEnable = bEnable;
	Parms.DisplayNits = DisplayNits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.ConfirmVideoMode
// (Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::ConfirmVideoMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "ConfirmVideoMode");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.ApplySettings
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bCheckForCommandLineOverrides                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::ApplySettings(bool bCheckForCommandLineOverrides)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "ApplySettings");

	Params::UGameUserSettings_ApplySettings_Params Parms{};

	Parms.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.ApplyResolutionSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bCheckForCommandLineOverrides                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::ApplyResolutionSettings(bool bCheckForCommandLineOverrides)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "ApplyResolutionSettings");

	Params::UGameUserSettings_ApplyResolutionSettings_Params Parms{};

	Parms.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.ApplyNonResolutionSettings
// (Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::ApplyNonResolutionSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "ApplyNonResolutionSettings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameUserSettings.ApplyHardwareBenchmarkResults
// (Native, Public, BlueprintCallable)
// Parameters:

void UGameUserSettings::ApplyHardwareBenchmarkResults()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameUserSettings", "ApplyHardwareBenchmarkResults");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.DataTable
// (None)

class UClass* UDataTable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DataTable");

	return Clss;
}


// DataTable Engine.Default__DataTable
// (Public, ClassDefaultObject, ArchetypeObject)

class UDataTable* UDataTable::GetDefaultObj()
{
	static class UDataTable* Default = nullptr;

	if (!Default)
		Default = static_cast<UDataTable*>(UDataTable::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CameraComponent
// (SceneComponent)

class UClass* UCameraComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CameraComponent");

	return Clss;
}


// CameraComponent Engine.Default__CameraComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCameraComponent* UCameraComponent::GetDefaultObj()
{
	static class UCameraComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCameraComponent*>(UCameraComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CameraComponent.SetUseFieldOfViewForLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInUseFieldOfViewForLOD                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetUseFieldOfViewForLOD");

	Params::UCameraComponent_SetUseFieldOfViewForLOD_Params Parms{};

	Parms.bInUseFieldOfViewForLOD = bInUseFieldOfViewForLOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.SetProjectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ECameraProjectionMode   InProjectionMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetProjectionMode(enum class ECameraProjectionMode InProjectionMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetProjectionMode");

	Params::UCameraComponent_SetProjectionMode_Params Parms{};

	Parms.InProjectionMode = InProjectionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.SetPostProcessBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InPostProcessBlendWeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetPostProcessBlendWeight(float InPostProcessBlendWeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetPostProcessBlendWeight");

	Params::UCameraComponent_SetPostProcessBlendWeight_Params Parms{};

	Parms.InPostProcessBlendWeight = InPostProcessBlendWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.SetOrthoWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InOrthoWidth                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetOrthoWidth(float InOrthoWidth)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetOrthoWidth");

	Params::UCameraComponent_SetOrthoWidth_Params Parms{};

	Parms.InOrthoWidth = InOrthoWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.SetOrthoNearClipPlane
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InOrthoNearClipPlane                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetOrthoNearClipPlane(float InOrthoNearClipPlane)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetOrthoNearClipPlane");

	Params::UCameraComponent_SetOrthoNearClipPlane_Params Parms{};

	Parms.InOrthoNearClipPlane = InOrthoNearClipPlane;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.SetOrthoFarClipPlane
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InOrthoFarClipPlane                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetOrthoFarClipPlane(float InOrthoFarClipPlane)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetOrthoFarClipPlane");

	Params::UCameraComponent_SetOrthoFarClipPlane_Params Parms{};

	Parms.InOrthoFarClipPlane = InOrthoFarClipPlane;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.SetFieldOfView
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              InFieldOfView                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetFieldOfView(float InFieldOfView)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetFieldOfView");

	Params::UCameraComponent_SetFieldOfView_Params Parms{};

	Parms.InFieldOfView = InFieldOfView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.SetConstraintAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInConstrainAspectRatio                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetConstraintAspectRatio(bool bInConstrainAspectRatio)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetConstraintAspectRatio");

	Params::UCameraComponent_SetConstraintAspectRatio_Params Parms{};

	Parms.bInConstrainAspectRatio = bInConstrainAspectRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.SetAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InAspectRatio                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetAspectRatio(float InAspectRatio)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "SetAspectRatio");

	Params::UCameraComponent_SetAspectRatio_Params Parms{};

	Parms.InAspectRatio = InAspectRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.RemoveBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UCameraComponent::RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "RemoveBlendable");

	Params::UCameraComponent_RemoveBlendable_Params Parms{};

	Parms.InBlendableObject = InBlendableObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraComponent.GetCameraView
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMinimalViewInfo            DesiredView                                                      (Parm, OutParm, NativeAccessSpecifierPublic)

void UCameraComponent::GetCameraView(float DeltaTime, struct FMinimalViewInfo* DesiredView)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "GetCameraView");

	Params::UCameraComponent_GetCameraView_Params Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (DesiredView != nullptr)
		*DesiredView = std::move(Parms.DesiredView);

}


// Function Engine.CameraComponent.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                              InWeight                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraComponent", "AddOrUpdateBlendable");

	Params::UCameraComponent_AddOrUpdateBlendable_Params Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.AssetUserData
// (None)

class UClass* UAssetUserData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AssetUserData");

	return Clss;
}


// AssetUserData Engine.Default__AssetUserData
// (Public, ClassDefaultObject, ArchetypeObject)

class UAssetUserData* UAssetUserData::GetDefaultObj()
{
	static class UAssetUserData* Default = nullptr;

	if (!Default)
		Default = static_cast<UAssetUserData*>(UAssetUserData::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LevelScriptActor
// (Actor)

class UClass* ALevelScriptActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelScriptActor");

	return Clss;
}


// LevelScriptActor Engine.Default__LevelScriptActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ALevelScriptActor* ALevelScriptActor::GetDefaultObj()
{
	static class ALevelScriptActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ALevelScriptActor*>(ALevelScriptActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.LevelScriptActor.WorldOriginLocationChanged
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FIntVector                  OldOriginLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                  NewOriginLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelScriptActor::WorldOriginLocationChanged(const struct FIntVector& OldOriginLocation, const struct FIntVector& NewOriginLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelScriptActor", "WorldOriginLocationChanged");

	Params::ALevelScriptActor_WorldOriginLocationChanged_Params Parms{};

	Parms.OldOriginLocation = OldOriginLocation;
	Parms.NewOriginLocation = NewOriginLocation;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.LevelScriptActor.SetCinematicMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bCinematicMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bHidePlayer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsHUD                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsMovement                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAffectsTurning                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelScriptActor::SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelScriptActor", "SetCinematicMode");

	Params::ALevelScriptActor_SetCinematicMode_Params Parms{};

	Parms.bCinematicMode = bCinematicMode;
	Parms.bHidePlayer = bHidePlayer;
	Parms.bAffectsHUD = bAffectsHUD;
	Parms.bAffectsMovement = bAffectsMovement;
	Parms.bAffectsTurning = bAffectsTurning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LevelScriptActor.RemoteEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        EventName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelScriptActor::RemoteEvent(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelScriptActor", "RemoteEvent");

	Params::ALevelScriptActor_RemoteEvent_Params Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.LevelScriptActor.LevelReset
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:

void ALevelScriptActor::LevelReset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelScriptActor", "LevelReset");



	UObject::ProcessEvent(Func, nullptr);

}


// Class Engine.CharacterMovementComponent
// (None)

class UClass* UCharacterMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CharacterMovementComponent");

	return Clss;
}


// CharacterMovementComponent Engine.Default__CharacterMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCharacterMovementComponent* UCharacterMovementComponent::GetDefaultObj()
{
	static class UCharacterMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCharacterMovementComponent*>(UCharacterMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CharacterMovementComponent.SetWalkableFloorZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InWalkableFloorZ                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetWalkableFloorZ");

	Params::UCharacterMovementComponent_SetWalkableFloorZ_Params Parms{};

	Parms.InWalkableFloorZ = InWalkableFloorZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetWalkableFloorAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InWalkableFloorAngle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetWalkableFloorAngle");

	Params::UCharacterMovementComponent_SetWalkableFloorAngle_Params Parms{};

	Parms.InWalkableFloorAngle = InWalkableFloorAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetMovementMode
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EMovementMode           NewMovementMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              NewCustomMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetMovementMode(enum class EMovementMode NewMovementMode, uint8 NewCustomMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetMovementMode");

	Params::UCharacterMovementComponent_SetMovementMode_Params Parms{};

	Parms.NewMovementMode = NewMovementMode;
	Parms.NewCustomMode = NewCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetGroupsToIgnoreMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask           GroupMask                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetGroupsToIgnoreMask(struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetGroupsToIgnoreMask");

	Params::UCharacterMovementComponent_SetGroupsToIgnoreMask_Params Parms{};

	Parms.GroupMask = GroupMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetGroupsToIgnore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              GroupFlags                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetGroupsToIgnore(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetGroupsToIgnore");

	Params::UCharacterMovementComponent_SetGroupsToIgnore_Params Parms{};

	Parms.GroupFlags = GroupFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetGroupsToAvoidMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask           GroupMask                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetGroupsToAvoidMask(struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetGroupsToAvoidMask");

	Params::UCharacterMovementComponent_SetGroupsToAvoidMask_Params Parms{};

	Parms.GroupMask = GroupMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetGroupsToAvoid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              GroupFlags                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetGroupsToAvoid(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetGroupsToAvoid");

	Params::UCharacterMovementComponent_SetGroupsToAvoid_Params Parms{};

	Parms.GroupFlags = GroupFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetAvoidanceGroupMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask           GroupMask                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetAvoidanceGroupMask(struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetAvoidanceGroupMask");

	Params::UCharacterMovementComponent_SetAvoidanceGroupMask_Params Parms{};

	Parms.GroupMask = GroupMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetAvoidanceGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              GroupFlags                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetAvoidanceGroup(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetAvoidanceGroup");

	Params::UCharacterMovementComponent_SetAvoidanceGroup_Params Parms{};

	Parms.GroupFlags = GroupFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.SetAvoidanceEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetAvoidanceEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "SetAvoidanceEnabled");

	Params::UCharacterMovementComponent_SetAvoidanceEnabled_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::K2_GetWalkableFloorZ()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "K2_GetWalkableFloorZ");

	Params::UCharacterMovementComponent_K2_GetWalkableFloorZ_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::K2_GetWalkableFloorAngle()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "K2_GetWalkableFloorAngle");

	Params::UCharacterMovementComponent_K2_GetWalkableFloorAngle_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::K2_GetModifiedMaxAcceleration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "K2_GetModifiedMaxAcceleration");

	Params::UCharacterMovementComponent_K2_GetModifiedMaxAcceleration_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.K2_FindFloor
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     CapsuleLocation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFindFloorResult            FloorResult                                                      (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::K2_FindFloor(const struct FVector& CapsuleLocation, struct FFindFloorResult* FloorResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "K2_FindFloor");

	Params::UCharacterMovementComponent_K2_FindFloor_Params Parms{};

	Parms.CapsuleLocation = CapsuleLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (FloorResult != nullptr)
		*FloorResult = std::move(Parms.FloorResult);

}


// Function Engine.CharacterMovementComponent.K2_ComputeFloorDist
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     CapsuleLocation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LineDistance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SweepDistance                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SweepRadius                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFindFloorResult            FloorResult                                                      (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::K2_ComputeFloorDist(const struct FVector& CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, struct FFindFloorResult* FloorResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "K2_ComputeFloorDist");

	Params::UCharacterMovementComponent_K2_ComputeFloorDist_Params Parms{};

	Parms.CapsuleLocation = CapsuleLocation;
	Parms.LineDistance = LineDistance;
	Parms.SweepDistance = SweepDistance;
	Parms.SweepRadius = SweepRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (FloorResult != nullptr)
		*FloorResult = std::move(Parms.FloorResult);

}


// Function Engine.CharacterMovementComponent.IsWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterMovementComponent::IsWalking()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "IsWalking");

	Params::UCharacterMovementComponent_IsWalking_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.IsWalkable
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterMovementComponent::IsWalkable(struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "IsWalkable");

	Params::UCharacterMovementComponent_IsWalkable_Params Parms{};

	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetValidPerchRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetValidPerchRadius()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetValidPerchRadius");

	Params::UCharacterMovementComponent_GetValidPerchRadius_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetPerchRadiusThreshold()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetPerchRadiusThreshold");

	Params::UCharacterMovementComponent_GetPerchRadiusThreshold_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetMovementBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*         ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UCharacterMovementComponent::GetMovementBase()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetMovementBase");

	Params::UCharacterMovementComponent_GetMovementBase_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetMinAnalogSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMinAnalogSpeed()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetMinAnalogSpeed");

	Params::UCharacterMovementComponent_GetMinAnalogSpeed_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetMaxJumpHeightWithJumpTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMaxJumpHeightWithJumpTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetMaxJumpHeightWithJumpTime");

	Params::UCharacterMovementComponent_GetMaxJumpHeightWithJumpTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetMaxJumpHeight
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMaxJumpHeight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetMaxJumpHeight");

	Params::UCharacterMovementComponent_GetMaxJumpHeight_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetMaxBrakingDeceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMaxBrakingDeceleration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetMaxBrakingDeceleration");

	Params::UCharacterMovementComponent_GetMaxBrakingDeceleration_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetMaxAcceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMaxAcceleration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetMaxAcceleration");

	Params::UCharacterMovementComponent_GetMaxAcceleration_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetLastUpdateVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterMovementComponent::GetLastUpdateVelocity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetLastUpdateVelocity");

	Params::UCharacterMovementComponent_GetLastUpdateVelocity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetLastUpdateRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UCharacterMovementComponent::GetLastUpdateRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetLastUpdateRotation");

	Params::UCharacterMovementComponent_GetLastUpdateRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetLastUpdateLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterMovementComponent::GetLastUpdateLocation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetLastUpdateLocation");

	Params::UCharacterMovementComponent_GetLastUpdateLocation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterMovementComponent::GetImpartedMovementBaseVelocity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetImpartedMovementBaseVelocity");

	Params::UCharacterMovementComponent_GetImpartedMovementBaseVelocity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetCurrentAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterMovementComponent::GetCurrentAcceleration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetCurrentAcceleration");

	Params::UCharacterMovementComponent_GetCurrentAcceleration_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetCharacterOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UCharacterMovementComponent::GetCharacterOwner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetCharacterOwner");

	Params::UCharacterMovementComponent_GetCharacterOwner_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.GetAnalogInputModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetAnalogInputModifier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "GetAnalogInputModifier");

	Params::UCharacterMovementComponent_GetAnalogInputModifier_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CharacterMovementComponent.DisableMovement
// (Native, Public, BlueprintCallable)
// Parameters:

void UCharacterMovementComponent::DisableMovement()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "DisableMovement");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.ClearAccumulatedForces
// (Native, Public, BlueprintCallable)
// Parameters:

void UCharacterMovementComponent::ClearAccumulatedForces()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "ClearAccumulatedForces");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.CapsuleTouched
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*         OverlappedComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Other                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         OtherComp                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OtherBodyIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFromSweep                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  SweepResult                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "CapsuleTouched");

	Params::UCharacterMovementComponent_CapsuleTouched_Params Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = SweepResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.CalcVelocity
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Friction                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFluid                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BrakingDeceleration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "CalcVelocity");

	Params::UCharacterMovementComponent_CalcVelocity_Params Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Friction = Friction;
	Parms.bFluid = bFluid;
	Parms.BrakingDeceleration = BrakingDeceleration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.AddImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Impulse                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bVelocityChange                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::AddImpulse(const struct FVector& Impulse, bool bVelocityChange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "AddImpulse");

	Params::UCharacterMovementComponent_AddImpulse_Params Parms{};

	Parms.Impulse = Impulse;
	Parms.bVelocityChange = bVelocityChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CharacterMovementComponent.AddForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Force                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::AddForce(const struct FVector& Force)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CharacterMovementComponent", "AddForce");

	Params::UCharacterMovementComponent_AddForce_Params Parms{};

	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.ShapeComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UShapeComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ShapeComponent");

	return Clss;
}


// ShapeComponent Engine.Default__ShapeComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UShapeComponent* UShapeComponent::GetDefaultObj()
{
	static class UShapeComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UShapeComponent*>(UShapeComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BoxComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UBoxComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BoxComponent");

	return Clss;
}


// BoxComponent Engine.Default__BoxComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UBoxComponent* UBoxComponent::GetDefaultObj()
{
	static class UBoxComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UBoxComponent*>(UBoxComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.BoxComponent.SetBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InBoxExtent                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateOverlaps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBoxComponent::SetBoxExtent(const struct FVector& InBoxExtent, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BoxComponent", "SetBoxExtent");

	Params::UBoxComponent_SetBoxExtent_Params Parms{};

	Parms.InBoxExtent = InBoxExtent;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BoxComponent.GetUnscaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBoxComponent::GetUnscaledBoxExtent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BoxComponent", "GetUnscaledBoxExtent");

	Params::UBoxComponent_GetUnscaledBoxExtent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BoxComponent.GetScaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBoxComponent::GetScaledBoxExtent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BoxComponent", "GetScaledBoxExtent");

	Params::UBoxComponent_GetScaledBoxExtent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.NavLinkDefinition
// (None)

class UClass* UNavLinkDefinition::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavLinkDefinition");

	return Clss;
}


// NavLinkDefinition Engine.Default__NavLinkDefinition
// (Public, ClassDefaultObject, ArchetypeObject)

class UNavLinkDefinition* UNavLinkDefinition::GetDefaultObj()
{
	static class UNavLinkDefinition* Default = nullptr;

	if (!Default)
		Default = static_cast<UNavLinkDefinition*>(UNavLinkDefinition::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LocalMessage
// (None)

class UClass* ULocalMessage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LocalMessage");

	return Clss;
}


// LocalMessage Engine.Default__LocalMessage
// (Public, ClassDefaultObject, ArchetypeObject)

class ULocalMessage* ULocalMessage::GetDefaultObj()
{
	static class ULocalMessage* Default = nullptr;

	if (!Default)
		Default = static_cast<ULocalMessage*>(ULocalMessage::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavigationObjectBase
// (Actor)

class UClass* ANavigationObjectBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavigationObjectBase");

	return Clss;
}


// NavigationObjectBase Engine.Default__NavigationObjectBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ANavigationObjectBase* ANavigationObjectBase::GetDefaultObj()
{
	static class ANavigationObjectBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ANavigationObjectBase*>(ANavigationObjectBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PlayerInput
// (None)

class UClass* UPlayerInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerInput");

	return Clss;
}


// PlayerInput Engine.Default__PlayerInput
// (Public, Transactional, ClassDefaultObject, ArchetypeObject)

class UPlayerInput* UPlayerInput::GetDefaultObj()
{
	static class UPlayerInput* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlayerInput*>(UPlayerInput::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PlayerInput.SetMouseSensitivity
// (Final, Exec, Native, Public)
// Parameters:
// float                              Sensitivity                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInput::SetMouseSensitivity(float Sensitivity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerInput", "SetMouseSensitivity");

	Params::UPlayerInput_SetMouseSensitivity_Params Parms{};

	Parms.Sensitivity = Sensitivity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerInput.SetBind
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        BindName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Command                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInput::SetBind(class FName BindName, const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerInput", "SetBind");

	Params::UPlayerInput_SetBind_Params Parms{};

	Parms.BindName = BindName;
	Parms.Command = Command;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerInput.InvertAxisKey
// (Final, Exec, Native, Public)
// Parameters:
// struct FKey                        AxisKey                                                          (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInput::InvertAxisKey(const struct FKey& AxisKey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerInput", "InvertAxisKey");

	Params::UPlayerInput_InvertAxisKey_Params Parms{};

	Parms.AxisKey = AxisKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerInput.InvertAxis
// (Final, Exec, Native, Public)
// Parameters:
// class FName                        AxisName                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInput::InvertAxis(class FName AxisName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerInput", "InvertAxis");

	Params::UPlayerInput_InvertAxis_Params Parms{};

	Parms.AxisName = AxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerInput.ClearSmoothing
// (Final, Exec, Native, Public)
// Parameters:

void UPlayerInput::ClearSmoothing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerInput", "ClearSmoothing");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SkeletalMeshActor
// (Actor)

class UClass* ASkeletalMeshActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkeletalMeshActor");

	return Clss;
}


// SkeletalMeshActor Engine.Default__SkeletalMeshActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ASkeletalMeshActor* ASkeletalMeshActor::GetDefaultObj()
{
	static class ASkeletalMeshActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ASkeletalMeshActor*>(ASkeletalMeshActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset
// (Native, Public)
// Parameters:

void ASkeletalMeshActor::OnRep_ReplicatedPhysAsset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshActor", "OnRep_ReplicatedPhysAsset");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh
// (Native, Public)
// Parameters:

void ASkeletalMeshActor::OnRep_ReplicatedMesh()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshActor", "OnRep_ReplicatedMesh");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1
// (Native, Public)
// Parameters:

void ASkeletalMeshActor::OnRep_ReplicatedMaterial1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshActor", "OnRep_ReplicatedMaterial1");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0
// (Native, Public)
// Parameters:

void ASkeletalMeshActor::OnRep_ReplicatedMaterial0()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshActor", "OnRep_ReplicatedMaterial0");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PlayerStart
// (Actor)

class UClass* APlayerStart::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerStart");

	return Clss;
}


// PlayerStart Engine.Default__PlayerStart
// (Public, ClassDefaultObject, ArchetypeObject)

class APlayerStart* APlayerStart::GetDefaultObj()
{
	static class APlayerStart* Default = nullptr;

	if (!Default)
		Default = static_cast<APlayerStart*>(APlayerStart::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PlayerState
// (Actor)

class UClass* APlayerState::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerState");

	return Clss;
}


// PlayerState Engine.Default__PlayerState
// (Public, ClassDefaultObject, ArchetypeObject)

class APlayerState* APlayerState::GetDefaultObj()
{
	static class APlayerState* Default = nullptr;

	if (!Default)
		Default = static_cast<APlayerState*>(APlayerState::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PlayerState.ReceiveOverrideWith
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerState*                OldPlayerState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerState::ReceiveOverrideWith(class APlayerState* OldPlayerState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerState", "ReceiveOverrideWith");

	Params::APlayerState_ReceiveOverrideWith_Params Parms{};

	Parms.OldPlayerState = OldPlayerState;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.PlayerState.ReceiveCopyProperties
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerState*                NewPlayerState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerState::ReceiveCopyProperties(class APlayerState* NewPlayerState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerState", "ReceiveCopyProperties");

	Params::APlayerState_ReceiveCopyProperties_Params Parms{};

	Parms.NewPlayerState = NewPlayerState;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.PlayerState.OnRep_UniqueId
// (Native, Public)
// Parameters:

void APlayerState::OnRep_UniqueId()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerState", "OnRep_UniqueId");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerState.OnRep_Score
// (Native, Public)
// Parameters:

void APlayerState::OnRep_Score()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerState", "OnRep_Score");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerState.OnRep_PlayerName
// (Native, Public)
// Parameters:

void APlayerState::OnRep_PlayerName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerState", "OnRep_PlayerName");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerState.OnRep_PlayerId
// (Native, Public)
// Parameters:

void APlayerState::OnRep_PlayerId()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerState", "OnRep_PlayerId");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerState.OnRep_bIsInactive
// (Native, Public)
// Parameters:

void APlayerState::OnRep_bIsInactive()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerState", "OnRep_bIsInactive");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PlayerState.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APlayerState::GetPlayerName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlayerState", "GetPlayerName");

	Params::APlayerState_GetPlayerName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.RuntimeOptionsBase
// (None)

class UClass* URuntimeOptionsBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RuntimeOptionsBase");

	return Clss;
}


// RuntimeOptionsBase Engine.Default__RuntimeOptionsBase
// (Public, ClassDefaultObject, ArchetypeObject)

class URuntimeOptionsBase* URuntimeOptionsBase::GetDefaultObj()
{
	static class URuntimeOptionsBase* Default = nullptr;

	if (!Default)
		Default = static_cast<URuntimeOptionsBase*>(URuntimeOptionsBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AudioComponent
// (SceneComponent)

class UClass* UAudioComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AudioComponent");

	return Clss;
}


// AudioComponent Engine.Default__AudioComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UAudioComponent* UAudioComponent::GetDefaultObj()
{
	static class UAudioComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UAudioComponent*>(UAudioComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AudioComponent.StopDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              DelayTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::StopDelayed(float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "StopDelayed");

	Params::UAudioComponent_StopDelayed_Params Parms{};

	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.Stop
// (Native, Public, BlueprintCallable)
// Parameters:

void UAudioComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "Stop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetWaveParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                  InWave                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetWaveParameter(class FName InName, class USoundWave* InWave)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetWaveParameter");

	Params::UAudioComponent_SetWaveParameter_Params Parms{};

	Parms.InName = InName;
	Parms.InWave = InWave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetVolumeMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewVolumeMultiplier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetVolumeMultiplier(float NewVolumeMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetVolumeMultiplier");

	Params::UAudioComponent_SetVolumeMultiplier_Params Parms{};

	Parms.NewVolumeMultiplier = NewVolumeMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetUISound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInUISound                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetUISound(bool bInUISound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetUISound");

	Params::UAudioComponent_SetUISound_Params Parms{};

	Parms.bInUISound = bInUISound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetSubmixSend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundSubmix*                Submix                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SendLevel                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetSubmixSend(class USoundSubmix* Submix, float SendLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetSubmixSend");

	Params::UAudioComponent_SetSubmixSend_Params Parms{};

	Parms.Submix = Submix;
	Parms.SendLevel = SendLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetSourceBusSendPreEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundSourceBus*             SoundSourceBus                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SourceBusSendLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetSourceBusSendPreEffect(class USoundSourceBus* SoundSourceBus, float SourceBusSendLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetSourceBusSendPreEffect");

	Params::UAudioComponent_SetSourceBusSendPreEffect_Params Parms{};

	Parms.SoundSourceBus = SoundSourceBus;
	Parms.SourceBusSendLevel = SourceBusSendLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetSourceBusSendPostEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundSourceBus*             SoundSourceBus                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SourceBusSendLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetSourceBusSendPostEffect(class USoundSourceBus* SoundSourceBus, float SourceBusSendLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetSourceBusSendPostEffect");

	Params::UAudioComponent_SetSourceBusSendPostEffect_Params Parms{};

	Parms.SoundSourceBus = SoundSourceBus;
	Parms.SourceBusSendLevel = SourceBusSendLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                  NewSound                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetSound(class USoundBase* NewSound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetSound");

	Params::UAudioComponent_SetSound_Params Parms{};

	Parms.NewSound = NewSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetPitchMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewPitchMultiplier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetPitchMultiplier(float NewPitchMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetPitchMultiplier");

	Params::UAudioComponent_SetPitchMultiplier_Params Parms{};

	Parms.NewPitchMultiplier = NewPitchMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bPause                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetPaused(bool bPause)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetPaused");

	Params::UAudioComponent_SetPaused_Params Parms{};

	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetLowPassFilterFrequency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InLowPassFilterFrequency                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetLowPassFilterFrequency(float InLowPassFilterFrequency)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetLowPassFilterFrequency");

	Params::UAudioComponent_SetLowPassFilterFrequency_Params Parms{};

	Parms.InLowPassFilterFrequency = InLowPassFilterFrequency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetLowPassFilterEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               InLowPassFilterEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetLowPassFilterEnabled(bool InLowPassFilterEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetLowPassFilterEnabled");

	Params::UAudioComponent_SetLowPassFilterEnabled_Params Parms{};

	Parms.InLowPassFilterEnabled = InLowPassFilterEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetIntParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InInt                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetIntParameter(class FName InName, int32 InInt)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetIntParameter");

	Params::UAudioComponent_SetIntParameter_Params Parms{};

	Parms.InName = InName;
	Parms.InInt = InInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetFloatParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetFloatParameter(class FName InName, float InFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetFloatParameter");

	Params::UAudioComponent_SetFloatParameter_Params Parms{};

	Parms.InName = InName;
	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.SetBoolParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InBool                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetBoolParameter(class FName InName, bool InBool)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "SetBoolParameter");

	Params::UAudioComponent_SetBoolParameter_Params Parms{};

	Parms.InName = InName;
	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.Play
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::Play(float StartTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "Play");

	Params::UAudioComponent_Play_Params Parms{};

	Parms.StartTime = StartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.IsPlaying
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::IsPlaying()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "IsPlaying");

	Params::UAudioComponent_IsPlaying_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AudioComponent.HasCookedFFTData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::HasCookedFFTData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "HasCookedFFTData");

	Params::UAudioComponent_HasCookedFFTData_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AudioComponent.HasCookedAmplitudeEnvelopeData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::HasCookedAmplitudeEnvelopeData()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "HasCookedAmplitudeEnvelopeData");

	Params::UAudioComponent_HasCookedAmplitudeEnvelopeData_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AudioComponent.GetCookedFFTDataForAllPlayingSounds
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSoundWaveSpectralDataPerSound>OutSoundWaveSpectralData                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::GetCookedFFTDataForAllPlayingSounds(TArray<struct FSoundWaveSpectralDataPerSound>* OutSoundWaveSpectralData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "GetCookedFFTDataForAllPlayingSounds");

	Params::UAudioComponent_GetCookedFFTDataForAllPlayingSounds_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSoundWaveSpectralData != nullptr)
		*OutSoundWaveSpectralData = std::move(Parms.OutSoundWaveSpectralData);

	return Parms.ReturnValue;

}


// Function Engine.AudioComponent.GetCookedFFTData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                      FrequenciesToGet                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FSoundWaveSpectralData>OutSoundWaveSpectralData                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::GetCookedFFTData(TArray<float>& FrequenciesToGet, TArray<struct FSoundWaveSpectralData>* OutSoundWaveSpectralData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "GetCookedFFTData");

	Params::UAudioComponent_GetCookedFFTData_Params Parms{};

	Parms.FrequenciesToGet = FrequenciesToGet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSoundWaveSpectralData != nullptr)
		*OutSoundWaveSpectralData = std::move(Parms.OutSoundWaveSpectralData);

	return Parms.ReturnValue;

}


// Function Engine.AudioComponent.GetCookedEnvelopeDataForAllPlayingSounds
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSoundWaveEnvelopeDataPerSound>OutEnvelopeData                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::GetCookedEnvelopeDataForAllPlayingSounds(TArray<struct FSoundWaveEnvelopeDataPerSound>* OutEnvelopeData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "GetCookedEnvelopeDataForAllPlayingSounds");

	Params::UAudioComponent_GetCookedEnvelopeDataForAllPlayingSounds_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutEnvelopeData != nullptr)
		*OutEnvelopeData = std::move(Parms.OutEnvelopeData);

	return Parms.ReturnValue;

}


// Function Engine.AudioComponent.GetCookedEnvelopeData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                              OutEnvelopeData                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::GetCookedEnvelopeData(float* OutEnvelopeData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "GetCookedEnvelopeData");

	Params::UAudioComponent_GetCookedEnvelopeData_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutEnvelopeData != nullptr)
		*OutEnvelopeData = Parms.OutEnvelopeData;

	return Parms.ReturnValue;

}


// Function Engine.AudioComponent.FadeOut
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              FadeOutDuration                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FadeVolumeLevel                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::FadeOut(float FadeOutDuration, float FadeVolumeLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "FadeOut");

	Params::UAudioComponent_FadeOut_Params Parms{};

	Parms.FadeOutDuration = FadeOutDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.FadeIn
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              FadeInDuration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FadeVolumeLevel                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "FadeIn");

	Params::UAudioComponent_FadeIn_Params Parms{};

	Parms.FadeInDuration = FadeInDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;
	Parms.StartTime = StartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSoundAttenuationSettings   OutAttenuationSettings                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::BP_GetAttenuationSettingsToApply(struct FSoundAttenuationSettings* OutAttenuationSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "BP_GetAttenuationSettingsToApply");

	Params::UAudioComponent_BP_GetAttenuationSettingsToApply_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutAttenuationSettings != nullptr)
		*OutAttenuationSettings = std::move(Parms.OutAttenuationSettings);

	return Parms.ReturnValue;

}


// Function Engine.AudioComponent.AdjustVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              AdjustVolumeDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AdjustVolumeLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "AdjustVolume");

	Params::UAudioComponent_AdjustVolume_Params Parms{};

	Parms.AdjustVolumeDuration = AdjustVolumeDuration;
	Parms.AdjustVolumeLevel = AdjustVolumeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioComponent.AdjustAttenuation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSoundAttenuationSettings   InAttenuationSettings                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAudioComponent::AdjustAttenuation(struct FSoundAttenuationSettings& InAttenuationSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioComponent", "AdjustAttenuation");

	Params::UAudioComponent_AdjustAttenuation_Params Parms{};

	Parms.InAttenuationSettings = InAttenuationSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.WorldSettings
// (Actor)

class UClass* AWorldSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WorldSettings");

	return Clss;
}


// WorldSettings Engine.Default__WorldSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class AWorldSettings* AWorldSettings::GetDefaultObj()
{
	static class AWorldSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<AWorldSettings*>(AWorldSettings::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.WorldSettings.OnRep_WorldGravityZ
// (Native, Public)
// Parameters:

void AWorldSettings::OnRep_WorldGravityZ()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WorldSettings", "OnRep_WorldGravityZ");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PhysicsVolume
// (Actor)

class UClass* APhysicsVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsVolume");

	return Clss;
}


// PhysicsVolume Engine.Default__PhysicsVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class APhysicsVolume* APhysicsVolume::GetDefaultObj()
{
	static class APhysicsVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<APhysicsVolume*>(APhysicsVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.FloatingPawnMovement
// (None)

class UClass* UFloatingPawnMovement::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FloatingPawnMovement");

	return Clss;
}


// FloatingPawnMovement Engine.Default__FloatingPawnMovement
// (Public, ClassDefaultObject, ArchetypeObject)

class UFloatingPawnMovement* UFloatingPawnMovement::GetDefaultObj()
{
	static class UFloatingPawnMovement* Default = nullptr;

	if (!Default)
		Default = static_cast<UFloatingPawnMovement*>(UFloatingPawnMovement::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SpectatorPawnMovement
// (None)

class UClass* USpectatorPawnMovement::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpectatorPawnMovement");

	return Clss;
}


// SpectatorPawnMovement Engine.Default__SpectatorPawnMovement
// (Public, ClassDefaultObject, ArchetypeObject)

class USpectatorPawnMovement* USpectatorPawnMovement::GetDefaultObj()
{
	static class USpectatorPawnMovement* Default = nullptr;

	if (!Default)
		Default = static_cast<USpectatorPawnMovement*>(USpectatorPawnMovement::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SkyLight
// (Actor)

class UClass* ASkyLight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkyLight");

	return Clss;
}


// SkyLight Engine.Default__SkyLight
// (Public, ClassDefaultObject, ArchetypeObject)

class ASkyLight* ASkyLight::GetDefaultObj()
{
	static class ASkyLight* Default = nullptr;

	if (!Default)
		Default = static_cast<ASkyLight*>(ASkyLight::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SkyLight.OnRep_bEnabled
// (Native, Public)
// Parameters:

void ASkyLight::OnRep_bEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLight", "OnRep_bEnabled");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.StreamableRenderAsset
// (None)

class UClass* UStreamableRenderAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StreamableRenderAsset");

	return Clss;
}


// StreamableRenderAsset Engine.Default__StreamableRenderAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UStreamableRenderAsset* UStreamableRenderAsset::GetDefaultObj()
{
	static class UStreamableRenderAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UStreamableRenderAsset*>(UStreamableRenderAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Texture
// (None)

class UClass* UTexture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Texture");

	return Clss;
}


// Texture Engine.Default__Texture
// (Public, ClassDefaultObject, ArchetypeObject)

class UTexture* UTexture::GetDefaultObj()
{
	static class UTexture* Default = nullptr;

	if (!Default)
		Default = static_cast<UTexture*>(UTexture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TextureCube
// (None)

class UClass* UTextureCube::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextureCube");

	return Clss;
}


// TextureCube Engine.Default__TextureCube
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextureCube* UTextureCube::GetDefaultObj()
{
	static class UTextureCube* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextureCube*>(UTextureCube::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InstancedStaticMeshComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UInstancedStaticMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InstancedStaticMeshComponent");

	return Clss;
}


// InstancedStaticMeshComponent Engine.Default__InstancedStaticMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UInstancedStaticMeshComponent* UInstancedStaticMeshComponent::GetDefaultObj()
{
	static class UInstancedStaticMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UInstancedStaticMeshComponent*>(UInstancedStaticMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              InstanceIndex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  NewInstanceTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bWorldSpace                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bMarkRenderStateDirty                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::UpdateInstanceTransform(int32 InstanceIndex, struct FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "UpdateInstanceTransform");

	Params::UInstancedStaticMeshComponent_UpdateInstanceTransform_Params Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.NewInstanceTransform = NewInstanceTransform;
	Parms.bWorldSpace = bWorldSpace;
	Parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.SetCullDistances
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              StartCullDistance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              EndCullDistance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInstancedStaticMeshComponent::SetCullDistances(int32 StartCullDistance, int32 EndCullDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "SetCullDistances");

	Params::UInstancedStaticMeshComponent_SetCullDistances_Params Parms{};

	Parms.StartCullDistance = StartCullDistance;
	Parms.EndCullDistance = EndCullDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.InstancedStaticMeshComponent.RemoveInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              InstanceIndex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::RemoveInstance(int32 InstanceIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "RemoveInstance");

	Params::UInstancedStaticMeshComponent_RemoveInstance_Params Parms{};

	Parms.InstanceIndex = InstanceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.GetInstanceTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              InstanceIndex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  OutInstanceTransform                                             (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bWorldSpace                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::GetInstanceTransform(int32 InstanceIndex, struct FTransform* OutInstanceTransform, bool bWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "GetInstanceTransform");

	Params::UInstancedStaticMeshComponent_GetInstanceTransform_Params Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.bWorldSpace = bWorldSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutInstanceTransform != nullptr)
		*OutInstanceTransform = std::move(Parms.OutInstanceTransform);

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     Center                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSphereInWorldSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UInstancedStaticMeshComponent::GetInstancesOverlappingSphere(struct FVector& Center, float Radius, bool bSphereInWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "GetInstancesOverlappingSphere");

	Params::UInstancedStaticMeshComponent_GetInstancesOverlappingSphere_Params Parms{};

	Parms.Center = Center;
	Parms.Radius = Radius;
	Parms.bSphereInWorldSpace = bSphereInWorldSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingBox
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                        Box                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bBoxInWorldSpace                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UInstancedStaticMeshComponent::GetInstancesOverlappingBox(struct FBox& Box, bool bBoxInWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "GetInstancesOverlappingBox");

	Params::UInstancedStaticMeshComponent_GetInstancesOverlappingBox_Params Parms{};

	Parms.Box = Box;
	Parms.bBoxInWorldSpace = bBoxInWorldSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.GetInstanceCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInstancedStaticMeshComponent::GetInstanceCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "GetInstanceCount");

	Params::UInstancedStaticMeshComponent_GetInstanceCount_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.ClearInstances
// (Native, Public, BlueprintCallable)
// Parameters:

void UInstancedStaticMeshComponent::ClearInstances()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "ClearInstances");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransforms
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              StartInstanceIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>          NewInstancesTransforms                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bWorldSpace                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bMarkRenderStateDirty                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::BatchUpdateInstancesTransforms(int32 StartInstanceIndex, TArray<struct FTransform>& NewInstancesTransforms, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "BatchUpdateInstancesTransforms");

	Params::UInstancedStaticMeshComponent_BatchUpdateInstancesTransforms_Params Parms{};

	Parms.StartInstanceIndex = StartInstanceIndex;
	Parms.NewInstancesTransforms = NewInstancesTransforms;
	Parms.bWorldSpace = bWorldSpace;
	Parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              StartInstanceIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumInstances                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  NewInstancesTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bWorldSpace                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bMarkRenderStateDirty                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTeleport                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::BatchUpdateInstancesTransform(int32 StartInstanceIndex, int32 NumInstances, struct FTransform& NewInstancesTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "BatchUpdateInstancesTransform");

	Params::UInstancedStaticMeshComponent_BatchUpdateInstancesTransform_Params Parms{};

	Parms.StartInstanceIndex = StartInstanceIndex;
	Parms.NumInstances = NumInstances;
	Parms.NewInstancesTransform = NewInstancesTransform;
	Parms.bWorldSpace = bWorldSpace;
	Parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	Parms.bTeleport = bTeleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  WorldTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInstancedStaticMeshComponent::AddInstanceWorldSpace(struct FTransform& WorldTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "AddInstanceWorldSpace");

	Params::UInstancedStaticMeshComponent_AddInstanceWorldSpace_Params Parms{};

	Parms.WorldTransform = WorldTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InstancedStaticMeshComponent.AddInstance
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                  InstanceTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInstancedStaticMeshComponent::AddInstance(struct FTransform& InstanceTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InstancedStaticMeshComponent", "AddInstance");

	Params::UInstancedStaticMeshComponent_AddInstance_Params Parms{};

	Parms.InstanceTransform = InstanceTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.HierarchicalInstancedStaticMeshComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* UHierarchicalInstancedStaticMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HierarchicalInstancedStaticMeshComponent");

	return Clss;
}


// HierarchicalInstancedStaticMeshComponent Engine.Default__HierarchicalInstancedStaticMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UHierarchicalInstancedStaticMeshComponent* UHierarchicalInstancedStaticMeshComponent::GetDefaultObj()
{
	static class UHierarchicalInstancedStaticMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UHierarchicalInstancedStaticMeshComponent*>(UHierarchicalInstancedStaticMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.HierarchicalInstancedStaticMeshComponent.RemoveInstances
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      InstancesToRemove                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHierarchicalInstancedStaticMeshComponent::RemoveInstances(TArray<int32>& InstancesToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HierarchicalInstancedStaticMeshComponent", "RemoveInstances");

	Params::UHierarchicalInstancedStaticMeshComponent_RemoveInstances_Params Parms{};

	Parms.InstancesToRemove = InstancesToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.MaterialInterface
// (None)

class UClass* UMaterialInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialInterface");

	return Clss;
}


// MaterialInterface Engine.Default__MaterialInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialInterface* UMaterialInterface::GetDefaultObj()
{
	static class UMaterialInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialInterface*>(UMaterialInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.MaterialInterface.SetForceMipLevelsToBeResident
// (RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                               OverrideForceMiplevelsToBeResident                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForceMiplevelsToBeResidentValue                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ForceDuration                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              CinematicTextureGroups                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInterface::SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInterface", "SetForceMipLevelsToBeResident");

	Params::UMaterialInterface_SetForceMipLevelsToBeResident_Params Parms{};

	Parms.OverrideForceMiplevelsToBeResident = OverrideForceMiplevelsToBeResident;
	Parms.bForceMiplevelsToBeResidentValue = bForceMiplevelsToBeResidentValue;
	Parms.ForceDuration = ForceDuration;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MaterialInterface.GetPhysicalMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPhysicalMaterial*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* UMaterialInterface::GetPhysicalMaterial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInterface", "GetPhysicalMaterial");

	Params::UMaterialInterface_GetPhysicalMaterial_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MaterialInterface.GetBaseMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterial*                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterial* UMaterialInterface::GetBaseMaterial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInterface", "GetBaseMaterial");

	Params::UMaterialInterface_GetBaseMaterial_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.MaterialInstance
// (None)

class UClass* UMaterialInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialInstance");

	return Clss;
}


// MaterialInstance Engine.Default__MaterialInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialInstance* UMaterialInstance::GetDefaultObj()
{
	static class UMaterialInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialInstance*>(UMaterialInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialInstanceConstant
// (None)

class UClass* UMaterialInstanceConstant::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialInstanceConstant");

	return Clss;
}


// MaterialInstanceConstant Engine.Default__MaterialInstanceConstant
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialInstanceConstant* UMaterialInstanceConstant::GetDefaultObj()
{
	static class UMaterialInstanceConstant* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialInstanceConstant*>(UMaterialInstanceConstant::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.MaterialInstanceConstant.K2_GetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UMaterialInstanceConstant::K2_GetVectorParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceConstant", "K2_GetVectorParameterValue");

	Params::UMaterialInstanceConstant_K2_GetVectorParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MaterialInstanceConstant.K2_GetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UMaterialInstanceConstant::K2_GetTextureParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceConstant", "K2_GetTextureParameterValue");

	Params::UMaterialInstanceConstant_K2_GetTextureParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MaterialInstanceConstant.K2_GetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaterialInstanceConstant::K2_GetScalarParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceConstant", "K2_GetScalarParameterValue");

	Params::UMaterialInstanceConstant_K2_GetScalarParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.MaterialExpressionCustomOutput
// (None)

class UClass* UMaterialExpressionCustomOutput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCustomOutput");

	return Clss;
}


// MaterialExpressionCustomOutput Engine.Default__MaterialExpressionCustomOutput
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCustomOutput* UMaterialExpressionCustomOutput::GetDefaultObj()
{
	static class UMaterialExpressionCustomOutput* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCustomOutput*>(UMaterialExpressionCustomOutput::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EngineCustomTimeStep
// (None)

class UClass* UEngineCustomTimeStep::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EngineCustomTimeStep");

	return Clss;
}


// EngineCustomTimeStep Engine.Default__EngineCustomTimeStep
// (Public, ClassDefaultObject, ArchetypeObject)

class UEngineCustomTimeStep* UEngineCustomTimeStep::GetDefaultObj()
{
	static class UEngineCustomTimeStep* Default = nullptr;

	if (!Default)
		Default = static_cast<UEngineCustomTimeStep*>(UEngineCustomTimeStep::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DynamicBlueprintBinding
// (None)

class UClass* UDynamicBlueprintBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DynamicBlueprintBinding");

	return Clss;
}


// DynamicBlueprintBinding Engine.Default__DynamicBlueprintBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UDynamicBlueprintBinding* UDynamicBlueprintBinding::GetDefaultObj()
{
	static class UDynamicBlueprintBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UDynamicBlueprintBinding*>(UDynamicBlueprintBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundBase
// (None)

class UClass* USoundBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundBase");

	return Clss;
}


// SoundBase Engine.Default__SoundBase
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundBase* USoundBase::GetDefaultObj()
{
	static class USoundBase* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundBase*>(USoundBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundWave
// (None)

class UClass* USoundWave::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundWave");

	return Clss;
}


// SoundWave Engine.Default__SoundWave
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundWave* USoundWave::GetDefaultObj()
{
	static class USoundWave* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundWave*>(USoundWave::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundWaveProcedural
// (None)

class UClass* USoundWaveProcedural::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundWaveProcedural");

	return Clss;
}


// SoundWaveProcedural Engine.Default__SoundWaveProcedural
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundWaveProcedural* USoundWaveProcedural::GetDefaultObj()
{
	static class USoundWaveProcedural* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundWaveProcedural*>(USoundWaveProcedural::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Model
// (None)

class UClass* UModel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Model");

	return Clss;
}


// Model Engine.Default__Model
// (Public, ClassDefaultObject, ArchetypeObject)

class UModel* UModel::GetDefaultObj()
{
	static class UModel* Default = nullptr;

	if (!Default)
		Default = static_cast<UModel*>(UModel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ActorChannel
// (None)

class UClass* UActorChannel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ActorChannel");

	return Clss;
}


// ActorChannel Engine.Default__ActorChannel
// (Public, ClassDefaultObject, ArchetypeObject)

class UActorChannel* UActorChannel::GetDefaultObj()
{
	static class UActorChannel* Default = nullptr;

	if (!Default)
		Default = static_cast<UActorChannel*>(UActorChannel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimationAsset
// (None)

class UClass* UAnimationAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimationAsset");

	return Clss;
}


// AnimationAsset Engine.Default__AnimationAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimationAsset* UAnimationAsset::GetDefaultObj()
{
	static class UAnimationAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimationAsset*>(UAnimationAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlendSpaceBase
// (None)

class UClass* UBlendSpaceBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlendSpaceBase");

	return Clss;
}


// BlendSpaceBase Engine.Default__BlendSpaceBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlendSpaceBase* UBlendSpaceBase::GetDefaultObj()
{
	static class UBlendSpaceBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlendSpaceBase*>(UBlendSpaceBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlendSpace
// (None)

class UClass* UBlendSpace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlendSpace");

	return Clss;
}


// BlendSpace Engine.Default__BlendSpace
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlendSpace* UBlendSpace::GetDefaultObj()
{
	static class UBlendSpace* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlendSpace*>(UBlendSpace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AimOffsetBlendSpace
// (None)

class UClass* UAimOffsetBlendSpace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AimOffsetBlendSpace");

	return Clss;
}


// AimOffsetBlendSpace Engine.Default__AimOffsetBlendSpace
// (Public, ClassDefaultObject, ArchetypeObject)

class UAimOffsetBlendSpace* UAimOffsetBlendSpace::GetDefaultObj()
{
	static class UAimOffsetBlendSpace* Default = nullptr;

	if (!Default)
		Default = static_cast<UAimOffsetBlendSpace*>(UAimOffsetBlendSpace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlendSpace1D
// (None)

class UClass* UBlendSpace1D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlendSpace1D");

	return Clss;
}


// BlendSpace1D Engine.Default__BlendSpace1D
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlendSpace1D* UBlendSpace1D::GetDefaultObj()
{
	static class UBlendSpace1D* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlendSpace1D*>(UBlendSpace1D::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AimOffsetBlendSpace1D
// (None)

class UClass* UAimOffsetBlendSpace1D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AimOffsetBlendSpace1D");

	return Clss;
}


// AimOffsetBlendSpace1D Engine.Default__AimOffsetBlendSpace1D
// (Public, ClassDefaultObject, ArchetypeObject)

class UAimOffsetBlendSpace1D* UAimOffsetBlendSpace1D::GetDefaultObj()
{
	static class UAimOffsetBlendSpace1D* Default = nullptr;

	if (!Default)
		Default = static_cast<UAimOffsetBlendSpace1D*>(UAimOffsetBlendSpace1D::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AmbientSound
// (Actor)

class UClass* AAmbientSound::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AmbientSound");

	return Clss;
}


// AmbientSound Engine.Default__AmbientSound
// (Public, ClassDefaultObject, ArchetypeObject)

class AAmbientSound* AAmbientSound::GetDefaultObj()
{
	static class AAmbientSound* Default = nullptr;

	if (!Default)
		Default = static_cast<AAmbientSound*>(AAmbientSound::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AmbientSound.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void AAmbientSound::Stop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AmbientSound", "Stop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AmbientSound.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbientSound::Play(float StartTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AmbientSound", "Play");

	Params::AAmbientSound_Play_Params Parms{};

	Parms.StartTime = StartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AmbientSound.FadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              FadeOutDuration                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FadeVolumeLevel                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbientSound::FadeOut(float FadeOutDuration, float FadeVolumeLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AmbientSound", "FadeOut");

	Params::AAmbientSound_FadeOut_Params Parms{};

	Parms.FadeOutDuration = FadeOutDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AmbientSound.FadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              FadeInDuration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FadeVolumeLevel                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbientSound::FadeIn(float FadeInDuration, float FadeVolumeLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AmbientSound", "FadeIn");

	Params::AAmbientSound_FadeIn_Params Parms{};

	Parms.FadeInDuration = FadeInDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AmbientSound.AdjustVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              AdjustVolumeDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AdjustVolumeLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbientSound::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AmbientSound", "AdjustVolume");

	Params::AAmbientSound_AdjustVolume_Params Parms{};

	Parms.AdjustVolumeDuration = AdjustVolumeDuration;
	Parms.AdjustVolumeLevel = AdjustVolumeLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.AnimationSettings
// (None)

class UClass* UAnimationSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimationSettings");

	return Clss;
}


// AnimationSettings Engine.Default__AnimationSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimationSettings* UAnimationSettings::GetDefaultObj()
{
	static class UAnimationSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimationSettings*>(UAnimationSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimBlueprint
// (Blueprint)

class UClass* UAnimBlueprint::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimBlueprint");

	return Clss;
}


// AnimBlueprint Engine.Default__AnimBlueprint
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimBlueprint* UAnimBlueprint::GetDefaultObj()
{
	static class UAnimBlueprint* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimBlueprint*>(UAnimBlueprint::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimBlueprintGeneratedClass
// (Field, Struct, Class)

class UClass* UAnimBlueprintGeneratedClass::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimBlueprintGeneratedClass");

	return Clss;
}


// AnimBlueprintGeneratedClass Engine.Default__AnimBlueprintGeneratedClass
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimBlueprintGeneratedClass* UAnimBlueprintGeneratedClass::GetDefaultObj()
{
	static class UAnimBlueprintGeneratedClass* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimBlueprintGeneratedClass*>(UAnimBlueprintGeneratedClass::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimClassData
// (None)

class UClass* UAnimClassData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimClassData");

	return Clss;
}


// AnimClassData Engine.Default__AnimClassData
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimClassData* UAnimClassData::GetDefaultObj()
{
	static class UAnimClassData* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimClassData*>(UAnimClassData::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimClassInterface
// (None)

class UClass* IAnimClassInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimClassInterface");

	return Clss;
}


// AnimClassInterface Engine.Default__AnimClassInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IAnimClassInterface* IAnimClassInterface::GetDefaultObj()
{
	static class IAnimClassInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IAnimClassInterface*>(IAnimClassInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimSequenceBase
// (None)

class UClass* UAnimSequenceBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimSequenceBase");

	return Clss;
}


// AnimSequenceBase Engine.Default__AnimSequenceBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimSequenceBase* UAnimSequenceBase::GetDefaultObj()
{
	static class UAnimSequenceBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimSequenceBase*>(UAnimSequenceBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AnimSequenceBase.GetPlayLength
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimSequenceBase::GetPlayLength()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSequenceBase", "GetPlayLength");

	Params::UAnimSequenceBase_GetPlayLength_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AnimCompositeBase
// (None)

class UClass* UAnimCompositeBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompositeBase");

	return Clss;
}


// AnimCompositeBase Engine.Default__AnimCompositeBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompositeBase* UAnimCompositeBase::GetDefaultObj()
{
	static class UAnimCompositeBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompositeBase*>(UAnimCompositeBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimComposite
// (None)

class UClass* UAnimComposite::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimComposite");

	return Clss;
}


// AnimComposite Engine.Default__AnimComposite
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimComposite* UAnimComposite::GetDefaultObj()
{
	static class UAnimComposite* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimComposite*>(UAnimComposite::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCompress
// (None)

class UClass* UAnimCompress::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompress");

	return Clss;
}


// AnimCompress Engine.Default__AnimCompress
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompress* UAnimCompress::GetDefaultObj()
{
	static class UAnimCompress* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompress*>(UAnimCompress::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCompress_Automatic
// (None)

class UClass* UAnimCompress_Automatic::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompress_Automatic");

	return Clss;
}


// AnimCompress_Automatic Engine.Default__AnimCompress_Automatic
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompress_Automatic* UAnimCompress_Automatic::GetDefaultObj()
{
	static class UAnimCompress_Automatic* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompress_Automatic*>(UAnimCompress_Automatic::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCompress_BitwiseCompressOnly
// (None)

class UClass* UAnimCompress_BitwiseCompressOnly::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompress_BitwiseCompressOnly");

	return Clss;
}


// AnimCompress_BitwiseCompressOnly Engine.Default__AnimCompress_BitwiseCompressOnly
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompress_BitwiseCompressOnly* UAnimCompress_BitwiseCompressOnly::GetDefaultObj()
{
	static class UAnimCompress_BitwiseCompressOnly* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompress_BitwiseCompressOnly*>(UAnimCompress_BitwiseCompressOnly::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCompress_LeastDestructive
// (None)

class UClass* UAnimCompress_LeastDestructive::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompress_LeastDestructive");

	return Clss;
}


// AnimCompress_LeastDestructive Engine.Default__AnimCompress_LeastDestructive
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompress_LeastDestructive* UAnimCompress_LeastDestructive::GetDefaultObj()
{
	static class UAnimCompress_LeastDestructive* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompress_LeastDestructive*>(UAnimCompress_LeastDestructive::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCompress_RemoveLinearKeys
// (None)

class UClass* UAnimCompress_RemoveLinearKeys::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompress_RemoveLinearKeys");

	return Clss;
}


// AnimCompress_RemoveLinearKeys Engine.Default__AnimCompress_RemoveLinearKeys
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompress_RemoveLinearKeys* UAnimCompress_RemoveLinearKeys::GetDefaultObj()
{
	static class UAnimCompress_RemoveLinearKeys* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompress_RemoveLinearKeys*>(UAnimCompress_RemoveLinearKeys::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCompress_PerTrackCompression
// (None)

class UClass* UAnimCompress_PerTrackCompression::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompress_PerTrackCompression");

	return Clss;
}


// AnimCompress_PerTrackCompression Engine.Default__AnimCompress_PerTrackCompression
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompress_PerTrackCompression* UAnimCompress_PerTrackCompression::GetDefaultObj()
{
	static class UAnimCompress_PerTrackCompression* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompress_PerTrackCompression*>(UAnimCompress_PerTrackCompression::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCompress_RemoveEverySecondKey
// (None)

class UClass* UAnimCompress_RemoveEverySecondKey::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompress_RemoveEverySecondKey");

	return Clss;
}


// AnimCompress_RemoveEverySecondKey Engine.Default__AnimCompress_RemoveEverySecondKey
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompress_RemoveEverySecondKey* UAnimCompress_RemoveEverySecondKey::GetDefaultObj()
{
	static class UAnimCompress_RemoveEverySecondKey* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompress_RemoveEverySecondKey*>(UAnimCompress_RemoveEverySecondKey::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCompress_RemoveTrivialKeys
// (None)

class UClass* UAnimCompress_RemoveTrivialKeys::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCompress_RemoveTrivialKeys");

	return Clss;
}


// AnimCompress_RemoveTrivialKeys Engine.Default__AnimCompress_RemoveTrivialKeys
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCompress_RemoveTrivialKeys* UAnimCompress_RemoveTrivialKeys::GetDefaultObj()
{
	static class UAnimCompress_RemoveTrivialKeys* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCompress_RemoveTrivialKeys*>(UAnimCompress_RemoveTrivialKeys::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCurveCompressionCodec
// (None)

class UClass* UAnimCurveCompressionCodec::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCurveCompressionCodec");

	return Clss;
}


// AnimCurveCompressionCodec Engine.Default__AnimCurveCompressionCodec
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCurveCompressionCodec* UAnimCurveCompressionCodec::GetDefaultObj()
{
	static class UAnimCurveCompressionCodec* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCurveCompressionCodec*>(UAnimCurveCompressionCodec::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCurveCompressionCodec_CompressedRichCurve
// (None)

class UClass* UAnimCurveCompressionCodec_CompressedRichCurve::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCurveCompressionCodec_CompressedRichCurve");

	return Clss;
}


// AnimCurveCompressionCodec_CompressedRichCurve Engine.Default__AnimCurveCompressionCodec_CompressedRichCurve
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCurveCompressionCodec_CompressedRichCurve* UAnimCurveCompressionCodec_CompressedRichCurve::GetDefaultObj()
{
	static class UAnimCurveCompressionCodec_CompressedRichCurve* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCurveCompressionCodec_CompressedRichCurve*>(UAnimCurveCompressionCodec_CompressedRichCurve::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCurveCompressionCodec_UniformlySampled
// (None)

class UClass* UAnimCurveCompressionCodec_UniformlySampled::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCurveCompressionCodec_UniformlySampled");

	return Clss;
}


// AnimCurveCompressionCodec_UniformlySampled Engine.Default__AnimCurveCompressionCodec_UniformlySampled
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCurveCompressionCodec_UniformlySampled* UAnimCurveCompressionCodec_UniformlySampled::GetDefaultObj()
{
	static class UAnimCurveCompressionCodec_UniformlySampled* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCurveCompressionCodec_UniformlySampled*>(UAnimCurveCompressionCodec_UniformlySampled::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimCurveCompressionSettings
// (None)

class UClass* UAnimCurveCompressionSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimCurveCompressionSettings");

	return Clss;
}


// AnimCurveCompressionSettings Engine.Default__AnimCurveCompressionSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimCurveCompressionSettings* UAnimCurveCompressionSettings::GetDefaultObj()
{
	static class UAnimCurveCompressionSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimCurveCompressionSettings*>(UAnimCurveCompressionSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimLayerInterface
// (None)

class UClass* IAnimLayerInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimLayerInterface");

	return Clss;
}


// AnimLayerInterface Engine.Default__AnimLayerInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IAnimLayerInterface* IAnimLayerInterface::GetDefaultObj()
{
	static class IAnimLayerInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IAnimLayerInterface*>(IAnimLayerInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimMetaData
// (None)

class UClass* UAnimMetaData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimMetaData");

	return Clss;
}


// AnimMetaData Engine.Default__AnimMetaData
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimMetaData* UAnimMetaData::GetDefaultObj()
{
	static class UAnimMetaData* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimMetaData*>(UAnimMetaData::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimMontage
// (None)

class UClass* UAnimMontage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimMontage");

	return Clss;
}


// AnimMontage Engine.Default__AnimMontage
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimMontage* UAnimMontage::GetDefaultObj()
{
	static class UAnimMontage* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimMontage*>(UAnimMontage::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AnimMontage.GetDefaultBlendOutTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimMontage::GetDefaultBlendOutTime()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimMontage", "GetDefaultBlendOutTime");

	Params::UAnimMontage_GetDefaultBlendOutTime_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AnimNotify_PauseClothingSimulation
// (None)

class UClass* UAnimNotify_PauseClothingSimulation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotify_PauseClothingSimulation");

	return Clss;
}


// AnimNotify_PauseClothingSimulation Engine.Default__AnimNotify_PauseClothingSimulation
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotify_PauseClothingSimulation* UAnimNotify_PauseClothingSimulation::GetDefaultObj()
{
	static class UAnimNotify_PauseClothingSimulation* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotify_PauseClothingSimulation*>(UAnimNotify_PauseClothingSimulation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotify_ResetClothingSimulation
// (None)

class UClass* UAnimNotify_ResetClothingSimulation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotify_ResetClothingSimulation");

	return Clss;
}


// AnimNotify_ResetClothingSimulation Engine.Default__AnimNotify_ResetClothingSimulation
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotify_ResetClothingSimulation* UAnimNotify_ResetClothingSimulation::GetDefaultObj()
{
	static class UAnimNotify_ResetClothingSimulation* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotify_ResetClothingSimulation*>(UAnimNotify_ResetClothingSimulation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotify_ResetDynamics
// (None)

class UClass* UAnimNotify_ResetDynamics::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotify_ResetDynamics");

	return Clss;
}


// AnimNotify_ResetDynamics Engine.Default__AnimNotify_ResetDynamics
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotify_ResetDynamics* UAnimNotify_ResetDynamics::GetDefaultObj()
{
	static class UAnimNotify_ResetDynamics* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotify_ResetDynamics*>(UAnimNotify_ResetDynamics::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotify_ResumeClothingSimulation
// (None)

class UClass* UAnimNotify_ResumeClothingSimulation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotify_ResumeClothingSimulation");

	return Clss;
}


// AnimNotify_ResumeClothingSimulation Engine.Default__AnimNotify_ResumeClothingSimulation
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotify_ResumeClothingSimulation* UAnimNotify_ResumeClothingSimulation::GetDefaultObj()
{
	static class UAnimNotify_ResumeClothingSimulation* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotify_ResumeClothingSimulation*>(UAnimNotify_ResumeClothingSimulation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotifyState_DisableRootMotion
// (None)

class UClass* UAnimNotifyState_DisableRootMotion::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotifyState_DisableRootMotion");

	return Clss;
}


// AnimNotifyState_DisableRootMotion Engine.Default__AnimNotifyState_DisableRootMotion
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotifyState_DisableRootMotion* UAnimNotifyState_DisableRootMotion::GetDefaultObj()
{
	static class UAnimNotifyState_DisableRootMotion* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotifyState_DisableRootMotion*>(UAnimNotifyState_DisableRootMotion::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotifyState_TimedParticleEffect
// (None)

class UClass* UAnimNotifyState_TimedParticleEffect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotifyState_TimedParticleEffect");

	return Clss;
}


// AnimNotifyState_TimedParticleEffect Engine.Default__AnimNotifyState_TimedParticleEffect
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotifyState_TimedParticleEffect* UAnimNotifyState_TimedParticleEffect::GetDefaultObj()
{
	static class UAnimNotifyState_TimedParticleEffect* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotifyState_TimedParticleEffect*>(UAnimNotifyState_TimedParticleEffect::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimNotifyState_Trail
// (None)

class UClass* UAnimNotifyState_Trail::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimNotifyState_Trail");

	return Clss;
}


// AnimNotifyState_Trail Engine.Default__AnimNotifyState_Trail
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimNotifyState_Trail* UAnimNotifyState_Trail::GetDefaultObj()
{
	static class UAnimNotifyState_Trail* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimNotifyState_Trail*>(UAnimNotifyState_Trail::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AnimNotifyState_Trail.OverridePSTemplate
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*      MeshComp                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*           Animation                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* UAnimNotifyState_Trail::OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimNotifyState_Trail", "OverridePSTemplate");

	Params::UAnimNotifyState_Trail_OverridePSTemplate_Params Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Class Engine.AnimSequence
// (None)

class UClass* UAnimSequence::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimSequence");

	return Clss;
}


// AnimSequence Engine.Default__AnimSequence
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimSequence* UAnimSequence::GetDefaultObj()
{
	static class UAnimSequence* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimSequence*>(UAnimSequence::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimSet
// (None)

class UClass* UAnimSet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimSet");

	return Clss;
}


// AnimSet Engine.Default__AnimSet
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimSet* UAnimSet::GetDefaultObj()
{
	static class UAnimSet* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimSet*>(UAnimSet::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimSingleNodeInstance
// (None)

class UClass* UAnimSingleNodeInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimSingleNodeInstance");

	return Clss;
}


// AnimSingleNodeInstance Engine.Default__AnimSingleNodeInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimSingleNodeInstance* UAnimSingleNodeInstance::GetDefaultObj()
{
	static class UAnimSingleNodeInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimSingleNodeInstance*>(UAnimSingleNodeInstance::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AnimSingleNodeInstance.StopAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UAnimSingleNodeInstance::StopAnim()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "StopAnim");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetReverse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInReverse                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetReverse(bool bInReverse)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetReverse");

	Params::UAnimSingleNodeInstance_SetReverse_Params Parms{};

	Parms.bInReverse = bInReverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetPreviewCurveOverride
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        PoseName                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRemoveIfZero                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPreviewCurveOverride(class FName& PoseName, float Value, bool bRemoveIfZero)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetPreviewCurveOverride");

	Params::UAnimSingleNodeInstance_SetPreviewCurveOverride_Params Parms{};

	Parms.PoseName = PoseName;
	Parms.Value = Value;
	Parms.bRemoveIfZero = bRemoveIfZero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetPositionWithPreviousTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InPosition                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPreviousTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFireNotifies                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetPositionWithPreviousTime");

	Params::UAnimSingleNodeInstance_SetPositionWithPreviousTime_Params Parms{};

	Parms.InPosition = InPosition;
	Parms.InPreviousTime = InPreviousTime;
	Parms.bFireNotifies = bFireNotifies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InPosition                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFireNotifies                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPosition(float InPosition, bool bFireNotifies)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetPosition");

	Params::UAnimSingleNodeInstance_SetPosition_Params Parms{};

	Parms.InPosition = InPosition;
	Parms.bFireNotifies = bFireNotifies;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InPlayRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPlayRate(float InPlayRate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetPlayRate");

	Params::UAnimSingleNodeInstance_SetPlayRate_Params Parms{};

	Parms.InPlayRate = InPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsPlaying                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPlaying(bool bIsPlaying)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetPlaying");

	Params::UAnimSingleNodeInstance_SetPlaying_Params Parms{};

	Parms.bIsPlaying = bIsPlaying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetLooping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsLooping                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetLooping(bool bIsLooping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetLooping");

	Params::UAnimSingleNodeInstance_SetLooping_Params Parms{};

	Parms.bIsLooping = bIsLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InBlendInput                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetBlendSpaceInput(struct FVector& InBlendInput)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetBlendSpaceInput");

	Params::UAnimSingleNodeInstance_SetBlendSpaceInput_Params Parms{};

	Parms.InBlendInput = InBlendInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.SetAnimationAsset
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*             NewAsset                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsLooping                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPlayRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetAnimationAsset(class UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "SetAnimationAsset");

	Params::UAnimSingleNodeInstance_SetAnimationAsset_Params Parms{};

	Parms.NewAsset = NewAsset;
	Parms.bIsLooping = bIsLooping;
	Parms.InPlayRate = InPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.PlayAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bIsLooping                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPlayRate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InStartPosition                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "PlayAnim");

	Params::UAnimSingleNodeInstance_PlayAnim_Params Parms{};

	Parms.bIsLooping = bIsLooping;
	Parms.InPlayRate = InPlayRate;
	Parms.InStartPosition = InStartPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AnimSingleNodeInstance.GetLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimSingleNodeInstance::GetLength()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "GetLength");

	Params::UAnimSingleNodeInstance_GetLength_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AnimSingleNodeInstance.GetAnimationAsset
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimationAsset*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationAsset* UAnimSingleNodeInstance::GetAnimationAsset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AnimSingleNodeInstance", "GetAnimationAsset");

	Params::UAnimSingleNodeInstance_GetAnimationAsset_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AnimStateMachineTypes
// (None)

class UClass* UAnimStateMachineTypes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimStateMachineTypes");

	return Clss;
}


// AnimStateMachineTypes Engine.Default__AnimStateMachineTypes
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimStateMachineTypes* UAnimStateMachineTypes::GetDefaultObj()
{
	static class UAnimStateMachineTypes* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimStateMachineTypes*>(UAnimStateMachineTypes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AnimStreamable
// (None)

class UClass* UAnimStreamable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AnimStreamable");

	return Clss;
}


// AnimStreamable Engine.Default__AnimStreamable
// (Public, ClassDefaultObject, ArchetypeObject)

class UAnimStreamable* UAnimStreamable::GetDefaultObj()
{
	static class UAnimStreamable* Default = nullptr;

	if (!Default)
		Default = static_cast<UAnimStreamable*>(UAnimStreamable::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ApplicationLifecycleComponent
// (None)

class UClass* UApplicationLifecycleComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ApplicationLifecycleComponent");

	return Clss;
}


// ApplicationLifecycleComponent Engine.Default__ApplicationLifecycleComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UApplicationLifecycleComponent* UApplicationLifecycleComponent::GetDefaultObj()
{
	static class UApplicationLifecycleComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UApplicationLifecycleComponent*>(UApplicationLifecycleComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ArrowComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UArrowComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ArrowComponent");

	return Clss;
}


// ArrowComponent Engine.Default__ArrowComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UArrowComponent* UArrowComponent::GetDefaultObj()
{
	static class UArrowComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UArrowComponent*>(UArrowComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ArrowComponent.SetArrowColor
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                NewColor                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrowComponent::SetArrowColor(const struct FLinearColor& NewColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ArrowComponent", "SetArrowColor");

	Params::UArrowComponent_SetArrowColor_Params Parms{};

	Parms.NewColor = NewColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.AssetExportTask
// (None)

class UClass* UAssetExportTask::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AssetExportTask");

	return Clss;
}


// AssetExportTask Engine.Default__AssetExportTask
// (Public, ClassDefaultObject, ArchetypeObject)

class UAssetExportTask* UAssetExportTask::GetDefaultObj()
{
	static class UAssetExportTask* Default = nullptr;

	if (!Default)
		Default = static_cast<UAssetExportTask*>(UAssetExportTask::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AssetImportData
// (None)

class UClass* UAssetImportData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AssetImportData");

	return Clss;
}


// AssetImportData Engine.Default__AssetImportData
// (Public, ClassDefaultObject, ArchetypeObject)

class UAssetImportData* UAssetImportData::GetDefaultObj()
{
	static class UAssetImportData* Default = nullptr;

	if (!Default)
		Default = static_cast<UAssetImportData*>(UAssetImportData::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AssetManagerSettings
// (None)

class UClass* UAssetManagerSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AssetManagerSettings");

	return Clss;
}


// AssetManagerSettings Engine.Default__AssetManagerSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UAssetManagerSettings* UAssetManagerSettings::GetDefaultObj()
{
	static class UAssetManagerSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UAssetManagerSettings*>(UAssetManagerSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AssetMappingTable
// (None)

class UClass* UAssetMappingTable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AssetMappingTable");

	return Clss;
}


// AssetMappingTable Engine.Default__AssetMappingTable
// (Public, ClassDefaultObject, ArchetypeObject)

class UAssetMappingTable* UAssetMappingTable::GetDefaultObj()
{
	static class UAssetMappingTable* Default = nullptr;

	if (!Default)
		Default = static_cast<UAssetMappingTable*>(UAssetMappingTable::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AsyncActionLoadPrimaryAssetBase
// (None)

class UClass* UAsyncActionLoadPrimaryAssetBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AsyncActionLoadPrimaryAssetBase");

	return Clss;
}


// AsyncActionLoadPrimaryAssetBase Engine.Default__AsyncActionLoadPrimaryAssetBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UAsyncActionLoadPrimaryAssetBase* UAsyncActionLoadPrimaryAssetBase::GetDefaultObj()
{
	static class UAsyncActionLoadPrimaryAssetBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UAsyncActionLoadPrimaryAssetBase*>(UAsyncActionLoadPrimaryAssetBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AsyncActionLoadPrimaryAsset
// (None)

class UClass* UAsyncActionLoadPrimaryAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AsyncActionLoadPrimaryAsset");

	return Clss;
}


// AsyncActionLoadPrimaryAsset Engine.Default__AsyncActionLoadPrimaryAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UAsyncActionLoadPrimaryAsset* UAsyncActionLoadPrimaryAsset::GetDefaultObj()
{
	static class UAsyncActionLoadPrimaryAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UAsyncActionLoadPrimaryAsset*>(UAsyncActionLoadPrimaryAsset::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AsyncActionLoadPrimaryAsset.AsyncLoadPrimaryAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId             PrimaryAsset                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                LoadBundles                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionLoadPrimaryAsset*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionLoadPrimaryAsset* UAsyncActionLoadPrimaryAsset::AsyncLoadPrimaryAsset(class UObject* WorldContextObject, const struct FPrimaryAssetId& PrimaryAsset, TArray<class FName>& LoadBundles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AsyncActionLoadPrimaryAsset", "AsyncLoadPrimaryAsset");

	Params::UAsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAsset = PrimaryAsset;
	Parms.LoadBundles = LoadBundles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AsyncActionLoadPrimaryAssetClass
// (None)

class UClass* UAsyncActionLoadPrimaryAssetClass::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AsyncActionLoadPrimaryAssetClass");

	return Clss;
}


// AsyncActionLoadPrimaryAssetClass Engine.Default__AsyncActionLoadPrimaryAssetClass
// (Public, ClassDefaultObject, ArchetypeObject)

class UAsyncActionLoadPrimaryAssetClass* UAsyncActionLoadPrimaryAssetClass::GetDefaultObj()
{
	static class UAsyncActionLoadPrimaryAssetClass* Default = nullptr;

	if (!Default)
		Default = static_cast<UAsyncActionLoadPrimaryAssetClass*>(UAsyncActionLoadPrimaryAssetClass::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AsyncActionLoadPrimaryAssetClass.AsyncLoadPrimaryAssetClass
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId             PrimaryAsset                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                LoadBundles                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionLoadPrimaryAssetClass*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionLoadPrimaryAssetClass* UAsyncActionLoadPrimaryAssetClass::AsyncLoadPrimaryAssetClass(class UObject* WorldContextObject, const struct FPrimaryAssetId& PrimaryAsset, TArray<class FName>& LoadBundles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AsyncActionLoadPrimaryAssetClass", "AsyncLoadPrimaryAssetClass");

	Params::UAsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAsset = PrimaryAsset;
	Parms.LoadBundles = LoadBundles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AsyncActionLoadPrimaryAssetList
// (None)

class UClass* UAsyncActionLoadPrimaryAssetList::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AsyncActionLoadPrimaryAssetList");

	return Clss;
}


// AsyncActionLoadPrimaryAssetList Engine.Default__AsyncActionLoadPrimaryAssetList
// (Public, ClassDefaultObject, ArchetypeObject)

class UAsyncActionLoadPrimaryAssetList* UAsyncActionLoadPrimaryAssetList::GetDefaultObj()
{
	static class UAsyncActionLoadPrimaryAssetList* Default = nullptr;

	if (!Default)
		Default = static_cast<UAsyncActionLoadPrimaryAssetList*>(UAsyncActionLoadPrimaryAssetList::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AsyncActionLoadPrimaryAssetList.AsyncLoadPrimaryAssetList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>     PrimaryAssetList                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                LoadBundles                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionLoadPrimaryAssetList*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionLoadPrimaryAssetList* UAsyncActionLoadPrimaryAssetList::AsyncLoadPrimaryAssetList(class UObject* WorldContextObject, TArray<struct FPrimaryAssetId>& PrimaryAssetList, TArray<class FName>& LoadBundles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AsyncActionLoadPrimaryAssetList", "AsyncLoadPrimaryAssetList");

	Params::UAsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAssetList = PrimaryAssetList;
	Parms.LoadBundles = LoadBundles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AsyncActionLoadPrimaryAssetClassList
// (None)

class UClass* UAsyncActionLoadPrimaryAssetClassList::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AsyncActionLoadPrimaryAssetClassList");

	return Clss;
}


// AsyncActionLoadPrimaryAssetClassList Engine.Default__AsyncActionLoadPrimaryAssetClassList
// (Public, ClassDefaultObject, ArchetypeObject)

class UAsyncActionLoadPrimaryAssetClassList* UAsyncActionLoadPrimaryAssetClassList::GetDefaultObj()
{
	static class UAsyncActionLoadPrimaryAssetClassList* Default = nullptr;

	if (!Default)
		Default = static_cast<UAsyncActionLoadPrimaryAssetClassList*>(UAsyncActionLoadPrimaryAssetClassList::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AsyncActionLoadPrimaryAssetClassList.AsyncLoadPrimaryAssetClassList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>     PrimaryAssetList                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                LoadBundles                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionLoadPrimaryAssetClassList*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionLoadPrimaryAssetClassList* UAsyncActionLoadPrimaryAssetClassList::AsyncLoadPrimaryAssetClassList(class UObject* WorldContextObject, TArray<struct FPrimaryAssetId>& PrimaryAssetList, TArray<class FName>& LoadBundles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AsyncActionLoadPrimaryAssetClassList", "AsyncLoadPrimaryAssetClassList");

	Params::UAsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAssetList = PrimaryAssetList;
	Parms.LoadBundles = LoadBundles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AsyncActionChangePrimaryAssetBundles
// (None)

class UClass* UAsyncActionChangePrimaryAssetBundles::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AsyncActionChangePrimaryAssetBundles");

	return Clss;
}


// AsyncActionChangePrimaryAssetBundles Engine.Default__AsyncActionChangePrimaryAssetBundles
// (Public, ClassDefaultObject, ArchetypeObject)

class UAsyncActionChangePrimaryAssetBundles* UAsyncActionChangePrimaryAssetBundles::GetDefaultObj()
{
	static class UAsyncActionChangePrimaryAssetBundles* Default = nullptr;

	if (!Default)
		Default = static_cast<UAsyncActionChangePrimaryAssetBundles*>(UAsyncActionChangePrimaryAssetBundles::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForPrimaryAssetList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>     PrimaryAssetList                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                AddBundles                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                RemoveBundles                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionChangePrimaryAssetBundles*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionChangePrimaryAssetBundles* UAsyncActionChangePrimaryAssetBundles::AsyncChangeBundleStateForPrimaryAssetList(class UObject* WorldContextObject, TArray<struct FPrimaryAssetId>& PrimaryAssetList, TArray<class FName>& AddBundles, TArray<class FName>& RemoveBundles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AsyncActionChangePrimaryAssetBundles", "AsyncChangeBundleStateForPrimaryAssetList");

	Params::UAsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAssetList = PrimaryAssetList;
	Parms.AddBundles = AddBundles;
	Parms.RemoveBundles = RemoveBundles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForMatchingPrimaryAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                NewBundles                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                OldBundles                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionChangePrimaryAssetBundles*ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionChangePrimaryAssetBundles* UAsyncActionChangePrimaryAssetBundles::AsyncChangeBundleStateForMatchingPrimaryAssets(class UObject* WorldContextObject, TArray<class FName>& NewBundles, TArray<class FName>& OldBundles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AsyncActionChangePrimaryAssetBundles", "AsyncChangeBundleStateForMatchingPrimaryAssets");

	Params::UAsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NewBundles = NewBundles;
	Parms.OldBundles = OldBundles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.AtmosphericFog
// (Actor)

class UClass* AAtmosphericFog::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AtmosphericFog");

	return Clss;
}


// AtmosphericFog Engine.Default__AtmosphericFog
// (Public, ClassDefaultObject, ArchetypeObject)

class AAtmosphericFog* AAtmosphericFog::GetDefaultObj()
{
	static class AAtmosphericFog* Default = nullptr;

	if (!Default)
		Default = static_cast<AAtmosphericFog*>(AAtmosphericFog::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AtmosphericFogComponent
// (SceneComponent)

class UClass* UAtmosphericFogComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AtmosphericFogComponent");

	return Clss;
}


// AtmosphericFogComponent Engine.Default__AtmosphericFogComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UAtmosphericFogComponent* UAtmosphericFogComponent::GetDefaultObj()
{
	static class UAtmosphericFogComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UAtmosphericFogComponent*>(UAtmosphericFogComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AtmosphericFogComponent.StartPrecompute
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UAtmosphericFogComponent::StartPrecompute()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "StartPrecompute");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetSunMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewSunMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetSunMultiplier(float NewSunMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetSunMultiplier");

	Params::UAtmosphericFogComponent_SetSunMultiplier_Params Parms{};

	Parms.NewSunMultiplier = NewSunMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetStartDistance
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewStartDistance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetStartDistance(float NewStartDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetStartDistance");

	Params::UAtmosphericFogComponent_SetStartDistance_Params Parms{};

	Parms.NewStartDistance = NewStartDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetPrecomputeParams
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              DensityHeight                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaxScatteringOrder                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InscatterAltitudeSampleNum                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetPrecomputeParams(float DensityHeight, int32 MaxScatteringOrder, int32 InscatterAltitudeSampleNum)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetPrecomputeParams");

	Params::UAtmosphericFogComponent_SetPrecomputeParams_Params Parms{};

	Parms.DensityHeight = DensityHeight;
	Parms.MaxScatteringOrder = MaxScatteringOrder;
	Parms.InscatterAltitudeSampleNum = InscatterAltitudeSampleNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetFogMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewFogMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetFogMultiplier(float NewFogMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetFogMultiplier");

	Params::UAtmosphericFogComponent_SetFogMultiplier_Params Parms{};

	Parms.NewFogMultiplier = NewFogMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetDistanceScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewDistanceScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDistanceScale(float NewDistanceScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetDistanceScale");

	Params::UAtmosphericFogComponent_SetDistanceScale_Params Parms{};

	Parms.NewDistanceScale = NewDistanceScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetDistanceOffset
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewDistanceOffset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDistanceOffset(float NewDistanceOffset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetDistanceOffset");

	Params::UAtmosphericFogComponent_SetDistanceOffset_Params Parms{};

	Parms.NewDistanceOffset = NewDistanceOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetDensityOffset
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewDensityOffset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDensityOffset(float NewDensityOffset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetDensityOffset");

	Params::UAtmosphericFogComponent_SetDensityOffset_Params Parms{};

	Parms.NewDensityOffset = NewDensityOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetDensityMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewDensityMultiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDensityMultiplier(float NewDensityMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetDensityMultiplier");

	Params::UAtmosphericFogComponent_SetDensityMultiplier_Params Parms{};

	Parms.NewDensityMultiplier = NewDensityMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetDefaultLightColor
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                NewLightColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDefaultLightColor(const struct FLinearColor& NewLightColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetDefaultLightColor");

	Params::UAtmosphericFogComponent_SetDefaultLightColor_Params Parms{};

	Parms.NewLightColor = NewLightColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetDefaultBrightness
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewBrightness                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDefaultBrightness(float NewBrightness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetDefaultBrightness");

	Params::UAtmosphericFogComponent_SetDefaultBrightness_Params Parms{};

	Parms.NewBrightness = NewBrightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.SetAltitudeScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewAltitudeScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetAltitudeScale(float NewAltitudeScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "SetAltitudeScale");

	Params::UAtmosphericFogComponent_SetAltitudeScale_Params Parms{};

	Parms.NewAltitudeScale = NewAltitudeScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.DisableSunDisk
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                               NewSunDisk                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::DisableSunDisk(bool NewSunDisk)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "DisableSunDisk");

	Params::UAtmosphericFogComponent_DisableSunDisk_Params Parms{};

	Parms.NewSunDisk = NewSunDisk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AtmosphericFogComponent.DisableGroundScattering
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                               NewGroundScattering                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::DisableGroundScattering(bool NewGroundScattering)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AtmosphericFogComponent", "DisableGroundScattering");

	Params::UAtmosphericFogComponent_DisableGroundScattering_Params Parms{};

	Parms.NewGroundScattering = NewGroundScattering;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.AudioSettings
// (None)

class UClass* UAudioSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AudioSettings");

	return Clss;
}


// AudioSettings Engine.Default__AudioSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UAudioSettings* UAudioSettings::GetDefaultObj()
{
	static class UAudioSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UAudioSettings*>(UAudioSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AudioVolume
// (Actor)

class UClass* AAudioVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AudioVolume");

	return Clss;
}


// AudioVolume Engine.Default__AudioVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AAudioVolume* AAudioVolume::GetDefaultObj()
{
	static class AAudioVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AAudioVolume*>(AAudioVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.AudioVolume.SetReverbSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FReverbSettings             NewReverbSettings                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AAudioVolume::SetReverbSettings(struct FReverbSettings& NewReverbSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioVolume", "SetReverbSettings");

	Params::AAudioVolume_SetReverbSettings_Params Parms{};

	Parms.NewReverbSettings = NewReverbSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioVolume.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewPriority                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAudioVolume::SetPriority(float NewPriority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioVolume", "SetPriority");

	Params::AAudioVolume_SetPriority_Params Parms{};

	Parms.NewPriority = NewPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioVolume.SetInteriorSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInteriorSettings           NewInteriorSettings                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AAudioVolume::SetInteriorSettings(struct FInteriorSettings& NewInteriorSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioVolume", "SetInteriorSettings");

	Params::AAudioVolume_SetInteriorSettings_Params Parms{};

	Parms.NewInteriorSettings = NewInteriorSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioVolume.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewEnabled                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAudioVolume::SetEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioVolume", "SetEnabled");

	Params::AAudioVolume_SetEnabled_Params Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.AudioVolume.OnRep_bEnabled
// (Final, Native, Private)
// Parameters:

void AAudioVolume::OnRep_bEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("AudioVolume", "OnRep_bEnabled");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.AutomationTestSettings
// (None)

class UClass* UAutomationTestSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AutomationTestSettings");

	return Clss;
}


// AutomationTestSettings Engine.Default__AutomationTestSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UAutomationTestSettings* UAutomationTestSettings::GetDefaultObj()
{
	static class UAutomationTestSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UAutomationTestSettings*>(UAutomationTestSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BillboardComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UBillboardComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BillboardComponent");

	return Clss;
}


// BillboardComponent Engine.Default__BillboardComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UBillboardComponent* UBillboardComponent::GetDefaultObj()
{
	static class UBillboardComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UBillboardComponent*>(UBillboardComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.BillboardComponent.SetUV
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewU                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewUL                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewV                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewVL                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBillboardComponent::SetUV(int32 NewU, int32 NewUL, int32 NewV, int32 NewVL)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BillboardComponent", "SetUV");

	Params::UBillboardComponent_SetUV_Params Parms{};

	Parms.NewU = NewU;
	Parms.NewUL = NewUL;
	Parms.NewV = NewV;
	Parms.NewVL = NewVL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BillboardComponent.SetSpriteAndUV
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                  NewSprite                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewU                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewUL                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewV                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NewVL                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBillboardComponent::SetSpriteAndUV(class UTexture2D* NewSprite, int32 NewU, int32 NewUL, int32 NewV, int32 NewVL)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BillboardComponent", "SetSpriteAndUV");

	Params::UBillboardComponent_SetSpriteAndUV_Params Parms{};

	Parms.NewSprite = NewSprite;
	Parms.NewU = NewU;
	Parms.NewUL = NewUL;
	Parms.NewV = NewV;
	Parms.NewVL = NewVL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BillboardComponent.SetSprite
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                  NewSprite                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBillboardComponent::SetSprite(class UTexture2D* NewSprite)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BillboardComponent", "SetSprite");

	Params::UBillboardComponent_SetSprite_Params Parms{};

	Parms.NewSprite = NewSprite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.BlendableInterface
// (None)

class UClass* IBlendableInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlendableInterface");

	return Clss;
}


// BlendableInterface Engine.Default__BlendableInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IBlendableInterface* IBlendableInterface::GetDefaultObj()
{
	static class IBlendableInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IBlendableInterface*>(IBlendableInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Skeleton
// (None)

class UClass* USkeleton::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Skeleton");

	return Clss;
}


// Skeleton Engine.Default__Skeleton
// (Public, ClassDefaultObject, ArchetypeObject)

class USkeleton* USkeleton::GetDefaultObj()
{
	static class USkeleton* Default = nullptr;

	if (!Default)
		Default = static_cast<USkeleton*>(USkeleton::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlendProfile
// (None)

class UClass* UBlendProfile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlendProfile");

	return Clss;
}


// BlendProfile Engine.Default__BlendProfile
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlendProfile* UBlendProfile::GetDefaultObj()
{
	static class UBlendProfile* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlendProfile*>(UBlendProfile::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlockingVolume
// (Actor)

class UClass* ABlockingVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlockingVolume");

	return Clss;
}


// BlockingVolume Engine.Default__BlockingVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ABlockingVolume* ABlockingVolume::GetDefaultObj()
{
	static class ABlockingVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ABlockingVolume*>(ABlockingVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlueprintMapLibrary
// (None)

class UClass* UBlueprintMapLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueprintMapLibrary");

	return Clss;
}


// BlueprintMapLibrary Engine.Default__BlueprintMapLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprintMapLibrary* UBlueprintMapLibrary::GetDefaultObj()
{
	static class UBlueprintMapLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprintMapLibrary*>(UBlueprintMapLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.BlueprintMapLibrary.SetMapPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, int32>                 Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::SetMapPropertyByName(class UObject* Object, class FName PropertyName, TMap<int32, int32>& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "SetMapPropertyByName");

	Params::UBlueprintMapLibrary_SetMapPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintMapLibrary.Map_Values
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                 TargetMap                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      Values                                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::Map_Values(TMap<int32, int32>& TargetMap, TArray<int32>* Values)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "Map_Values");

	Params::UBlueprintMapLibrary_Map_Values_Params Parms{};

	Parms.TargetMap = TargetMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Values != nullptr)
		*Values = std::move(Parms.Values);

}


// Function Engine.BlueprintMapLibrary.Map_Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                 TargetMap                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Key                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintMapLibrary::Map_Remove(TMap<int32, int32>& TargetMap, int32& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "Map_Remove");

	Params::UBlueprintMapLibrary_Map_Remove_Params Parms{};

	Parms.TargetMap = TargetMap;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintMapLibrary.Map_Length
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, int32>                 TargetMap                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintMapLibrary::Map_Length(TMap<int32, int32>& TargetMap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "Map_Length");

	Params::UBlueprintMapLibrary_Map_Length_Params Parms{};

	Parms.TargetMap = TargetMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintMapLibrary.Map_Keys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                 TargetMap                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      Keys                                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::Map_Keys(TMap<int32, int32>& TargetMap, TArray<int32>* Keys)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "Map_Keys");

	Params::UBlueprintMapLibrary_Map_Keys_Params Parms{};

	Parms.TargetMap = TargetMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Keys != nullptr)
		*Keys = std::move(Parms.Keys);

}


// Function Engine.BlueprintMapLibrary.Map_Find
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, int32>                 TargetMap                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Key                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Value                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintMapLibrary::Map_Find(TMap<int32, int32>& TargetMap, int32& Key, int32* Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "Map_Find");

	Params::UBlueprintMapLibrary_Map_Find_Params Parms{};

	Parms.TargetMap = TargetMap;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintMapLibrary.Map_Contains
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, int32>                 TargetMap                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Key                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintMapLibrary::Map_Contains(TMap<int32, int32>& TargetMap, int32& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "Map_Contains");

	Params::UBlueprintMapLibrary_Map_Contains_Params Parms{};

	Parms.TargetMap = TargetMap;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintMapLibrary.Map_Clear
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                 TargetMap                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::Map_Clear(TMap<int32, int32>& TargetMap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "Map_Clear");

	Params::UBlueprintMapLibrary_Map_Clear_Params Parms{};

	Parms.TargetMap = TargetMap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintMapLibrary.Map_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                 TargetMap                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Key                                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::Map_Add(TMap<int32, int32>& TargetMap, int32& Key, int32& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintMapLibrary", "Map_Add");

	Params::UBlueprintMapLibrary_Map_Add_Params Parms{};

	Parms.TargetMap = TargetMap;
	Parms.Key = Key;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.BlueprintPathsLibrary
// (None)

class UClass* UBlueprintPathsLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueprintPathsLibrary");

	return Clss;
}


// BlueprintPathsLibrary Engine.Default__BlueprintPathsLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprintPathsLibrary* UBlueprintPathsLibrary::GetDefaultObj()
{
	static class UBlueprintPathsLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprintPathsLibrary*>(UBlueprintPathsLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.BlueprintPathsLibrary.VideoCaptureDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::VideoCaptureDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "VideoCaptureDir");

	Params::UBlueprintPathsLibrary_VideoCaptureDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ValidatePath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDidSucceed                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        OutReason                                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::ValidatePath(const class FString& InPath, bool* bDidSucceed, class FText* OutReason)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ValidatePath");

	Params::UBlueprintPathsLibrary_ValidatePath_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bDidSucceed != nullptr)
		*bDidSucceed = Parms.bDidSucceed;

	if (OutReason != nullptr)
		*OutReason = Parms.OutReason;

}


// Function Engine.BlueprintPathsLibrary.Split
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PathPart                                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FilenamePart                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ExtensionPart                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::Split(const class FString& InPath, class FString* PathPart, class FString* FilenamePart, class FString* ExtensionPart)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "Split");

	Params::UBlueprintPathsLibrary_Split_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (PathPart != nullptr)
		*PathPart = std::move(Parms.PathPart);

	if (FilenamePart != nullptr)
		*FilenamePart = std::move(Parms.FilenamePart);

	if (ExtensionPart != nullptr)
		*ExtensionPart = std::move(Parms.ExtensionPart);

}


// Function Engine.BlueprintPathsLibrary.SourceConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::SourceConfigDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "SourceConfigDir");

	Params::UBlueprintPathsLibrary_SourceConfigDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ShouldSaveToUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::ShouldSaveToUserDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ShouldSaveToUserDir");

	Params::UBlueprintPathsLibrary_ShouldSaveToUserDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ShaderWorkingDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ShaderWorkingDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ShaderWorkingDir");

	Params::UBlueprintPathsLibrary_ShaderWorkingDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.SetProjectFilePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      NewGameProjectFilePath                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::SetProjectFilePath(const class FString& NewGameProjectFilePath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "SetProjectFilePath");

	Params::UBlueprintPathsLibrary_SetProjectFilePath_Params Parms{};

	Parms.NewGameProjectFilePath = NewGameProjectFilePath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintPathsLibrary.SetExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InNewExtension                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::SetExtension(const class FString& InPath, const class FString& InNewExtension)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "SetExtension");

	Params::UBlueprintPathsLibrary_SetExtension_Params Parms{};

	Parms.InPath = InPath;
	Parms.InNewExtension = InNewExtension;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ScreenShotDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ScreenShotDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ScreenShotDir");

	Params::UBlueprintPathsLibrary_ScreenShotDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.SandboxesDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::SandboxesDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "SandboxesDir");

	Params::UBlueprintPathsLibrary_SandboxesDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.RootDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::RootDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "RootDir");

	Params::UBlueprintPathsLibrary_RootDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.RemoveDuplicateSlashes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutPath                                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::RemoveDuplicateSlashes(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "RemoveDuplicateSlashes");

	Params::UBlueprintPathsLibrary_RemoveDuplicateSlashes_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

}


// Function Engine.BlueprintPathsLibrary.ProjectUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectUserDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectUserDir");

	Params::UBlueprintPathsLibrary_ProjectUserDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectSavedDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectSavedDir");

	Params::UBlueprintPathsLibrary_ProjectSavedDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectPluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectPluginsDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectPluginsDir");

	Params::UBlueprintPathsLibrary_ProjectPluginsDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectPersistentDownloadDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectPersistentDownloadDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectPersistentDownloadDir");

	Params::UBlueprintPathsLibrary_ProjectPersistentDownloadDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectModsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectModsDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectModsDir");

	Params::UBlueprintPathsLibrary_ProjectModsDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectLogDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectLogDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectLogDir");

	Params::UBlueprintPathsLibrary_ProjectLogDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectIntermediateDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectIntermediateDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectIntermediateDir");

	Params::UBlueprintPathsLibrary_ProjectIntermediateDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectDir");

	Params::UBlueprintPathsLibrary_ProjectDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectContentDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectContentDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectContentDir");

	Params::UBlueprintPathsLibrary_ProjectContentDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProjectConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectConfigDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProjectConfigDir");

	Params::UBlueprintPathsLibrary_ProjectConfigDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ProfilingDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProfilingDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ProfilingDir");

	Params::UBlueprintPathsLibrary_ProfilingDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.NormalizeFilename
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutPath                                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::NormalizeFilename(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "NormalizeFilename");

	Params::UBlueprintPathsLibrary_NormalizeFilename_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

}


// Function Engine.BlueprintPathsLibrary.NormalizeDirectoryName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutPath                                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::NormalizeDirectoryName(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "NormalizeDirectoryName");

	Params::UBlueprintPathsLibrary_NormalizeDirectoryName_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

}


// Function Engine.BlueprintPathsLibrary.MakeValidFileName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InReplacementChar                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::MakeValidFileName(const class FString& InString, const class FString& InReplacementChar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "MakeValidFileName");

	Params::UBlueprintPathsLibrary_MakeValidFileName_Params Parms{};

	Parms.InString = InString;
	Parms.InReplacementChar = InReplacementChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.MakeStandardFilename
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutPath                                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::MakeStandardFilename(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "MakeStandardFilename");

	Params::UBlueprintPathsLibrary_MakeStandardFilename_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

}


// Function Engine.BlueprintPathsLibrary.MakePlatformFilename
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutPath                                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::MakePlatformFilename(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "MakePlatformFilename");

	Params::UBlueprintPathsLibrary_MakePlatformFilename_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

}


// Function Engine.BlueprintPathsLibrary.MakePathRelativeTo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InRelativeTo                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutPath                                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::MakePathRelativeTo(const class FString& InPath, const class FString& InRelativeTo, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "MakePathRelativeTo");

	Params::UBlueprintPathsLibrary_MakePathRelativeTo_Params Parms{};

	Parms.InPath = InPath;
	Parms.InRelativeTo = InRelativeTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.LaunchDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::LaunchDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "LaunchDir");

	Params::UBlueprintPathsLibrary_LaunchDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.IsSamePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      PathA                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PathB                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsSamePath(const class FString& PathA, const class FString& PathB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "IsSamePath");

	Params::UBlueprintPathsLibrary_IsSamePath_Params Parms{};

	Parms.PathA = PathA;
	Parms.PathB = PathB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.IsRestrictedPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsRestrictedPath(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "IsRestrictedPath");

	Params::UBlueprintPathsLibrary_IsRestrictedPath_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.IsRelative
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsRelative(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "IsRelative");

	Params::UBlueprintPathsLibrary_IsRelative_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.IsProjectFilePathSet
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsProjectFilePathSet()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "IsProjectFilePathSet");

	Params::UBlueprintPathsLibrary_IsProjectFilePathSet_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.IsDrive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsDrive(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "IsDrive");

	Params::UBlueprintPathsLibrary_IsDrive_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.HasProjectPersistentDownloadDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::HasProjectPersistentDownloadDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "HasProjectPersistentDownloadDir");

	Params::UBlueprintPathsLibrary_HasProjectPersistentDownloadDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetToolTipLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class FString> UBlueprintPathsLibrary::GetToolTipLocalizationPaths()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetToolTipLocalizationPaths");

	Params::UBlueprintPathsLibrary_GetToolTipLocalizationPaths_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetRestrictedFolderNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class FString> UBlueprintPathsLibrary::GetRestrictedFolderNames()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetRestrictedFolderNames");

	Params::UBlueprintPathsLibrary_GetRestrictedFolderNames_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetRelativePathToRoot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetRelativePathToRoot()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetRelativePathToRoot");

	Params::UBlueprintPathsLibrary_GetRelativePathToRoot_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetPropertyNameLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class FString> UBlueprintPathsLibrary::GetPropertyNameLocalizationPaths()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetPropertyNameLocalizationPaths");

	Params::UBlueprintPathsLibrary_GetPropertyNameLocalizationPaths_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetProjectFilePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetProjectFilePath()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetProjectFilePath");

	Params::UBlueprintPathsLibrary_GetProjectFilePath_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetPath(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetPath");

	Params::UBlueprintPathsLibrary_GetPath_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetInvalidFileSystemChars
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetInvalidFileSystemChars()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetInvalidFileSystemChars");

	Params::UBlueprintPathsLibrary_GetInvalidFileSystemChars_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetGameLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class FString> UBlueprintPathsLibrary::GetGameLocalizationPaths()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetGameLocalizationPaths");

	Params::UBlueprintPathsLibrary_GetGameLocalizationPaths_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludeDot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetExtension(const class FString& InPath, bool bIncludeDot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetExtension");

	Params::UBlueprintPathsLibrary_GetExtension_Params Parms{};

	Parms.InPath = InPath;
	Parms.bIncludeDot = bIncludeDot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetEngineLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class FString> UBlueprintPathsLibrary::GetEngineLocalizationPaths()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetEngineLocalizationPaths");

	Params::UBlueprintPathsLibrary_GetEngineLocalizationPaths_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetEditorLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

TArray<class FString> UBlueprintPathsLibrary::GetEditorLocalizationPaths()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetEditorLocalizationPaths");

	Params::UBlueprintPathsLibrary_GetEditorLocalizationPaths_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetCleanFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetCleanFilename(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetCleanFilename");

	Params::UBlueprintPathsLibrary_GetCleanFilename_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GetBaseFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRemovePath                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetBaseFilename(const class FString& InPath, bool bRemovePath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GetBaseFilename");

	Params::UBlueprintPathsLibrary_GetBaseFilename_Params Parms{};

	Parms.InPath = InPath;
	Parms.bRemovePath = bRemovePath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GeneratedConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GeneratedConfigDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GeneratedConfigDir");

	Params::UBlueprintPathsLibrary_GeneratedConfigDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GameUserDeveloperDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GameUserDeveloperDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GameUserDeveloperDir");

	Params::UBlueprintPathsLibrary_GameUserDeveloperDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GameSourceDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GameSourceDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GameSourceDir");

	Params::UBlueprintPathsLibrary_GameSourceDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GameDevelopersDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GameDevelopersDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GameDevelopersDir");

	Params::UBlueprintPathsLibrary_GameDevelopersDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.GameAgnosticSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GameAgnosticSavedDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "GameAgnosticSavedDir");

	Params::UBlueprintPathsLibrary_GameAgnosticSavedDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.FileExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::FileExists(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "FileExists");

	Params::UBlueprintPathsLibrary_FileExists_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.FeaturePackDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::FeaturePackDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "FeaturePackDir");

	Params::UBlueprintPathsLibrary_FeaturePackDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EnterprisePluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EnterprisePluginsDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EnterprisePluginsDir");

	Params::UBlueprintPathsLibrary_EnterprisePluginsDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EnterpriseFeaturePackDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EnterpriseFeaturePackDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EnterpriseFeaturePackDir");

	Params::UBlueprintPathsLibrary_EnterpriseFeaturePackDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EnterpriseDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EnterpriseDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EnterpriseDir");

	Params::UBlueprintPathsLibrary_EnterpriseDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EngineVersionAgnosticUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineVersionAgnosticUserDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EngineVersionAgnosticUserDir");

	Params::UBlueprintPathsLibrary_EngineVersionAgnosticUserDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EngineUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineUserDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EngineUserDir");

	Params::UBlueprintPathsLibrary_EngineUserDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EngineSourceDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineSourceDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EngineSourceDir");

	Params::UBlueprintPathsLibrary_EngineSourceDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EngineSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineSavedDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EngineSavedDir");

	Params::UBlueprintPathsLibrary_EngineSavedDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EnginePluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EnginePluginsDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EnginePluginsDir");

	Params::UBlueprintPathsLibrary_EnginePluginsDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EngineIntermediateDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineIntermediateDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EngineIntermediateDir");

	Params::UBlueprintPathsLibrary_EngineIntermediateDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EngineDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EngineDir");

	Params::UBlueprintPathsLibrary_EngineDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EngineContentDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineContentDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EngineContentDir");

	Params::UBlueprintPathsLibrary_EngineContentDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.EngineConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineConfigDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "EngineConfigDir");

	Params::UBlueprintPathsLibrary_EngineConfigDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.DirectoryExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::DirectoryExists(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "DirectoryExists");

	Params::UBlueprintPathsLibrary_DirectoryExists_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.DiffDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::DiffDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "DiffDir");

	Params::UBlueprintPathsLibrary_DiffDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.CreateTempFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Path                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Extension                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::CreateTempFilename(const class FString& Path, const class FString& Prefix, const class FString& Extension)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "CreateTempFilename");

	Params::UBlueprintPathsLibrary_CreateTempFilename_Params Parms{};

	Parms.Path = Path;
	Parms.Prefix = Prefix;
	Parms.Extension = Extension;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ConvertToSandboxPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InSandboxName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ConvertToSandboxPath(const class FString& InPath, const class FString& InSandboxName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ConvertToSandboxPath");

	Params::UBlueprintPathsLibrary_ConvertToSandboxPath_Params Parms{};

	Parms.InPath = InPath;
	Parms.InSandboxName = InSandboxName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ConvertRelativePathToFull
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InBasePath                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ConvertRelativePathToFull(const class FString& InPath, const class FString& InBasePath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ConvertRelativePathToFull");

	Params::UBlueprintPathsLibrary_ConvertRelativePathToFull_Params Parms{};

	Parms.InPath = InPath;
	Parms.InBasePath = InBasePath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ConvertFromSandboxPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InSandboxName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ConvertFromSandboxPath(const class FString& InPath, const class FString& InSandboxName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ConvertFromSandboxPath");

	Params::UBlueprintPathsLibrary_ConvertFromSandboxPath_Params Parms{};

	Parms.InPath = InPath;
	Parms.InSandboxName = InSandboxName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.Combine
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              InPaths                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::Combine(TArray<class FString>& InPaths)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "Combine");

	Params::UBlueprintPathsLibrary_Combine_Params Parms{};

	Parms.InPaths = InPaths;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.CollapseRelativeDirectories
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutPath                                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::CollapseRelativeDirectories(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "CollapseRelativeDirectories");

	Params::UBlueprintPathsLibrary_CollapseRelativeDirectories_Params Parms{};

	Parms.InPath = InPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.CloudDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::CloudDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "CloudDir");

	Params::UBlueprintPathsLibrary_CloudDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.ChangeExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InPath                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InNewExtension                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ChangeExtension(const class FString& InPath, const class FString& InNewExtension)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "ChangeExtension");

	Params::UBlueprintPathsLibrary_ChangeExtension_Params Parms{};

	Parms.InPath = InPath;
	Parms.InNewExtension = InNewExtension;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.BugItDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::BugItDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "BugItDir");

	Params::UBlueprintPathsLibrary_BugItDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.AutomationTransientDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::AutomationTransientDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "AutomationTransientDir");

	Params::UBlueprintPathsLibrary_AutomationTransientDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.AutomationLogDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::AutomationLogDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "AutomationLogDir");

	Params::UBlueprintPathsLibrary_AutomationLogDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPathsLibrary.AutomationDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::AutomationDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPathsLibrary", "AutomationDir");

	Params::UBlueprintPathsLibrary_AutomationDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.PlatformGameInstance
// (None)

class UClass* UPlatformGameInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlatformGameInstance");

	return Clss;
}


// PlatformGameInstance Engine.Default__PlatformGameInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlatformGameInstance* UPlatformGameInstance::GetDefaultObj()
{
	static class UPlatformGameInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlatformGameInstance*>(UPlatformGameInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BlueprintPlatformLibrary
// (None)

class UClass* UBlueprintPlatformLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueprintPlatformLibrary");

	return Clss;
}


// BlueprintPlatformLibrary Engine.Default__BlueprintPlatformLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprintPlatformLibrary* UBlueprintPlatformLibrary::GetDefaultObj()
{
	static class UBlueprintPlatformLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprintPlatformLibrary*>(UBlueprintPlatformLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationFromNow
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              InSecondsFromNow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Title                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Body                                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Action                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      ActivationEvent                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintPlatformLibrary::ScheduleLocalNotificationFromNow(int32 InSecondsFromNow, class FText& Title, class FText& Body, class FText& Action, const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "ScheduleLocalNotificationFromNow");

	Params::UBlueprintPlatformLibrary_ScheduleLocalNotificationFromNow_Params Parms{};

	Parms.InSecondsFromNow = InSecondsFromNow;
	Parms.Title = Title;
	Parms.Body = Body;
	Parms.Action = Action;
	Parms.ActivationEvent = ActivationEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeFromNow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              InSecondsFromNow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ActivationEvent                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPlatformLibrary::ScheduleLocalNotificationBadgeFromNow(int32 InSecondsFromNow, const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "ScheduleLocalNotificationBadgeFromNow");

	Params::UBlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow_Params Parms{};

	Parms.InSecondsFromNow = InSecondsFromNow;
	Parms.ActivationEvent = ActivationEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeAtTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                   FireDateTime                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               LocalTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ActivationEvent                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintPlatformLibrary::ScheduleLocalNotificationBadgeAtTime(struct FDateTime& FireDateTime, bool LocalTime, const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "ScheduleLocalNotificationBadgeAtTime");

	Params::UBlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime_Params Parms{};

	Parms.FireDateTime = FireDateTime;
	Parms.LocalTime = LocalTime;
	Parms.ActivationEvent = ActivationEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationAtTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                   FireDateTime                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               LocalTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Title                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Body                                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        Action                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      ActivationEvent                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintPlatformLibrary::ScheduleLocalNotificationAtTime(struct FDateTime& FireDateTime, bool LocalTime, class FText& Title, class FText& Body, class FText& Action, const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "ScheduleLocalNotificationAtTime");

	Params::UBlueprintPlatformLibrary_ScheduleLocalNotificationAtTime_Params Parms{};

	Parms.FireDateTime = FireDateTime;
	Parms.LocalTime = LocalTime;
	Parms.Title = Title;
	Parms.Body = Body;
	Parms.Action = Action;
	Parms.ActivationEvent = ActivationEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPlatformLibrary.GetLaunchNotification
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                               NotificationLaunchedApp                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ActivationEvent                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              FireDate                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPlatformLibrary::GetLaunchNotification(bool* NotificationLaunchedApp, class FString* ActivationEvent, int32* FireDate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "GetLaunchNotification");

	Params::UBlueprintPlatformLibrary_GetLaunchNotification_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (NotificationLaunchedApp != nullptr)
		*NotificationLaunchedApp = Parms.NotificationLaunchedApp;

	if (ActivationEvent != nullptr)
		*ActivationEvent = std::move(Parms.ActivationEvent);

	if (FireDate != nullptr)
		*FireDate = Parms.FireDate;

}


// Function Engine.BlueprintPlatformLibrary.GetDeviceOrientation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class EScreenOrientation      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EScreenOrientation UBlueprintPlatformLibrary::GetDeviceOrientation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "GetDeviceOrientation");

	Params::UBlueprintPlatformLibrary_GetDeviceOrientation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintPlatformLibrary.ClearAllLocalNotifications
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UBlueprintPlatformLibrary::ClearAllLocalNotifications()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "ClearAllLocalNotifications");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintPlatformLibrary.CancelLocalNotificationById
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              NotificationId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPlatformLibrary::CancelLocalNotificationById(int32 NotificationId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "CancelLocalNotificationById");

	Params::UBlueprintPlatformLibrary_CancelLocalNotificationById_Params Parms{};

	Parms.NotificationId = NotificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintPlatformLibrary.CancelLocalNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      ActivationEvent                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPlatformLibrary::CancelLocalNotification(const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintPlatformLibrary", "CancelLocalNotification");

	Params::UBlueprintPlatformLibrary_CancelLocalNotification_Params Parms{};

	Parms.ActivationEvent = ActivationEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.BlueprintSetLibrary
// (None)

class UClass* UBlueprintSetLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BlueprintSetLibrary");

	return Clss;
}


// BlueprintSetLibrary Engine.Default__BlueprintSetLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UBlueprintSetLibrary* UBlueprintSetLibrary::GetDefaultObj()
{
	static class UBlueprintSetLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UBlueprintSetLibrary*>(UBlueprintSetLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.BlueprintSetLibrary.SetSetPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<int32>                        Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::SetSetPropertyByName(class UObject* Object, class FName PropertyName, TSet<int32>& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "SetSetPropertyByName");

	Params::UBlueprintSetLibrary_SetSetPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintSetLibrary.Set_Union
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                        B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                        Result                                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Union(TSet<int32>& A, TSet<int32>& B, TSet<int32>* Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_Union");

	Params::UBlueprintSetLibrary_Set_Union_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

}


// Function Engine.BlueprintSetLibrary.Set_ToArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      Result                                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_ToArray(TSet<int32>& A, TArray<int32>* Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_ToArray");

	Params::UBlueprintSetLibrary_Set_ToArray_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

}


// Function Engine.BlueprintSetLibrary.Set_RemoveItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        TargetSet                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      Items                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_RemoveItems(TSet<int32>& TargetSet, TArray<int32>& Items)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_RemoveItems");

	Params::UBlueprintSetLibrary_Set_RemoveItems_Params Parms{};

	Parms.TargetSet = TargetSet;
	Parms.Items = Items;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintSetLibrary.Set_Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        TargetSet                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Item                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintSetLibrary::Set_Remove(TSet<int32>& TargetSet, int32& Item)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_Remove");

	Params::UBlueprintSetLibrary_Set_Remove_Params Parms{};

	Parms.TargetSet = TargetSet;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintSetLibrary.Set_Length
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<int32>                        TargetSet                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintSetLibrary::Set_Length(TSet<int32>& TargetSet)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_Length");

	Params::UBlueprintSetLibrary_Set_Length_Params Parms{};

	Parms.TargetSet = TargetSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintSetLibrary.Set_Intersection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                        B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                        Result                                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Intersection(TSet<int32>& A, TSet<int32>& B, TSet<int32>* Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_Intersection");

	Params::UBlueprintSetLibrary_Set_Intersection_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

}


// Function Engine.BlueprintSetLibrary.Set_Difference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                        B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                        Result                                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Difference(TSet<int32>& A, TSet<int32>& B, TSet<int32>* Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_Difference");

	Params::UBlueprintSetLibrary_Set_Difference_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

}


// Function Engine.BlueprintSetLibrary.Set_Contains
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<int32>                        TargetSet                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ItemToFind                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintSetLibrary::Set_Contains(TSet<int32>& TargetSet, int32& ItemToFind)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_Contains");

	Params::UBlueprintSetLibrary_Set_Contains_Params Parms{};

	Parms.TargetSet = TargetSet;
	Parms.ItemToFind = ItemToFind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.BlueprintSetLibrary.Set_Clear
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        TargetSet                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Clear(TSet<int32>& TargetSet)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_Clear");

	Params::UBlueprintSetLibrary_Set_Clear_Params Parms{};

	Parms.TargetSet = TargetSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintSetLibrary.Set_AddItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        TargetSet                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      NewItems                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_AddItems(TSet<int32>& TargetSet, TArray<int32>& NewItems)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_AddItems");

	Params::UBlueprintSetLibrary_Set_AddItems_Params Parms{};

	Parms.TargetSet = TargetSet;
	Parms.NewItems = NewItems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.BlueprintSetLibrary.Set_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                        TargetSet                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              NewItem                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Add(TSet<int32>& TargetSet, int32& NewItem)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("BlueprintSetLibrary", "Set_Add");

	Params::UBlueprintSetLibrary_Set_Add_Params Parms{};

	Parms.TargetSet = TargetSet;
	Parms.NewItem = NewItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.BodySetup
// (None)

class UClass* UBodySetup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BodySetup");

	return Clss;
}


// BodySetup Engine.Default__BodySetup
// (Public, Transactional, ClassDefaultObject, ArchetypeObject)

class UBodySetup* UBodySetup::GetDefaultObj()
{
	static class UBodySetup* Default = nullptr;

	if (!Default)
		Default = static_cast<UBodySetup*>(UBodySetup::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BoneMaskFilter
// (None)

class UClass* UBoneMaskFilter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BoneMaskFilter");

	return Clss;
}


// BoneMaskFilter Engine.Default__BoneMaskFilter
// (Public, ClassDefaultObject, ArchetypeObject)

class UBoneMaskFilter* UBoneMaskFilter::GetDefaultObj()
{
	static class UBoneMaskFilter* Default = nullptr;

	if (!Default)
		Default = static_cast<UBoneMaskFilter*>(UBoneMaskFilter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BookmarkBase
// (None)

class UClass* UBookmarkBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BookmarkBase");

	return Clss;
}


// BookmarkBase Engine.Default__BookmarkBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UBookmarkBase* UBookmarkBase::GetDefaultObj()
{
	static class UBookmarkBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UBookmarkBase*>(UBookmarkBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BookMark
// (None)

class UClass* UBookMark::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BookMark");

	return Clss;
}


// BookMark Engine.Default__BookMark
// (Public, ClassDefaultObject, ArchetypeObject)

class UBookMark* UBookMark::GetDefaultObj()
{
	static class UBookMark* Default = nullptr;

	if (!Default)
		Default = static_cast<UBookMark*>(UBookMark::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BookMark2D
// (None)

class UClass* UBookMark2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BookMark2D");

	return Clss;
}


// BookMark2D Engine.Default__BookMark2D
// (Public, ClassDefaultObject, ArchetypeObject)

class UBookMark2D* UBookMark2D::GetDefaultObj()
{
	static class UBookMark2D* Default = nullptr;

	if (!Default)
		Default = static_cast<UBookMark2D*>(UBookMark2D::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ReflectionCapture
// (Actor)

class UClass* AReflectionCapture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReflectionCapture");

	return Clss;
}


// ReflectionCapture Engine.Default__ReflectionCapture
// (Public, ClassDefaultObject, ArchetypeObject)

class AReflectionCapture* AReflectionCapture::GetDefaultObj()
{
	static class AReflectionCapture* Default = nullptr;

	if (!Default)
		Default = static_cast<AReflectionCapture*>(AReflectionCapture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BoxReflectionCapture
// (Actor)

class UClass* ABoxReflectionCapture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BoxReflectionCapture");

	return Clss;
}


// BoxReflectionCapture Engine.Default__BoxReflectionCapture
// (Public, ClassDefaultObject, ArchetypeObject)

class ABoxReflectionCapture* ABoxReflectionCapture::GetDefaultObj()
{
	static class ABoxReflectionCapture* Default = nullptr;

	if (!Default)
		Default = static_cast<ABoxReflectionCapture*>(ABoxReflectionCapture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ReflectionCaptureComponent
// (SceneComponent)

class UClass* UReflectionCaptureComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReflectionCaptureComponent");

	return Clss;
}


// ReflectionCaptureComponent Engine.Default__ReflectionCaptureComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UReflectionCaptureComponent* UReflectionCaptureComponent::GetDefaultObj()
{
	static class UReflectionCaptureComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UReflectionCaptureComponent*>(UReflectionCaptureComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BoxReflectionCaptureComponent
// (SceneComponent)

class UClass* UBoxReflectionCaptureComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BoxReflectionCaptureComponent");

	return Clss;
}


// BoxReflectionCaptureComponent Engine.Default__BoxReflectionCaptureComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UBoxReflectionCaptureComponent* UBoxReflectionCaptureComponent::GetDefaultObj()
{
	static class UBoxReflectionCaptureComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UBoxReflectionCaptureComponent*>(UBoxReflectionCaptureComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Breakpoint
// (None)

class UClass* UBreakpoint::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Breakpoint");

	return Clss;
}


// Breakpoint Engine.Default__Breakpoint
// (Public, ClassDefaultObject, ArchetypeObject)

class UBreakpoint* UBreakpoint::GetDefaultObj()
{
	static class UBreakpoint* Default = nullptr;

	if (!Default)
		Default = static_cast<UBreakpoint*>(UBreakpoint::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BrushBuilder
// (None)

class UClass* UBrushBuilder::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BrushBuilder");

	return Clss;
}


// BrushBuilder Engine.Default__BrushBuilder
// (Public, ClassDefaultObject, ArchetypeObject)

class UBrushBuilder* UBrushBuilder::GetDefaultObj()
{
	static class UBrushBuilder* Default = nullptr;

	if (!Default)
		Default = static_cast<UBrushBuilder*>(UBrushBuilder::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BrushComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UBrushComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BrushComponent");

	return Clss;
}


// BrushComponent Engine.Default__BrushComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UBrushComponent* UBrushComponent::GetDefaultObj()
{
	static class UBrushComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UBrushComponent*>(UBrushComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.BrushShape
// (Actor)

class UClass* ABrushShape::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("BrushShape");

	return Clss;
}


// BrushShape Engine.Default__BrushShape
// (Public, ClassDefaultObject, ArchetypeObject)

class ABrushShape* ABrushShape::GetDefaultObj()
{
	static class ABrushShape* Default = nullptr;

	if (!Default)
		Default = static_cast<ABrushShape*>(ABrushShape::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ButtonStyleAsset
// (None)

class UClass* UButtonStyleAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ButtonStyleAsset");

	return Clss;
}


// ButtonStyleAsset Engine.Default__ButtonStyleAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UButtonStyleAsset* UButtonStyleAsset::GetDefaultObj()
{
	static class UButtonStyleAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UButtonStyleAsset*>(UButtonStyleAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CameraAnim
// (None)

class UClass* UCameraAnim::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CameraAnim");

	return Clss;
}


// CameraAnim Engine.Default__CameraAnim
// (Public, ClassDefaultObject, ArchetypeObject)

class UCameraAnim* UCameraAnim::GetDefaultObj()
{
	static class UCameraAnim* Default = nullptr;

	if (!Default)
		Default = static_cast<UCameraAnim*>(UCameraAnim::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CameraAnimInst
// (None)

class UClass* UCameraAnimInst::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CameraAnimInst");

	return Clss;
}


// CameraAnimInst Engine.Default__CameraAnimInst
// (Public, ClassDefaultObject, ArchetypeObject)

class UCameraAnimInst* UCameraAnimInst::GetDefaultObj()
{
	static class UCameraAnimInst* Default = nullptr;

	if (!Default)
		Default = static_cast<UCameraAnimInst*>(UCameraAnimInst::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CameraAnimInst.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bImmediate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAnimInst::Stop(bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraAnimInst", "Stop");

	Params::UCameraAnimInst_Stop_Params Parms{};

	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraAnimInst.SetScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewDuration                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAnimInst::SetScale(float NewDuration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraAnimInst", "SetScale");

	Params::UCameraAnimInst_SetScale_Params Parms{};

	Parms.NewDuration = NewDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraAnimInst.SetDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewDuration                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAnimInst::SetDuration(float NewDuration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraAnimInst", "SetDuration");

	Params::UCameraAnimInst_SetDuration_Params Parms{};

	Parms.NewDuration = NewDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.CameraBlockingVolume
// (Actor)

class UClass* ACameraBlockingVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CameraBlockingVolume");

	return Clss;
}


// CameraBlockingVolume Engine.Default__CameraBlockingVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ACameraBlockingVolume* ACameraBlockingVolume::GetDefaultObj()
{
	static class ACameraBlockingVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ACameraBlockingVolume*>(ACameraBlockingVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CameraModifier
// (None)

class UClass* UCameraModifier::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CameraModifier");

	return Clss;
}


// CameraModifier Engine.Default__CameraModifier
// (Public, ClassDefaultObject, ArchetypeObject)

class UCameraModifier* UCameraModifier::GetDefaultObj()
{
	static class UCameraModifier* Default = nullptr;

	if (!Default)
		Default = static_cast<UCameraModifier*>(UCameraModifier::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CameraModifier.IsDisabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraModifier::IsDisabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraModifier", "IsDisabled");

	Params::UCameraModifier_IsDisabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CameraModifier.GetViewTarget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCameraModifier::GetViewTarget()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraModifier", "GetViewTarget");

	Params::UCameraModifier_GetViewTarget_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CameraModifier.EnableModifier
// (Native, Public, BlueprintCallable)
// Parameters:

void UCameraModifier::EnableModifier()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraModifier", "EnableModifier");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraModifier.DisableModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bImmediate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModifier::DisableModifier(bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraModifier", "DisableModifier");

	Params::UCameraModifier_DisableModifier_Params Parms{};

	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CameraModifier.BlueprintModifyPostProcess
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PostProcessBlendWeight                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPostProcessSettings        PostProcessSettings                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UCameraModifier::BlueprintModifyPostProcess(float DeltaTime, float* PostProcessBlendWeight, struct FPostProcessSettings* PostProcessSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraModifier", "BlueprintModifyPostProcess");

	Params::UCameraModifier_BlueprintModifyPostProcess_Params Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	if (PostProcessBlendWeight != nullptr)
		*PostProcessBlendWeight = Parms.PostProcessBlendWeight;

	if (PostProcessSettings != nullptr)
		*PostProcessSettings = std::move(Parms.PostProcessSettings);

}


// Function Engine.CameraModifier.BlueprintModifyCamera
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ViewLocation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ViewRotation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              FOV                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewViewLocation                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewViewRotation                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              NewFOV                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModifier::BlueprintModifyCamera(float DeltaTime, const struct FVector& ViewLocation, const struct FRotator& ViewRotation, float FOV, struct FVector* NewViewLocation, struct FRotator* NewViewRotation, float* NewFOV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraModifier", "BlueprintModifyCamera");

	Params::UCameraModifier_BlueprintModifyCamera_Params Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.ViewLocation = ViewLocation;
	Parms.ViewRotation = ViewRotation;
	Parms.FOV = FOV;

	UObject::ProcessEvent(Func, &Parms);

	if (NewViewLocation != nullptr)
		*NewViewLocation = std::move(Parms.NewViewLocation);

	if (NewViewRotation != nullptr)
		*NewViewRotation = std::move(Parms.NewViewRotation);

	if (NewFOV != nullptr)
		*NewFOV = Parms.NewFOV;

}


// Class Engine.CameraModifier_CameraShake
// (None)

class UClass* UCameraModifier_CameraShake::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CameraModifier_CameraShake");

	return Clss;
}


// CameraModifier_CameraShake Engine.Default__CameraModifier_CameraShake
// (Public, ClassDefaultObject, ArchetypeObject)

class UCameraModifier_CameraShake* UCameraModifier_CameraShake::GetDefaultObj()
{
	static class UCameraModifier_CameraShake* Default = nullptr;

	if (!Default)
		Default = static_cast<UCameraModifier_CameraShake*>(UCameraModifier_CameraShake::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CameraShake
// (None)

class UClass* UCameraShake::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CameraShake");

	return Clss;
}


// CameraShake Engine.Default__CameraShake
// (Public, ClassDefaultObject, ArchetypeObject)

class UCameraShake* UCameraShake::GetDefaultObj()
{
	static class UCameraShake* Default = nullptr;

	if (!Default)
		Default = static_cast<UCameraShake*>(UCameraShake::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CameraShake.ReceiveStopShake
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                               bImmediately                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraShake::ReceiveStopShake(bool bImmediately)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraShake", "ReceiveStopShake");

	Params::UCameraShake_ReceiveStopShake_Params Parms{};

	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.CameraShake.ReceivePlayShake
// (Event, Public, BlueprintEvent)
// Parameters:
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraShake::ReceivePlayShake(float Scale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraShake", "ReceivePlayShake");

	Params::UCameraShake_ReceivePlayShake_Params Parms{};

	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.CameraShake.ReceiveIsFinished
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraShake::ReceiveIsFinished()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraShake", "ReceiveIsFinished");

	Params::UCameraShake_ReceiveIsFinished_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CameraShake.BlueprintUpdateCameraShake
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMinimalViewInfo            POV                                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMinimalViewInfo            ModifiedPOV                                                      (Parm, OutParm, NativeAccessSpecifierPublic)

void UCameraShake::BlueprintUpdateCameraShake(float DeltaTime, float Alpha, struct FMinimalViewInfo& POV, struct FMinimalViewInfo* ModifiedPOV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CameraShake", "BlueprintUpdateCameraShake");

	Params::UCameraShake_BlueprintUpdateCameraShake_Params Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Alpha = Alpha;
	Parms.POV = POV;

	UObject::ProcessEvent(Func, &Parms);

	if (ModifiedPOV != nullptr)
		*ModifiedPOV = std::move(Parms.ModifiedPOV);

}


// Class Engine.Canvas
// (None)

class UClass* UCanvas::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Canvas");

	return Clss;
}


// Canvas Engine.Default__Canvas
// (Public, ClassDefaultObject, ArchetypeObject)

class UCanvas* UCanvas::GetDefaultObj()
{
	static class UCanvas* Default = nullptr;

	if (!Default)
		Default = static_cast<UCanvas*>(UCanvas::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Canvas.K2_TextSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UFont*                       RenderFont                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      RenderText                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCanvas::K2_TextSize(class UFont* RenderFont, const class FString& RenderText, const struct FVector2D& Scale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_TextSize");

	Params::UCanvas_K2_TextSize_Params Parms{};

	Parms.RenderFont = RenderFont;
	Parms.RenderText = RenderText;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Canvas.K2_StrLen
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UFont*                       RenderFont                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      RenderText                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCanvas::K2_StrLen(class UFont* RenderFont, const class FString& RenderText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_StrLen");

	Params::UCanvas_K2_StrLen_Params Parms{};

	Parms.RenderFont = RenderFont;
	Parms.RenderText = RenderText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Canvas.K2_Project
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     WorldLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCanvas::K2_Project(const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_Project");

	Params::UCanvas_K2_Project_Params Parms{};

	Parms.WorldLocation = WorldLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Canvas.K2_DrawTriangle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                    RenderTexture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCanvasUVTri>        Triangles                                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawTriangle(class UTexture* RenderTexture, const TArray<struct FCanvasUVTri>& Triangles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawTriangle");

	Params::UCanvas_K2_DrawTriangle_Params Parms{};

	Parms.RenderTexture = RenderTexture;
	Parms.Triangles = Triangles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_DrawTexture
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                    RenderTexture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   CoordinatePosition                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   CoordinateSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                RenderColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBlendMode              BlendMode                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   PivotPoint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawTexture(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, enum class EBlendMode BlendMode, float Rotation, const struct FVector2D& PivotPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawTexture");

	Params::UCanvas_K2_DrawTexture_Params Parms{};

	Parms.RenderTexture = RenderTexture;
	Parms.ScreenPosition = ScreenPosition;
	Parms.ScreenSize = ScreenSize;
	Parms.CoordinatePosition = CoordinatePosition;
	Parms.CoordinateSize = CoordinateSize;
	Parms.RenderColor = RenderColor;
	Parms.BlendMode = BlendMode;
	Parms.Rotation = Rotation;
	Parms.PivotPoint = PivotPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_DrawText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UFont*                       RenderFont                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      RenderText                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                RenderColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Kerning                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ShadowColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ShadowOffset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCentreX                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCentreY                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOutlined                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                OutlineColor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawText(class UFont* RenderFont, const class FString& RenderText, const struct FVector2D& ScreenPosition, const struct FVector2D& Scale, const struct FLinearColor& RenderColor, float Kerning, const struct FLinearColor& ShadowColor, const struct FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, const struct FLinearColor& OutlineColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawText");

	Params::UCanvas_K2_DrawText_Params Parms{};

	Parms.RenderFont = RenderFont;
	Parms.RenderText = RenderText;
	Parms.ScreenPosition = ScreenPosition;
	Parms.Scale = Scale;
	Parms.RenderColor = RenderColor;
	Parms.Kerning = Kerning;
	Parms.ShadowColor = ShadowColor;
	Parms.ShadowOffset = ShadowOffset;
	Parms.bCentreX = bCentreX;
	Parms.bCentreY = bCentreY;
	Parms.bOutlined = bOutlined;
	Parms.OutlineColor = OutlineColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_DrawPolygon
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                    RenderTexture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumberOfSides                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                RenderColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawPolygon(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& Radius, int32 NumberOfSides, const struct FLinearColor& RenderColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawPolygon");

	Params::UCanvas_K2_DrawPolygon_Params Parms{};

	Parms.RenderTexture = RenderTexture;
	Parms.ScreenPosition = ScreenPosition;
	Parms.Radius = Radius;
	Parms.NumberOfSides = NumberOfSides;
	Parms.RenderColor = RenderColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_DrawMaterialTriangle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          RenderMaterial                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCanvasUVTri>        Triangles                                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawMaterialTriangle(class UMaterialInterface* RenderMaterial, const TArray<struct FCanvasUVTri>& Triangles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawMaterialTriangle");

	Params::UCanvas_K2_DrawMaterialTriangle_Params Parms{};

	Parms.RenderMaterial = RenderMaterial;
	Parms.Triangles = Triangles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_DrawMaterial
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          RenderMaterial                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   CoordinatePosition                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   CoordinateSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   PivotPoint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawMaterial(class UMaterialInterface* RenderMaterial, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, float Rotation, const struct FVector2D& PivotPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawMaterial");

	Params::UCanvas_K2_DrawMaterial_Params Parms{};

	Parms.RenderMaterial = RenderMaterial;
	Parms.ScreenPosition = ScreenPosition;
	Parms.ScreenSize = ScreenSize;
	Parms.CoordinatePosition = CoordinatePosition;
	Parms.CoordinateSize = CoordinateSize;
	Parms.Rotation = Rotation;
	Parms.PivotPoint = PivotPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_DrawLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   ScreenPositionA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPositionB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                RenderColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawLine(const struct FVector2D& ScreenPositionA, const struct FVector2D& ScreenPositionB, float Thickness, const struct FLinearColor& RenderColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawLine");

	Params::UCanvas_K2_DrawLine_Params Parms{};

	Parms.ScreenPositionA = ScreenPositionA;
	Parms.ScreenPositionB = ScreenPositionB;
	Parms.Thickness = Thickness;
	Parms.RenderColor = RenderColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_DrawBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                RenderColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawBox(const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, float Thickness, const struct FLinearColor& RenderColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawBox");

	Params::UCanvas_K2_DrawBox_Params Parms{};

	Parms.ScreenPosition = ScreenPosition;
	Parms.ScreenSize = ScreenSize;
	Parms.Thickness = Thickness;
	Parms.RenderColor = RenderColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_DrawBorder
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                    BorderTexture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    BackgroundTexture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    LeftBorderTexture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    RightBorderTexture                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    TopBorderTexture                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    BottomBorderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   CoordinatePosition                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   CoordinateSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                RenderColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   BorderScale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   BackgroundScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   PivotPoint                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   CornerSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawBorder(class UTexture* BorderTexture, class UTexture* BackgroundTexture, class UTexture* LeftBorderTexture, class UTexture* RightBorderTexture, class UTexture* TopBorderTexture, class UTexture* BottomBorderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, const struct FVector2D& BorderScale, const struct FVector2D& BackgroundScale, float Rotation, const struct FVector2D& PivotPoint, const struct FVector2D& CornerSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_DrawBorder");

	Params::UCanvas_K2_DrawBorder_Params Parms{};

	Parms.BorderTexture = BorderTexture;
	Parms.BackgroundTexture = BackgroundTexture;
	Parms.LeftBorderTexture = LeftBorderTexture;
	Parms.RightBorderTexture = RightBorderTexture;
	Parms.TopBorderTexture = TopBorderTexture;
	Parms.BottomBorderTexture = BottomBorderTexture;
	Parms.ScreenPosition = ScreenPosition;
	Parms.ScreenSize = ScreenSize;
	Parms.CoordinatePosition = CoordinatePosition;
	Parms.CoordinateSize = CoordinateSize;
	Parms.RenderColor = RenderColor;
	Parms.BorderScale = BorderScale;
	Parms.BackgroundScale = BackgroundScale;
	Parms.Rotation = Rotation;
	Parms.PivotPoint = PivotPoint;
	Parms.CornerSize = CornerSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Canvas.K2_Deproject
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   ScreenPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldOrigin                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldDirection                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_Deproject(const struct FVector2D& ScreenPosition, struct FVector* WorldOrigin, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Canvas", "K2_Deproject");

	Params::UCanvas_K2_Deproject_Params Parms{};

	Parms.ScreenPosition = ScreenPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (WorldOrigin != nullptr)
		*WorldOrigin = std::move(Parms.WorldOrigin);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

}


// Class Engine.TextureRenderTarget
// (None)

class UClass* UTextureRenderTarget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextureRenderTarget");

	return Clss;
}


// TextureRenderTarget Engine.Default__TextureRenderTarget
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextureRenderTarget* UTextureRenderTarget::GetDefaultObj()
{
	static class UTextureRenderTarget* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextureRenderTarget*>(UTextureRenderTarget::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TextureRenderTarget2D
// (None)

class UClass* UTextureRenderTarget2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextureRenderTarget2D");

	return Clss;
}


// TextureRenderTarget2D Engine.Default__TextureRenderTarget2D
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextureRenderTarget2D* UTextureRenderTarget2D::GetDefaultObj()
{
	static class UTextureRenderTarget2D* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextureRenderTarget2D*>(UTextureRenderTarget2D::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CanvasRenderTarget2D
// (None)

class UClass* UCanvasRenderTarget2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CanvasRenderTarget2D");

	return Clss;
}


// CanvasRenderTarget2D Engine.Default__CanvasRenderTarget2D
// (Public, ClassDefaultObject, ArchetypeObject)

class UCanvasRenderTarget2D* UCanvasRenderTarget2D::GetDefaultObj()
{
	static class UCanvasRenderTarget2D* Default = nullptr;

	if (!Default)
		Default = static_cast<UCanvasRenderTarget2D*>(UCanvasRenderTarget2D::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CanvasRenderTarget2D.UpdateResource
// (Native, Public, BlueprintCallable)
// Parameters:

void UCanvasRenderTarget2D::UpdateResource()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CanvasRenderTarget2D", "UpdateResource");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CanvasRenderTarget2D.ReceiveUpdate
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCanvas*                     Canvas                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Width                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Height                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasRenderTarget2D::ReceiveUpdate(class UCanvas* Canvas, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CanvasRenderTarget2D", "ReceiveUpdate");

	Params::UCanvasRenderTarget2D_ReceiveUpdate_Params Parms{};

	Parms.Canvas = Canvas;
	Parms.Width = Width;
	Parms.Height = Height;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.CanvasRenderTarget2D.GetSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Width                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Height                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasRenderTarget2D::GetSize(int32* Width, int32* Height)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CanvasRenderTarget2D", "GetSize");

	Params::UCanvasRenderTarget2D_GetSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Width != nullptr)
		*Width = Parms.Width;

	if (Height != nullptr)
		*Height = Parms.Height;

}


// Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCanvasRenderTarget2D>CanvasRenderTarget2DClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Width                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Height                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCanvasRenderTarget2D*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCanvasRenderTarget2D* UCanvasRenderTarget2D::CreateCanvasRenderTarget2D(class UObject* WorldContextObject, TSubclassOf<class UCanvasRenderTarget2D> CanvasRenderTarget2DClass, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CanvasRenderTarget2D", "CreateCanvasRenderTarget2D");

	Params::UCanvasRenderTarget2D_CreateCanvasRenderTarget2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CanvasRenderTarget2DClass = CanvasRenderTarget2DClass;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.CapsuleComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UCapsuleComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CapsuleComponent");

	return Clss;
}


// CapsuleComponent Engine.Default__CapsuleComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UCapsuleComponent* UCapsuleComponent::GetDefaultObj()
{
	static class UCapsuleComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UCapsuleComponent*>(UCapsuleComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CapsuleComponent.SetCapsuleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InRadius                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InHalfHeight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateOverlaps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "SetCapsuleSize");

	Params::UCapsuleComponent_SetCapsuleSize_Params Parms{};

	Parms.InRadius = InRadius;
	Parms.InHalfHeight = InHalfHeight;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CapsuleComponent.SetCapsuleRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateOverlaps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::SetCapsuleRadius(float Radius, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "SetCapsuleRadius");

	Params::UCapsuleComponent_SetCapsuleRadius_Params Parms{};

	Parms.Radius = Radius;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CapsuleComponent.SetCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateOverlaps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "SetCapsuleHalfHeight");

	Params::UCapsuleComponent_SetCapsuleHalfHeight_Params Parms{};

	Parms.HalfHeight = HalfHeight;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize_WithoutHemisphere
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              OutRadius                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutHalfHeightWithoutHemisphere                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::GetUnscaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetUnscaledCapsuleSize_WithoutHemisphere");

	Params::UCapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeightWithoutHemisphere != nullptr)
		*OutHalfHeightWithoutHemisphere = Parms.OutHalfHeightWithoutHemisphere;

}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              OutRadius                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutHalfHeight                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::GetUnscaledCapsuleSize(float* OutRadius, float* OutHalfHeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetUnscaledCapsuleSize");

	Params::UCapsuleComponent_GetUnscaledCapsuleSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeight != nullptr)
		*OutHalfHeight = Parms.OutHalfHeight;

}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetUnscaledCapsuleRadius()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetUnscaledCapsuleRadius");

	Params::UCapsuleComponent_GetUnscaledCapsuleRadius_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetUnscaledCapsuleHalfHeight_WithoutHemisphere()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetUnscaledCapsuleHalfHeight_WithoutHemisphere");

	Params::UCapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetUnscaledCapsuleHalfHeight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetUnscaledCapsuleHalfHeight");

	Params::UCapsuleComponent_GetUnscaledCapsuleHalfHeight_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CapsuleComponent.GetShapeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetShapeScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetShapeScale");

	Params::UCapsuleComponent_GetShapeScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CapsuleComponent.GetScaledCapsuleSize_WithoutHemisphere
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              OutRadius                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutHalfHeightWithoutHemisphere                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::GetScaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetScaledCapsuleSize_WithoutHemisphere");

	Params::UCapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeightWithoutHemisphere != nullptr)
		*OutHalfHeightWithoutHemisphere = Parms.OutHalfHeightWithoutHemisphere;

}


// Function Engine.CapsuleComponent.GetScaledCapsuleSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              OutRadius                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutHalfHeight                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::GetScaledCapsuleSize(float* OutRadius, float* OutHalfHeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetScaledCapsuleSize");

	Params::UCapsuleComponent_GetScaledCapsuleSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeight != nullptr)
		*OutHalfHeight = Parms.OutHalfHeight;

}


// Function Engine.CapsuleComponent.GetScaledCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetScaledCapsuleRadius()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetScaledCapsuleRadius");

	Params::UCapsuleComponent_GetScaledCapsuleRadius_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetScaledCapsuleHalfHeight_WithoutHemisphere()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetScaledCapsuleHalfHeight_WithoutHemisphere");

	Params::UCapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetScaledCapsuleHalfHeight()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CapsuleComponent", "GetScaledCapsuleHalfHeight");

	Params::UCapsuleComponent_GetScaledCapsuleHalfHeight_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.CheckBoxStyleAsset
// (None)

class UClass* UCheckBoxStyleAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CheckBoxStyleAsset");

	return Clss;
}


// CheckBoxStyleAsset Engine.Default__CheckBoxStyleAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UCheckBoxStyleAsset* UCheckBoxStyleAsset::GetDefaultObj()
{
	static class UCheckBoxStyleAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UCheckBoxStyleAsset*>(UCheckBoxStyleAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ChildConnection
// (None)

class UClass* UChildConnection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ChildConnection");

	return Clss;
}


// ChildConnection Engine.Default__ChildConnection
// (Public, ClassDefaultObject, ArchetypeObject)

class UChildConnection* UChildConnection::GetDefaultObj()
{
	static class UChildConnection* Default = nullptr;

	if (!Default)
		Default = static_cast<UChildConnection*>(UChildConnection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PlatformInterfaceBase
// (None)

class UClass* UPlatformInterfaceBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlatformInterfaceBase");

	return Clss;
}


// PlatformInterfaceBase Engine.Default__PlatformInterfaceBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlatformInterfaceBase* UPlatformInterfaceBase::GetDefaultObj()
{
	static class UPlatformInterfaceBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlatformInterfaceBase*>(UPlatformInterfaceBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CloudStorageBase
// (None)

class UClass* UCloudStorageBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CloudStorageBase");

	return Clss;
}


// CloudStorageBase Engine.Default__CloudStorageBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UCloudStorageBase* UCloudStorageBase::GetDefaultObj()
{
	static class UCloudStorageBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UCloudStorageBase*>(UCloudStorageBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CollisionProfile
// (None)

class UClass* UCollisionProfile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CollisionProfile");

	return Clss;
}


// CollisionProfile Engine.Default__CollisionProfile
// (Public, ClassDefaultObject, ArchetypeObject)

class UCollisionProfile* UCollisionProfile::GetDefaultObj()
{
	static class UCollisionProfile* Default = nullptr;

	if (!Default)
		Default = static_cast<UCollisionProfile*>(UCollisionProfile::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ComponentDelegateBinding
// (None)

class UClass* UComponentDelegateBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ComponentDelegateBinding");

	return Clss;
}


// ComponentDelegateBinding Engine.Default__ComponentDelegateBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UComponentDelegateBinding* UComponentDelegateBinding::GetDefaultObj()
{
	static class UComponentDelegateBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UComponentDelegateBinding*>(UComponentDelegateBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CurveTable
// (None)

class UClass* UCurveTable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CurveTable");

	return Clss;
}


// CurveTable Engine.Default__CurveTable
// (Public, ClassDefaultObject, ArchetypeObject)

class UCurveTable* UCurveTable::GetDefaultObj()
{
	static class UCurveTable* Default = nullptr;

	if (!Default)
		Default = static_cast<UCurveTable*>(UCurveTable::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CompositeCurveTable
// (None)

class UClass* UCompositeCurveTable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CompositeCurveTable");

	return Clss;
}


// CompositeCurveTable Engine.Default__CompositeCurveTable
// (Public, ClassDefaultObject, ArchetypeObject)

class UCompositeCurveTable* UCompositeCurveTable::GetDefaultObj()
{
	static class UCompositeCurveTable* Default = nullptr;

	if (!Default)
		Default = static_cast<UCompositeCurveTable*>(UCompositeCurveTable::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CompositeDataTable
// (None)

class UClass* UCompositeDataTable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CompositeDataTable");

	return Clss;
}


// CompositeDataTable Engine.Default__CompositeDataTable
// (Public, ClassDefaultObject, ArchetypeObject)

class UCompositeDataTable* UCompositeDataTable::GetDefaultObj()
{
	static class UCompositeDataTable* Default = nullptr;

	if (!Default)
		Default = static_cast<UCompositeDataTable*>(UCompositeDataTable::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ControlChannel
// (None)

class UClass* UControlChannel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ControlChannel");

	return Clss;
}


// ControlChannel Engine.Default__ControlChannel
// (Public, ClassDefaultObject, ArchetypeObject)

class UControlChannel* UControlChannel::GetDefaultObj()
{
	static class UControlChannel* Default = nullptr;

	if (!Default)
		Default = static_cast<UControlChannel*>(UControlChannel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ControlRigInterface
// (None)

class UClass* IControlRigInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ControlRigInterface");

	return Clss;
}


// ControlRigInterface Engine.Default__ControlRigInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IControlRigInterface* IControlRigInterface::GetDefaultObj()
{
	static class IControlRigInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IControlRigInterface*>(IControlRigInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.StreamingSettings
// (None)

class UClass* UStreamingSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StreamingSettings");

	return Clss;
}


// StreamingSettings Engine.Default__StreamingSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UStreamingSettings* UStreamingSettings::GetDefaultObj()
{
	static class UStreamingSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UStreamingSettings*>(UStreamingSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.GarbageCollectionSettings
// (None)

class UClass* UGarbageCollectionSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GarbageCollectionSettings");

	return Clss;
}


// GarbageCollectionSettings Engine.Default__GarbageCollectionSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UGarbageCollectionSettings* UGarbageCollectionSettings::GetDefaultObj()
{
	static class UGarbageCollectionSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UGarbageCollectionSettings*>(UGarbageCollectionSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CullDistanceVolume
// (Actor)

class UClass* ACullDistanceVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CullDistanceVolume");

	return Clss;
}


// CullDistanceVolume Engine.Default__CullDistanceVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ACullDistanceVolume* ACullDistanceVolume::GetDefaultObj()
{
	static class ACullDistanceVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ACullDistanceVolume*>(ACullDistanceVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CurveBase
// (None)

class UClass* UCurveBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CurveBase");

	return Clss;
}


// CurveBase Engine.Default__CurveBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UCurveBase* UCurveBase::GetDefaultObj()
{
	static class UCurveBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UCurveBase*>(UCurveBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CurveBase.GetValueRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              MinValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCurveBase::GetValueRange(float* MinValue, float* MaxValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveBase", "GetValueRange");

	Params::UCurveBase_GetValueRange_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (MinValue != nullptr)
		*MinValue = Parms.MinValue;

	if (MaxValue != nullptr)
		*MaxValue = Parms.MaxValue;

}


// Function Engine.CurveBase.GetTimeRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              MinTime                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxTime                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCurveBase::GetTimeRange(float* MinTime, float* MaxTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveBase", "GetTimeRange");

	Params::UCurveBase_GetTimeRange_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (MinTime != nullptr)
		*MinTime = Parms.MinTime;

	if (MaxTime != nullptr)
		*MaxTime = Parms.MaxTime;

}


// Class Engine.CurveEdPresetCurve
// (None)

class UClass* UCurveEdPresetCurve::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CurveEdPresetCurve");

	return Clss;
}


// CurveEdPresetCurve Engine.Default__CurveEdPresetCurve
// (Public, ClassDefaultObject, ArchetypeObject)

class UCurveEdPresetCurve* UCurveEdPresetCurve::GetDefaultObj()
{
	static class UCurveEdPresetCurve* Default = nullptr;

	if (!Default)
		Default = static_cast<UCurveEdPresetCurve*>(UCurveEdPresetCurve::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.CurveFloat
// (None)

class UClass* UCurveFloat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CurveFloat");

	return Clss;
}


// CurveFloat Engine.Default__CurveFloat
// (Public, ClassDefaultObject, ArchetypeObject)

class UCurveFloat* UCurveFloat::GetDefaultObj()
{
	static class UCurveFloat* Default = nullptr;

	if (!Default)
		Default = static_cast<UCurveFloat*>(UCurveFloat::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CurveFloat.GetFloatValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              InTime                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCurveFloat::GetFloatValue(float InTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveFloat", "GetFloatValue");

	Params::UCurveFloat_GetFloatValue_Params Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.CurveLinearColor
// (None)

class UClass* UCurveLinearColor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CurveLinearColor");

	return Clss;
}


// CurveLinearColor Engine.Default__CurveLinearColor
// (Public, ClassDefaultObject, ArchetypeObject)

class UCurveLinearColor* UCurveLinearColor::GetDefaultObj()
{
	static class UCurveLinearColor* Default = nullptr;

	if (!Default)
		Default = static_cast<UCurveLinearColor*>(UCurveLinearColor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CurveLinearColor.GetLinearColorValue
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              InTime                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UCurveLinearColor::GetLinearColorValue(float InTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveLinearColor", "GetLinearColorValue");

	Params::UCurveLinearColor_GetLinearColorValue_Params Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CurveLinearColor.GetClampedLinearColorValue
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              InTime                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UCurveLinearColor::GetClampedLinearColorValue(float InTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveLinearColor", "GetClampedLinearColorValue");

	Params::UCurveLinearColor_GetClampedLinearColorValue_Params Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.Texture2D
// (None)

class UClass* UTexture2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Texture2D");

	return Clss;
}


// Texture2D Engine.Default__Texture2D
// (Public, ClassDefaultObject, ArchetypeObject)

class UTexture2D* UTexture2D::GetDefaultObj()
{
	static class UTexture2D* Default = nullptr;

	if (!Default)
		Default = static_cast<UTexture2D*>(UTexture2D::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Texture2D.Blueprint_GetSizeY
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTexture2D::Blueprint_GetSizeY()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Texture2D", "Blueprint_GetSizeY");

	Params::UTexture2D_Blueprint_GetSizeY_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Texture2D.Blueprint_GetSizeX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTexture2D::Blueprint_GetSizeX()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Texture2D", "Blueprint_GetSizeX");

	Params::UTexture2D_Blueprint_GetSizeX_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.CurveLinearColorAtlas
// (None)

class UClass* UCurveLinearColorAtlas::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CurveLinearColorAtlas");

	return Clss;
}


// CurveLinearColorAtlas Engine.Default__CurveLinearColorAtlas
// (Public, ClassDefaultObject, ArchetypeObject)

class UCurveLinearColorAtlas* UCurveLinearColorAtlas::GetDefaultObj()
{
	static class UCurveLinearColorAtlas* Default = nullptr;

	if (!Default)
		Default = static_cast<UCurveLinearColorAtlas*>(UCurveLinearColorAtlas::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CurveLinearColorAtlas.GetCurvePosition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCurveLinearColor*           InCurve                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Position                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCurveLinearColorAtlas::GetCurvePosition(class UCurveLinearColor* InCurve, float* Position)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveLinearColorAtlas", "GetCurvePosition");

	Params::UCurveLinearColorAtlas_GetCurvePosition_Params Parms{};

	Parms.InCurve = InCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Position != nullptr)
		*Position = Parms.Position;

	return Parms.ReturnValue;

}


// Class Engine.CurveSourceInterface
// (None)

class UClass* ICurveSourceInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CurveSourceInterface");

	return Clss;
}


// CurveSourceInterface Engine.Default__CurveSourceInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class ICurveSourceInterface* ICurveSourceInterface::GetDefaultObj()
{
	static class ICurveSourceInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<ICurveSourceInterface*>(ICurveSourceInterface::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CurveSourceInterface.GetCurveValue
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FName                        CurveName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICurveSourceInterface::GetCurveValue(class FName CurveName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveSourceInterface", "GetCurveValue");

	Params::ICurveSourceInterface_GetCurveValue_Params Parms{};

	Parms.CurveName = CurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.CurveSourceInterface.GetCurves
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TArray<struct FNamedCurveValue>    OutValues                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ICurveSourceInterface::GetCurves(TArray<struct FNamedCurveValue>* OutValues)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveSourceInterface", "GetCurves");

	Params::ICurveSourceInterface_GetCurves_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutValues != nullptr)
		*OutValues = std::move(Parms.OutValues);

}


// Function Engine.CurveSourceInterface.GetBindingName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ICurveSourceInterface::GetBindingName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveSourceInterface", "GetBindingName");

	Params::ICurveSourceInterface_GetBindingName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.CurveVector
// (None)

class UClass* UCurveVector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("CurveVector");

	return Clss;
}


// CurveVector Engine.Default__CurveVector
// (Public, ClassDefaultObject, ArchetypeObject)

class UCurveVector* UCurveVector::GetDefaultObj()
{
	static class UCurveVector* Default = nullptr;

	if (!Default)
		Default = static_cast<UCurveVector*>(UCurveVector::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.CurveVector.GetVectorValue
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              InTime                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCurveVector::GetVectorValue(float InTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("CurveVector", "GetVectorValue");

	Params::UCurveVector_GetVectorValue_Params Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.DamageType
// (None)

class UClass* UDamageType::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DamageType");

	return Clss;
}


// DamageType Engine.Default__DamageType
// (Public, ClassDefaultObject, ArchetypeObject)

class UDamageType* UDamageType::GetDefaultObj()
{
	static class UDamageType* Default = nullptr;

	if (!Default)
		Default = static_cast<UDamageType*>(UDamageType::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DataTableFunctionLibrary
// (None)

class UClass* UDataTableFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DataTableFunctionLibrary");

	return Clss;
}


// DataTableFunctionLibrary Engine.Default__DataTableFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UDataTableFunctionLibrary* UDataTableFunctionLibrary::GetDefaultObj()
{
	static class UDataTableFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UDataTableFunctionLibrary*>(UDataTableFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.DataTableFunctionLibrary.GetDataTableRowNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                  Table                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                OutRowNames                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDataTableFunctionLibrary::GetDataTableRowNames(class UDataTable* Table, TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DataTableFunctionLibrary", "GetDataTableRowNames");

	Params::UDataTableFunctionLibrary_GetDataTableRowNames_Params Parms{};

	Parms.Table = Table;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);

}


// Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                  Table                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        RowName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTableRowBase               OutRow                                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableFunctionLibrary::GetDataTableRowFromName(class UDataTable* Table, class FName RowName, struct FTableRowBase* OutRow)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DataTableFunctionLibrary", "GetDataTableRowFromName");

	Params::UDataTableFunctionLibrary_GetDataTableRowFromName_Params Parms{};

	Parms.Table = Table;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRow != nullptr)
		*OutRow = std::move(Parms.OutRow);

	return Parms.ReturnValue;

}


// Function Engine.DataTableFunctionLibrary.GetDataTableColumnAsString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                  DataTable                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UDataTableFunctionLibrary::GetDataTableColumnAsString(class UDataTable* DataTable, class FName PropertyName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DataTableFunctionLibrary", "GetDataTableColumnAsString");

	Params::UDataTableFunctionLibrary_GetDataTableColumnAsString_Params Parms{};

	Parms.DataTable = DataTable;
	Parms.PropertyName = PropertyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCurveTable*                 CurveTable                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        RowName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InXY                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEvaluateCurveTableResultOutResult                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutXY                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ContextString                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataTableFunctionLibrary::EvaluateCurveTableRow(class UCurveTable* CurveTable, class FName RowName, float InXY, enum class EEvaluateCurveTableResult* OutResult, float* OutXY, const class FString& ContextString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DataTableFunctionLibrary", "EvaluateCurveTableRow");

	Params::UDataTableFunctionLibrary_EvaluateCurveTableRow_Params Parms{};

	Parms.CurveTable = CurveTable;
	Parms.RowName = RowName;
	Parms.InXY = InXY;
	Parms.ContextString = ContextString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	if (OutXY != nullptr)
		*OutXY = Parms.OutXY;

}


// Function Engine.DataTableFunctionLibrary.DoesDataTableRowExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                  Table                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        RowName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableFunctionLibrary::DoesDataTableRowExist(class UDataTable* Table, class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DataTableFunctionLibrary", "DoesDataTableRowExist");

	Params::UDataTableFunctionLibrary_DoesDataTableRowExist_Params Parms{};

	Parms.Table = Table;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.DebugCameraController
// (Actor, PlayerController)

class UClass* ADebugCameraController::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DebugCameraController");

	return Clss;
}


// DebugCameraController Engine.Default__DebugCameraController
// (Public, ClassDefaultObject, ArchetypeObject)

class ADebugCameraController* ADebugCameraController::GetDefaultObj()
{
	static class ADebugCameraController* Default = nullptr;

	if (!Default)
		Default = static_cast<ADebugCameraController*>(ADebugCameraController::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.DebugCameraController.ToggleDisplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ADebugCameraController::ToggleDisplay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DebugCameraController", "ToggleDisplay");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DebugCameraController.ShowDebugSelectedInfo
// (Exec, Native, Public)
// Parameters:

void ADebugCameraController::ShowDebugSelectedInfo()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DebugCameraController", "ShowDebugSelectedInfo");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DebugCameraController.SetPawnMovementSpeedScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewSpeedScale                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugCameraController::SetPawnMovementSpeedScale(float NewSpeedScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DebugCameraController", "SetPawnMovementSpeedScale");

	Params::ADebugCameraController_SetPawnMovementSpeedScale_Params Parms{};

	Parms.NewSpeedScale = NewSpeedScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DebugCameraController.ReceiveOnDeactivate
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*           RestoredPC                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugCameraController::ReceiveOnDeactivate(class APlayerController* RestoredPC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DebugCameraController", "ReceiveOnDeactivate");

	Params::ADebugCameraController_ReceiveOnDeactivate_Params Parms{};

	Parms.RestoredPC = RestoredPC;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.DebugCameraController.ReceiveOnActorSelected
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                      NewSelectedActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SelectHitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SelectHitNormal                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADebugCameraController::ReceiveOnActorSelected(class AActor* NewSelectedActor, struct FVector& SelectHitLocation, struct FVector& SelectHitNormal, struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DebugCameraController", "ReceiveOnActorSelected");

	Params::ADebugCameraController_ReceiveOnActorSelected_Params Parms{};

	Parms.NewSelectedActor = NewSelectedActor;
	Parms.SelectHitLocation = SelectHitLocation;
	Parms.SelectHitNormal = SelectHitNormal;
	Parms.Hit = Hit;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.DebugCameraController.ReceiveOnActivate
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*           OriginalPC                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugCameraController::ReceiveOnActivate(class APlayerController* OriginalPC)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DebugCameraController", "ReceiveOnActivate");

	Params::ADebugCameraController_ReceiveOnActivate_Params Parms{};

	Parms.OriginalPC = OriginalPC;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.DebugCameraController.GetSelectedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ADebugCameraController::GetSelectedActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DebugCameraController", "GetSelectedActor");

	Params::ADebugCameraController_GetSelectedActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.DebugCameraControllerSettings
// (None)

class UClass* UDebugCameraControllerSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DebugCameraControllerSettings");

	return Clss;
}


// DebugCameraControllerSettings Engine.Default__DebugCameraControllerSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UDebugCameraControllerSettings* UDebugCameraControllerSettings::GetDefaultObj()
{
	static class UDebugCameraControllerSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UDebugCameraControllerSettings*>(UDebugCameraControllerSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DebugCameraHUD
// (Actor)

class UClass* ADebugCameraHUD::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DebugCameraHUD");

	return Clss;
}


// DebugCameraHUD Engine.Default__DebugCameraHUD
// (Public, ClassDefaultObject, ArchetypeObject)

class ADebugCameraHUD* ADebugCameraHUD::GetDefaultObj()
{
	static class ADebugCameraHUD* Default = nullptr;

	if (!Default)
		Default = static_cast<ADebugCameraHUD*>(ADebugCameraHUD::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DebugDrawService
// (None)

class UClass* UDebugDrawService::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DebugDrawService");

	return Clss;
}


// DebugDrawService Engine.Default__DebugDrawService
// (Public, ClassDefaultObject, ArchetypeObject)

class UDebugDrawService* UDebugDrawService::GetDefaultObj()
{
	static class UDebugDrawService* Default = nullptr;

	if (!Default)
		Default = static_cast<UDebugDrawService*>(UDebugDrawService::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DecalActor
// (Actor)

class UClass* ADecalActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DecalActor");

	return Clss;
}


// DecalActor Engine.Default__DecalActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ADecalActor* ADecalActor::GetDefaultObj()
{
	static class ADecalActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ADecalActor*>(ADecalActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.DecalActor.SetDecalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          NewDecalMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADecalActor::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalActor", "SetDecalMaterial");

	Params::ADecalActor_SetDecalMaterial_Params Parms{};

	Parms.NewDecalMaterial = NewDecalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DecalActor.GetDecalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* ADecalActor::GetDecalMaterial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalActor", "GetDecalMaterial");

	Params::ADecalActor_GetDecalMaterial_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.DecalActor.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* ADecalActor::CreateDynamicMaterialInstance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalActor", "CreateDynamicMaterialInstance");

	Params::ADecalActor_CreateDynamicMaterialInstance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.DecalComponent
// (SceneComponent)

class UClass* UDecalComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DecalComponent");

	return Clss;
}


// DecalComponent Engine.Default__DecalComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UDecalComponent* UDecalComponent::GetDefaultObj()
{
	static class UDecalComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UDecalComponent*>(UDecalComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.DecalComponent.SetSortOrder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetSortOrder(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "SetSortOrder");

	Params::UDecalComponent_SetSortOrder_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DecalComponent.SetFadeScreenSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewFadeScreenSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetFadeScreenSize(float NewFadeScreenSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "SetFadeScreenSize");

	Params::UDecalComponent_SetFadeScreenSize_Params Parms{};

	Parms.NewFadeScreenSize = NewFadeScreenSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DecalComponent.SetFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              StartDelay                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               DestroyOwnerAfterFade                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "SetFadeOut");

	Params::UDecalComponent_SetFadeOut_Params Parms{};

	Parms.StartDelay = StartDelay;
	Parms.Duration = Duration;
	Parms.DestroyOwnerAfterFade = DestroyOwnerAfterFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DecalComponent.SetFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              StartDelay                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duaration                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetFadeIn(float StartDelay, float Duaration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "SetFadeIn");

	Params::UDecalComponent_SetFadeIn_Params Parms{};

	Parms.StartDelay = StartDelay;
	Parms.Duaration = Duaration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DecalComponent.SetDecalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          NewDecalMaterial                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "SetDecalMaterial");

	Params::UDecalComponent_SetDecalMaterial_Params Parms{};

	Parms.NewDecalMaterial = NewDecalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DecalComponent.GetFadeStartDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDecalComponent::GetFadeStartDelay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "GetFadeStartDelay");

	Params::UDecalComponent_GetFadeStartDelay_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.DecalComponent.GetFadeInStartDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDecalComponent::GetFadeInStartDelay()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "GetFadeInStartDelay");

	Params::UDecalComponent_GetFadeInStartDelay_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.DecalComponent.GetFadeInDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDecalComponent::GetFadeInDuration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "GetFadeInDuration");

	Params::UDecalComponent_GetFadeInDuration_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.DecalComponent.GetFadeDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDecalComponent::GetFadeDuration()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "GetFadeDuration");

	Params::UDecalComponent_GetFadeDuration_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.DecalComponent.GetDecalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UDecalComponent::GetDecalMaterial()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "GetDecalMaterial");

	Params::UDecalComponent_GetDecalMaterial_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.DecalComponent.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UDecalComponent::CreateDynamicMaterialInstance()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DecalComponent", "CreateDynamicMaterialInstance");

	Params::UDecalComponent_CreateDynamicMaterialInstance_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.DefaultPhysicsVolume
// (Actor)

class UClass* ADefaultPhysicsVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DefaultPhysicsVolume");

	return Clss;
}


// DefaultPhysicsVolume Engine.Default__DefaultPhysicsVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ADefaultPhysicsVolume* ADefaultPhysicsVolume::GetDefaultObj()
{
	static class ADefaultPhysicsVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ADefaultPhysicsVolume*>(ADefaultPhysicsVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DemoNetConnection
// (None)

class UClass* UDemoNetConnection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DemoNetConnection");

	return Clss;
}


// DemoNetConnection Engine.Default__DemoNetConnection
// (Public, ClassDefaultObject, ArchetypeObject)

class UDemoNetConnection* UDemoNetConnection::GetDefaultObj()
{
	static class UDemoNetConnection* Default = nullptr;

	if (!Default)
		Default = static_cast<UDemoNetConnection*>(UDemoNetConnection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DemoNetDriver
// (None)

class UClass* UDemoNetDriver::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DemoNetDriver");

	return Clss;
}


// DemoNetDriver Engine.Default__DemoNetDriver
// (Public, ClassDefaultObject, ArchetypeObject)

class UDemoNetDriver* UDemoNetDriver::GetDefaultObj()
{
	static class UDemoNetDriver* Default = nullptr;

	if (!Default)
		Default = static_cast<UDemoNetDriver*>(UDemoNetDriver::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PendingNetGame
// (None)

class UClass* UPendingNetGame::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PendingNetGame");

	return Clss;
}


// PendingNetGame Engine.Default__PendingNetGame
// (Public, ClassDefaultObject, ArchetypeObject)

class UPendingNetGame* UPendingNetGame::GetDefaultObj()
{
	static class UPendingNetGame* Default = nullptr;

	if (!Default)
		Default = static_cast<UPendingNetGame*>(UPendingNetGame::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DemoPendingNetGame
// (None)

class UClass* UDemoPendingNetGame::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DemoPendingNetGame");

	return Clss;
}


// DemoPendingNetGame Engine.Default__DemoPendingNetGame
// (Public, ClassDefaultObject, ArchetypeObject)

class UDemoPendingNetGame* UDemoPendingNetGame::GetDefaultObj()
{
	static class UDemoPendingNetGame* Default = nullptr;

	if (!Default)
		Default = static_cast<UDemoPendingNetGame*>(UDemoPendingNetGame::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DestructibleInterface
// (None)

class UClass* IDestructibleInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DestructibleInterface");

	return Clss;
}


// DestructibleInterface Engine.Default__DestructibleInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IDestructibleInterface* IDestructibleInterface::GetDefaultObj()
{
	static class IDestructibleInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IDestructibleInterface*>(IDestructibleInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TextureLODSettings
// (None)

class UClass* UTextureLODSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextureLODSettings");

	return Clss;
}


// TextureLODSettings Engine.Default__TextureLODSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextureLODSettings* UTextureLODSettings::GetDefaultObj()
{
	static class UTextureLODSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextureLODSettings*>(UTextureLODSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DeviceProfile
// (None)

class UClass* UDeviceProfile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DeviceProfile");

	return Clss;
}


// DeviceProfile Engine.Default__DeviceProfile
// (Public, ClassDefaultObject, ArchetypeObject)

class UDeviceProfile* UDeviceProfile::GetDefaultObj()
{
	static class UDeviceProfile* Default = nullptr;

	if (!Default)
		Default = static_cast<UDeviceProfile*>(UDeviceProfile::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DeviceProfileManager
// (None)

class UClass* UDeviceProfileManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DeviceProfileManager");

	return Clss;
}


// DeviceProfileManager Engine.Default__DeviceProfileManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UDeviceProfileManager* UDeviceProfileManager::GetDefaultObj()
{
	static class UDeviceProfileManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UDeviceProfileManager*>(UDeviceProfileManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DialogueSoundWaveProxy
// (None)

class UClass* UDialogueSoundWaveProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueSoundWaveProxy");

	return Clss;
}


// DialogueSoundWaveProxy Engine.Default__DialogueSoundWaveProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueSoundWaveProxy* UDialogueSoundWaveProxy::GetDefaultObj()
{
	static class UDialogueSoundWaveProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueSoundWaveProxy*>(UDialogueSoundWaveProxy::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DialogueVoice
// (None)

class UClass* UDialogueVoice::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueVoice");

	return Clss;
}


// DialogueVoice Engine.Default__DialogueVoice
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueVoice* UDialogueVoice::GetDefaultObj()
{
	static class UDialogueVoice* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueVoice*>(UDialogueVoice::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DialogueWave
// (None)

class UClass* UDialogueWave::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DialogueWave");

	return Clss;
}


// DialogueWave Engine.Default__DialogueWave
// (Public, ClassDefaultObject, ArchetypeObject)

class UDialogueWave* UDialogueWave::GetDefaultObj()
{
	static class UDialogueWave* Default = nullptr;

	if (!Default)
		Default = static_cast<UDialogueWave*>(UDialogueWave::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Light
// (Actor)

class UClass* ALight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Light");

	return Clss;
}


// Light Engine.Default__Light
// (Public, ClassDefaultObject, ArchetypeObject)

class ALight* ALight::GetDefaultObj()
{
	static class ALight* Default = nullptr;

	if (!Default)
		Default = static_cast<ALight*>(ALight::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Light.ToggleEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void ALight::ToggleEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "ToggleEnabled");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.SetLightFunctionScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLightFunctionScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "SetLightFunctionScale");

	Params::ALight_SetLightFunctionScale_Params Parms{};

	Parms.NewLightFunctionScale = NewLightFunctionScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.SetLightFunctionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          NewLightFunctionMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "SetLightFunctionMaterial");

	Params::ALight_SetLightFunctionMaterial_Params Parms{};

	Parms.NewLightFunctionMaterial = NewLightFunctionMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.SetLightFunctionFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewLightFunctionFadeDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "SetLightFunctionFadeDistance");

	Params::ALight_SetLightFunctionFadeDistance_Params Parms{};

	Parms.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                NewLightColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetLightColor(const struct FLinearColor& NewLightColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "SetLightColor");

	Params::ALight_SetLightColor_Params Parms{};

	Parms.NewLightColor = NewLightColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bSetEnabled                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetEnabled(bool bSetEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "SetEnabled");

	Params::ALight_SetEnabled_Params Parms{};

	Parms.bSetEnabled = bSetEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.SetCastShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetCastShadows(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "SetCastShadows");

	Params::ALight_SetCastShadows_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewBrightness                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetBrightness(float NewBrightness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "SetBrightness");

	Params::ALight_SetBrightness_Params Parms{};

	Parms.NewBrightness = NewBrightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.SetAffectTranslucentLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetAffectTranslucentLighting(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "SetAffectTranslucentLighting");

	Params::ALight_SetAffectTranslucentLighting_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.OnRep_bEnabled
// (Native, Public)
// Parameters:

void ALight::OnRep_bEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "OnRep_bEnabled");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.Light.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALight::IsEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "IsEnabled");

	Params::ALight_IsEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Light.GetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ALight::GetLightColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "GetLightColor");

	Params::ALight_GetLightColor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Light.GetBrightness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALight::GetBrightness()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Light", "GetBrightness");

	Params::ALight_GetBrightness_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.DirectionalLight
// (Actor)

class UClass* ADirectionalLight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DirectionalLight");

	return Clss;
}


// DirectionalLight Engine.Default__DirectionalLight
// (Public, ClassDefaultObject, ArchetypeObject)

class ADirectionalLight* ADirectionalLight::GetDefaultObj()
{
	static class ADirectionalLight* Default = nullptr;

	if (!Default)
		Default = static_cast<ADirectionalLight*>(ADirectionalLight::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightComponentBase
// (SceneComponent)

class UClass* ULightComponentBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightComponentBase");

	return Clss;
}


// LightComponentBase Engine.Default__LightComponentBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightComponentBase* ULightComponentBase::GetDefaultObj()
{
	static class ULightComponentBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightComponentBase*>(ULightComponentBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.LightComponentBase.SetSamplesPerPixel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetSamplesPerPixel(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponentBase", "SetSamplesPerPixel");

	Params::ULightComponentBase_SetSamplesPerPixel_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponentBase.SetCastVolumetricShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetCastVolumetricShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponentBase", "SetCastVolumetricShadow");

	Params::ULightComponentBase_SetCastVolumetricShadow_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponentBase.SetCastShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetCastShadows(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponentBase", "SetCastShadows");

	Params::ULightComponentBase_SetCastShadows_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponentBase.SetCastRaytracedShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetCastRaytracedShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponentBase", "SetCastRaytracedShadow");

	Params::ULightComponentBase_SetCastRaytracedShadow_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponentBase.SetAffectReflection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetAffectReflection(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponentBase", "SetAffectReflection");

	Params::ULightComponentBase_SetAffectReflection_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponentBase.GetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ULightComponentBase::GetLightColor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponentBase", "GetLightColor");

	Params::ULightComponentBase_GetLightColor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.LightComponent
// (SceneComponent)

class UClass* ULightComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightComponent");

	return Clss;
}


// LightComponent Engine.Default__LightComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightComponent* ULightComponent::GetDefaultObj()
{
	static class ULightComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightComponent*>(ULightComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.LightComponent.SetVolumetricScatteringIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewIntensity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetVolumetricScatteringIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetVolumetricScatteringIntensity");

	Params::ULightComponent_SetVolumetricScatteringIntensity_Params Parms{};

	Parms.NewIntensity = NewIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetUseIESBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetUseIESBrightness(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetUseIESBrightness");

	Params::ULightComponent_SetUseIESBrightness_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetTransmission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetTransmission(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetTransmission");

	Params::ULightComponent_SetTransmission_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetTemperature
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewTemperature                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetTemperature(float NewTemperature)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetTemperature");

	Params::ULightComponent_SetTemperature_Params Parms{};

	Parms.NewTemperature = NewTemperature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetSpecularScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetSpecularScale(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetSpecularScale");

	Params::ULightComponent_SetSpecularScale_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetShadowBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetShadowBias(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetShadowBias");

	Params::ULightComponent_SetShadowBias_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetLightFunctionScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLightFunctionScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetLightFunctionScale");

	Params::ULightComponent_SetLightFunctionScale_Params Parms{};

	Parms.NewLightFunctionScale = NewLightFunctionScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetLightFunctionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          NewLightFunctionMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetLightFunctionMaterial");

	Params::ULightComponent_SetLightFunctionMaterial_Params Parms{};

	Parms.NewLightFunctionMaterial = NewLightFunctionMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetLightFunctionFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewLightFunctionFadeDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetLightFunctionFadeDistance");

	Params::ULightComponent_SetLightFunctionFadeDistance_Params Parms{};

	Parms.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetLightFunctionDisabledBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightFunctionDisabledBrightness(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetLightFunctionDisabledBrightness");

	Params::ULightComponent_SetLightFunctionDisabledBrightness_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                NewLightColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSRGB                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightColor(const struct FLinearColor& NewLightColor, bool bSRGB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetLightColor");

	Params::ULightComponent_SetLightColor_Params Parms{};

	Parms.NewLightColor = NewLightColor;
	Parms.bSRGB = bSRGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewIntensity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetIntensity");

	Params::ULightComponent_SetIntensity_Params Parms{};

	Parms.NewIntensity = NewIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetIndirectLightingIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewIntensity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetIndirectLightingIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetIndirectLightingIntensity");

	Params::ULightComponent_SetIndirectLightingIntensity_Params Parms{};

	Parms.NewIntensity = NewIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetIESTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureLightProfile*        NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetIESTexture(class UTextureLightProfile* NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetIESTexture");

	Params::ULightComponent_SetIESTexture_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetIESBrightnessScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetIESBrightnessScale(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetIESBrightnessScale");

	Params::ULightComponent_SetIESBrightnessScale_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetForceCachedShadowsForMovablePrimitives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetForceCachedShadowsForMovablePrimitives(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetForceCachedShadowsForMovablePrimitives");

	Params::ULightComponent_SetForceCachedShadowsForMovablePrimitives_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetEnableLightShaftBloom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetEnableLightShaftBloom(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetEnableLightShaftBloom");

	Params::ULightComponent_SetEnableLightShaftBloom_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetBloomTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                      NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetBloomTint(const struct FColor& NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetBloomTint");

	Params::ULightComponent_SetBloomTint_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetBloomThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetBloomThreshold(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetBloomThreshold");

	Params::ULightComponent_SetBloomThreshold_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetBloomScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetBloomScale(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetBloomScale");

	Params::ULightComponent_SetBloomScale_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetAffectTranslucentLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetAffectTranslucentLighting(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetAffectTranslucentLighting");

	Params::ULightComponent_SetAffectTranslucentLighting_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LightComponent.SetAffectDynamicIndirectLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetAffectDynamicIndirectLighting(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LightComponent", "SetAffectDynamicIndirectLighting");

	Params::ULightComponent_SetAffectDynamicIndirectLighting_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.DirectionalLightComponent
// (SceneComponent)

class UClass* UDirectionalLightComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DirectionalLightComponent");

	return Clss;
}


// DirectionalLightComponent Engine.Default__DirectionalLightComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UDirectionalLightComponent* UDirectionalLightComponent::GetDefaultObj()
{
	static class UDirectionalLightComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UDirectionalLightComponent*>(UDirectionalLightComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetShadowDistanceFadeoutFraction(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetShadowDistanceFadeoutFraction");

	Params::UDirectionalLightComponent_SetShadowDistanceFadeoutFraction_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetOcclusionMaskDarkness(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetOcclusionMaskDarkness");

	Params::UDirectionalLightComponent_SetOcclusionMaskDarkness_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetLightShaftOverrideDirection(const struct FVector& NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetLightShaftOverrideDirection");

	Params::UDirectionalLightComponent_SetLightShaftOverrideDirection_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetEnableLightShaftOcclusion(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetEnableLightShaftOcclusion");

	Params::UDirectionalLightComponent_SetEnableLightShaftOcclusion_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetDynamicShadowDistanceStationaryLight(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetDynamicShadowDistanceStationaryLight");

	Params::UDirectionalLightComponent_SetDynamicShadowDistanceStationaryLight_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetDynamicShadowDistanceMovableLight(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetDynamicShadowDistanceMovableLight");

	Params::UDirectionalLightComponent_SetDynamicShadowDistanceMovableLight_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DirectionalLightComponent.SetDynamicShadowCascades
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetDynamicShadowCascades(int32 NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetDynamicShadowCascades");

	Params::UDirectionalLightComponent_SetDynamicShadowCascades_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetCascadeTransitionFraction(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetCascadeTransitionFraction");

	Params::UDirectionalLightComponent_SetCascadeTransitionFraction_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetCascadeDistributionExponent(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("DirectionalLightComponent", "SetCascadeDistributionExponent");

	Params::UDirectionalLightComponent_SetCascadeDistributionExponent_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.Distribution
// (None)

class UClass* UDistribution::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Distribution");

	return Clss;
}


// Distribution Engine.Default__Distribution
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistribution* UDistribution::GetDefaultObj()
{
	static class UDistribution* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistribution*>(UDistribution::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionFloat
// (None)

class UClass* UDistributionFloat::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionFloat");

	return Clss;
}


// DistributionFloat Engine.Default__DistributionFloat
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionFloat* UDistributionFloat::GetDefaultObj()
{
	static class UDistributionFloat* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionFloat*>(UDistributionFloat::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionFloatConstant
// (None)

class UClass* UDistributionFloatConstant::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionFloatConstant");

	return Clss;
}


// DistributionFloatConstant Engine.Default__DistributionFloatConstant
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionFloatConstant* UDistributionFloatConstant::GetDefaultObj()
{
	static class UDistributionFloatConstant* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionFloatConstant*>(UDistributionFloatConstant::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionFloatConstantCurve
// (None)

class UClass* UDistributionFloatConstantCurve::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionFloatConstantCurve");

	return Clss;
}


// DistributionFloatConstantCurve Engine.Default__DistributionFloatConstantCurve
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionFloatConstantCurve* UDistributionFloatConstantCurve::GetDefaultObj()
{
	static class UDistributionFloatConstantCurve* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionFloatConstantCurve*>(UDistributionFloatConstantCurve::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionFloatParameterBase
// (None)

class UClass* UDistributionFloatParameterBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionFloatParameterBase");

	return Clss;
}


// DistributionFloatParameterBase Engine.Default__DistributionFloatParameterBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionFloatParameterBase* UDistributionFloatParameterBase::GetDefaultObj()
{
	static class UDistributionFloatParameterBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionFloatParameterBase*>(UDistributionFloatParameterBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionFloatParticleParameter
// (None)

class UClass* UDistributionFloatParticleParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionFloatParticleParameter");

	return Clss;
}


// DistributionFloatParticleParameter Engine.Default__DistributionFloatParticleParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionFloatParticleParameter* UDistributionFloatParticleParameter::GetDefaultObj()
{
	static class UDistributionFloatParticleParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionFloatParticleParameter*>(UDistributionFloatParticleParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionFloatUniform
// (None)

class UClass* UDistributionFloatUniform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionFloatUniform");

	return Clss;
}


// DistributionFloatUniform Engine.Default__DistributionFloatUniform
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionFloatUniform* UDistributionFloatUniform::GetDefaultObj()
{
	static class UDistributionFloatUniform* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionFloatUniform*>(UDistributionFloatUniform::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionFloatUniformCurve
// (None)

class UClass* UDistributionFloatUniformCurve::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionFloatUniformCurve");

	return Clss;
}


// DistributionFloatUniformCurve Engine.Default__DistributionFloatUniformCurve
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionFloatUniformCurve* UDistributionFloatUniformCurve::GetDefaultObj()
{
	static class UDistributionFloatUniformCurve* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionFloatUniformCurve*>(UDistributionFloatUniformCurve::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionVector
// (None)

class UClass* UDistributionVector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionVector");

	return Clss;
}


// DistributionVector Engine.Default__DistributionVector
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionVector* UDistributionVector::GetDefaultObj()
{
	static class UDistributionVector* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionVector*>(UDistributionVector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionVectorConstant
// (None)

class UClass* UDistributionVectorConstant::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionVectorConstant");

	return Clss;
}


// DistributionVectorConstant Engine.Default__DistributionVectorConstant
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionVectorConstant* UDistributionVectorConstant::GetDefaultObj()
{
	static class UDistributionVectorConstant* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionVectorConstant*>(UDistributionVectorConstant::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionVectorConstantCurve
// (None)

class UClass* UDistributionVectorConstantCurve::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionVectorConstantCurve");

	return Clss;
}


// DistributionVectorConstantCurve Engine.Default__DistributionVectorConstantCurve
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionVectorConstantCurve* UDistributionVectorConstantCurve::GetDefaultObj()
{
	static class UDistributionVectorConstantCurve* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionVectorConstantCurve*>(UDistributionVectorConstantCurve::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionVectorParameterBase
// (None)

class UClass* UDistributionVectorParameterBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionVectorParameterBase");

	return Clss;
}


// DistributionVectorParameterBase Engine.Default__DistributionVectorParameterBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionVectorParameterBase* UDistributionVectorParameterBase::GetDefaultObj()
{
	static class UDistributionVectorParameterBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionVectorParameterBase*>(UDistributionVectorParameterBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionVectorParticleParameter
// (None)

class UClass* UDistributionVectorParticleParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionVectorParticleParameter");

	return Clss;
}


// DistributionVectorParticleParameter Engine.Default__DistributionVectorParticleParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionVectorParticleParameter* UDistributionVectorParticleParameter::GetDefaultObj()
{
	static class UDistributionVectorParticleParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionVectorParticleParameter*>(UDistributionVectorParticleParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionVectorUniform
// (None)

class UClass* UDistributionVectorUniform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionVectorUniform");

	return Clss;
}


// DistributionVectorUniform Engine.Default__DistributionVectorUniform
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionVectorUniform* UDistributionVectorUniform::GetDefaultObj()
{
	static class UDistributionVectorUniform* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionVectorUniform*>(UDistributionVectorUniform::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DistributionVectorUniformCurve
// (None)

class UClass* UDistributionVectorUniformCurve::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DistributionVectorUniformCurve");

	return Clss;
}


// DistributionVectorUniformCurve Engine.Default__DistributionVectorUniformCurve
// (Public, ClassDefaultObject, ArchetypeObject)

class UDistributionVectorUniformCurve* UDistributionVectorUniformCurve::GetDefaultObj()
{
	static class UDistributionVectorUniformCurve* Default = nullptr;

	if (!Default)
		Default = static_cast<UDistributionVectorUniformCurve*>(UDistributionVectorUniformCurve::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DocumentationActor
// (Actor)

class UClass* ADocumentationActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DocumentationActor");

	return Clss;
}


// DocumentationActor Engine.Default__DocumentationActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ADocumentationActor* ADocumentationActor::GetDefaultObj()
{
	static class ADocumentationActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ADocumentationActor*>(ADocumentationActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DPICustomScalingRule
// (None)

class UClass* UDPICustomScalingRule::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DPICustomScalingRule");

	return Clss;
}


// DPICustomScalingRule Engine.Default__DPICustomScalingRule
// (Public, ClassDefaultObject, ArchetypeObject)

class UDPICustomScalingRule* UDPICustomScalingRule::GetDefaultObj()
{
	static class UDPICustomScalingRule* Default = nullptr;

	if (!Default)
		Default = static_cast<UDPICustomScalingRule*>(UDPICustomScalingRule::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DrawFrustumComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UDrawFrustumComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DrawFrustumComponent");

	return Clss;
}


// DrawFrustumComponent Engine.Default__DrawFrustumComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UDrawFrustumComponent* UDrawFrustumComponent::GetDefaultObj()
{
	static class UDrawFrustumComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UDrawFrustumComponent*>(UDrawFrustumComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SphereComponent
// (SceneComponent, PrimitiveComponent)

class UClass* USphereComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SphereComponent");

	return Clss;
}


// SphereComponent Engine.Default__SphereComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USphereComponent* USphereComponent::GetDefaultObj()
{
	static class USphereComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USphereComponent*>(USphereComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SphereComponent.SetSphereRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InSphereRadius                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateOverlaps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USphereComponent::SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SphereComponent", "SetSphereRadius");

	Params::USphereComponent_SetSphereRadius_Params Parms{};

	Parms.InSphereRadius = InSphereRadius;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SphereComponent.GetUnscaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USphereComponent::GetUnscaledSphereRadius()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SphereComponent", "GetUnscaledSphereRadius");

	Params::USphereComponent_GetUnscaledSphereRadius_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SphereComponent.GetShapeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USphereComponent::GetShapeScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SphereComponent", "GetShapeScale");

	Params::USphereComponent_GetShapeScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SphereComponent.GetScaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USphereComponent::GetScaledSphereRadius()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SphereComponent", "GetScaledSphereRadius");

	Params::USphereComponent_GetScaledSphereRadius_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.DrawSphereComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UDrawSphereComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DrawSphereComponent");

	return Clss;
}


// DrawSphereComponent Engine.Default__DrawSphereComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UDrawSphereComponent* UDrawSphereComponent::GetDefaultObj()
{
	static class UDrawSphereComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UDrawSphereComponent*>(UDrawSphereComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EdGraph
// (None)

class UClass* UEdGraph::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EdGraph");

	return Clss;
}


// EdGraph Engine.Default__EdGraph
// (Public, ClassDefaultObject, ArchetypeObject)

class UEdGraph* UEdGraph::GetDefaultObj()
{
	static class UEdGraph* Default = nullptr;

	if (!Default)
		Default = static_cast<UEdGraph*>(UEdGraph::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EdGraphNode
// (None)

class UClass* UEdGraphNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EdGraphNode");

	return Clss;
}


// EdGraphNode Engine.Default__EdGraphNode
// (Public, ClassDefaultObject, ArchetypeObject)

class UEdGraphNode* UEdGraphNode::GetDefaultObj()
{
	static class UEdGraphNode* Default = nullptr;

	if (!Default)
		Default = static_cast<UEdGraphNode*>(UEdGraphNode::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EdGraphNode_Documentation
// (None)

class UClass* UEdGraphNode_Documentation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EdGraphNode_Documentation");

	return Clss;
}


// EdGraphNode_Documentation Engine.Default__EdGraphNode_Documentation
// (Public, ClassDefaultObject, ArchetypeObject)

class UEdGraphNode_Documentation* UEdGraphNode_Documentation::GetDefaultObj()
{
	static class UEdGraphNode_Documentation* Default = nullptr;

	if (!Default)
		Default = static_cast<UEdGraphNode_Documentation*>(UEdGraphNode_Documentation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EdGraphPin_Deprecated
// (None)

class UClass* UEdGraphPin_Deprecated::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EdGraphPin_Deprecated");

	return Clss;
}


// EdGraphPin_Deprecated Engine.Default__EdGraphPin_Deprecated
// (Public, ClassDefaultObject, ArchetypeObject)

class UEdGraphPin_Deprecated* UEdGraphPin_Deprecated::GetDefaultObj()
{
	static class UEdGraphPin_Deprecated* Default = nullptr;

	if (!Default)
		Default = static_cast<UEdGraphPin_Deprecated*>(UEdGraphPin_Deprecated::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EdGraphSchema
// (None)

class UClass* UEdGraphSchema::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EdGraphSchema");

	return Clss;
}


// EdGraphSchema Engine.Default__EdGraphSchema
// (Public, ClassDefaultObject, ArchetypeObject)

class UEdGraphSchema* UEdGraphSchema::GetDefaultObj()
{
	static class UEdGraphSchema* Default = nullptr;

	if (!Default)
		Default = static_cast<UEdGraphSchema*>(UEdGraphSchema::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EngineBaseTypes
// (None)

class UClass* UEngineBaseTypes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EngineBaseTypes");

	return Clss;
}


// EngineBaseTypes Engine.Default__EngineBaseTypes
// (Public, ClassDefaultObject, ArchetypeObject)

class UEngineBaseTypes* UEngineBaseTypes::GetDefaultObj()
{
	static class UEngineBaseTypes* Default = nullptr;

	if (!Default)
		Default = static_cast<UEngineBaseTypes*>(UEngineBaseTypes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EngineHandlerComponentFactory
// (None)

class UClass* UEngineHandlerComponentFactory::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EngineHandlerComponentFactory");

	return Clss;
}


// EngineHandlerComponentFactory Engine.Default__EngineHandlerComponentFactory
// (Public, ClassDefaultObject, ArchetypeObject)

class UEngineHandlerComponentFactory* UEngineHandlerComponentFactory::GetDefaultObj()
{
	static class UEngineHandlerComponentFactory* Default = nullptr;

	if (!Default)
		Default = static_cast<UEngineHandlerComponentFactory*>(UEngineHandlerComponentFactory::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EngineMessage
// (None)

class UClass* UEngineMessage::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EngineMessage");

	return Clss;
}


// EngineMessage Engine.Default__EngineMessage
// (Public, ClassDefaultObject, ArchetypeObject)

class UEngineMessage* UEngineMessage::GetDefaultObj()
{
	static class UEngineMessage* Default = nullptr;

	if (!Default)
		Default = static_cast<UEngineMessage*>(UEngineMessage::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.DynamicSubsystem
// (None)

class UClass* UDynamicSubsystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("DynamicSubsystem");

	return Clss;
}


// DynamicSubsystem Engine.Default__DynamicSubsystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UDynamicSubsystem* UDynamicSubsystem::GetDefaultObj()
{
	static class UDynamicSubsystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UDynamicSubsystem*>(UDynamicSubsystem::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EngineSubsystem
// (None)

class UClass* UEngineSubsystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EngineSubsystem");

	return Clss;
}


// EngineSubsystem Engine.Default__EngineSubsystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UEngineSubsystem* UEngineSubsystem::GetDefaultObj()
{
	static class UEngineSubsystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UEngineSubsystem*>(UEngineSubsystem::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.EngineTypes
// (None)

class UClass* UEngineTypes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("EngineTypes");

	return Clss;
}


// EngineTypes Engine.Default__EngineTypes
// (Public, ClassDefaultObject, ArchetypeObject)

class UEngineTypes* UEngineTypes::GetDefaultObj()
{
	static class UEngineTypes* Default = nullptr;

	if (!Default)
		Default = static_cast<UEngineTypes*>(UEngineTypes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ExponentialHeightFog
// (Actor)

class UClass* AExponentialHeightFog::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ExponentialHeightFog");

	return Clss;
}


// ExponentialHeightFog Engine.Default__ExponentialHeightFog
// (Public, ClassDefaultObject, ArchetypeObject)

class AExponentialHeightFog* AExponentialHeightFog::GetDefaultObj()
{
	static class AExponentialHeightFog* Default = nullptr;

	if (!Default)
		Default = static_cast<AExponentialHeightFog*>(AExponentialHeightFog::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ExponentialHeightFog.OnRep_bEnabled
// (Native, Public)
// Parameters:

void AExponentialHeightFog::OnRep_bEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFog", "OnRep_bEnabled");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.ExponentialHeightFogComponent
// (SceneComponent)

class UClass* UExponentialHeightFogComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ExponentialHeightFogComponent");

	return Clss;
}


// ExponentialHeightFogComponent Engine.Default__ExponentialHeightFogComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UExponentialHeightFogComponent* UExponentialHeightFogComponent::GetDefaultObj()
{
	static class UExponentialHeightFogComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UExponentialHeightFogComponent*>(UExponentialHeightFogComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogScatteringDistribution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogScatteringDistribution(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetVolumetricFogScatteringDistribution");

	Params::UExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogExtinctionScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogExtinctionScale(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetVolumetricFogExtinctionScale");

	Params::UExponentialHeightFogComponent_SetVolumetricFogExtinctionScale_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogEmissive
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogEmissive(const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetVolumetricFogEmissive");

	Params::UExponentialHeightFogComponent_SetVolumetricFogEmissive_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogDistance(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetVolumetricFogDistance");

	Params::UExponentialHeightFogComponent_SetVolumetricFogDistance_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogAlbedo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                      NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogAlbedo(const struct FColor& NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetVolumetricFogAlbedo");

	Params::UExponentialHeightFogComponent_SetVolumetricFogAlbedo_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFog(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetVolumetricFog");

	Params::UExponentialHeightFogComponent_SetVolumetricFog_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetStartDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetStartDistance(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetStartDistance");

	Params::UExponentialHeightFogComponent_SetStartDistance_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetNonDirectionalInscatteringColorDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetNonDirectionalInscatteringColorDistance(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetNonDirectionalInscatteringColorDistance");

	Params::UExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringTextureTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetInscatteringTextureTint(const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetInscatteringTextureTint");

	Params::UExponentialHeightFogComponent_SetInscatteringTextureTint_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemapAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetInscatteringColorCubemapAngle(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetInscatteringColorCubemapAngle");

	Params::UExponentialHeightFogComponent_SetInscatteringColorCubemapAngle_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureCube*                Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetInscatteringColorCubemap(class UTextureCube* Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetInscatteringColorCubemap");

	Params::UExponentialHeightFogComponent_SetInscatteringColorCubemap_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetFullyDirectionalInscatteringColorDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFullyDirectionalInscatteringColorDistance(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetFullyDirectionalInscatteringColorDistance");

	Params::UExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogMaxOpacity(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetFogMaxOpacity");

	Params::UExponentialHeightFogComponent_SetFogMaxOpacity_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogInscatteringColor(const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetFogInscatteringColor");

	Params::UExponentialHeightFogComponent_SetFogInscatteringColor_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogHeightFalloff(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetFogHeightFalloff");

	Params::UExponentialHeightFogComponent_SetFogHeightFalloff_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetFogDensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogDensity(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetFogDensity");

	Params::UExponentialHeightFogComponent_SetFogDensity_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetFogCutoffDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogCutoffDistance(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetFogCutoffDistance");

	Params::UExponentialHeightFogComponent_SetFogCutoffDistance_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetDirectionalInscatteringStartDistance(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetDirectionalInscatteringStartDistance");

	Params::UExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetDirectionalInscatteringExponent(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetDirectionalInscatteringExponent");

	Params::UExponentialHeightFogComponent_SetDirectionalInscatteringExponent_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetDirectionalInscatteringColor(const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ExponentialHeightFogComponent", "SetDirectionalInscatteringColor");

	Params::UExponentialHeightFogComponent_SetDirectionalInscatteringColor_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.Exporter
// (None)

class UClass* UExporter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Exporter");

	return Clss;
}


// Exporter Engine.Default__Exporter
// (Public, ClassDefaultObject, ArchetypeObject)

class UExporter* UExporter::GetDefaultObj()
{
	static class UExporter* Default = nullptr;

	if (!Default)
		Default = static_cast<UExporter*>(UExporter::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.Exporter.ScriptRunAssetExportTask
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAssetExportTask*            Task                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExporter::ScriptRunAssetExportTask(class UAssetExportTask* Task)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Exporter", "ScriptRunAssetExportTask");

	Params::UExporter_ScriptRunAssetExportTask_Params Parms{};

	Parms.Task = Task;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;

}


// Function Engine.Exporter.RunAssetExportTasks
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UAssetExportTask*>    ExportTasks                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExporter::RunAssetExportTasks(TArray<class UAssetExportTask*>& ExportTasks)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Exporter", "RunAssetExportTasks");

	Params::UExporter_RunAssetExportTasks_Params Parms{};

	Parms.ExportTasks = ExportTasks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.Exporter.RunAssetExportTask
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAssetExportTask*            Task                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExporter::RunAssetExportTask(class UAssetExportTask* Task)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("Exporter", "RunAssetExportTask");

	Params::UExporter_RunAssetExportTask_Params Parms{};

	Parms.Task = Task;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.Font
// (None)

class UClass* UFont::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Font");

	return Clss;
}


// Font Engine.Default__Font
// (Public, ClassDefaultObject, ArchetypeObject)

class UFont* UFont::GetDefaultObj()
{
	static class UFont* Default = nullptr;

	if (!Default)
		Default = static_cast<UFont*>(UFont::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.FontFace
// (None)

class UClass* UFontFace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FontFace");

	return Clss;
}


// FontFace Engine.Default__FontFace
// (Public, ClassDefaultObject, ArchetypeObject)

class UFontFace* UFontFace::GetDefaultObj()
{
	static class UFontFace* Default = nullptr;

	if (!Default)
		Default = static_cast<UFontFace*>(UFontFace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.FontImportOptions
// (None)

class UClass* UFontImportOptions::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("FontImportOptions");

	return Clss;
}


// FontImportOptions Engine.Default__FontImportOptions
// (Public, ClassDefaultObject, ArchetypeObject)

class UFontImportOptions* UFontImportOptions::GetDefaultObj()
{
	static class UFontImportOptions* Default = nullptr;

	if (!Default)
		Default = static_cast<UFontImportOptions*>(UFontImportOptions::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ForceFeedbackAttenuation
// (None)

class UClass* UForceFeedbackAttenuation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ForceFeedbackAttenuation");

	return Clss;
}


// ForceFeedbackAttenuation Engine.Default__ForceFeedbackAttenuation
// (Public, ClassDefaultObject, ArchetypeObject)

class UForceFeedbackAttenuation* UForceFeedbackAttenuation::GetDefaultObj()
{
	static class UForceFeedbackAttenuation* Default = nullptr;

	if (!Default)
		Default = static_cast<UForceFeedbackAttenuation*>(UForceFeedbackAttenuation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ForceFeedbackComponent
// (SceneComponent)

class UClass* UForceFeedbackComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ForceFeedbackComponent");

	return Clss;
}


// ForceFeedbackComponent Engine.Default__ForceFeedbackComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UForceFeedbackComponent* UForceFeedbackComponent::GetDefaultObj()
{
	static class UForceFeedbackComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UForceFeedbackComponent*>(UForceFeedbackComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ForceFeedbackComponent.Stop
// (Native, Public, BlueprintCallable)
// Parameters:

void UForceFeedbackComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForceFeedbackComponent", "Stop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ForceFeedbackComponent.SetIntensityMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewIntensityMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForceFeedbackComponent::SetIntensityMultiplier(float NewIntensityMultiplier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForceFeedbackComponent", "SetIntensityMultiplier");

	Params::UForceFeedbackComponent_SetIntensityMultiplier_Params Parms{};

	Parms.NewIntensityMultiplier = NewIntensityMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ForceFeedbackComponent.SetForceFeedbackEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*        NewForceFeedbackEffect                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForceFeedbackComponent::SetForceFeedbackEffect(class UForceFeedbackEffect* NewForceFeedbackEffect)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForceFeedbackComponent", "SetForceFeedbackEffect");

	Params::UForceFeedbackComponent_SetForceFeedbackEffect_Params Parms{};

	Parms.NewForceFeedbackEffect = NewForceFeedbackEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ForceFeedbackComponent.Play
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForceFeedbackComponent::Play(float StartTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForceFeedbackComponent", "Play");

	Params::UForceFeedbackComponent_Play_Params Parms{};

	Parms.StartTime = StartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ForceFeedbackComponent.BP_GetAttenuationSettingsToApply
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FForceFeedbackAttenuationSettingsOutAttenuationSettings                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForceFeedbackComponent::BP_GetAttenuationSettingsToApply(struct FForceFeedbackAttenuationSettings* OutAttenuationSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForceFeedbackComponent", "BP_GetAttenuationSettingsToApply");

	Params::UForceFeedbackComponent_BP_GetAttenuationSettingsToApply_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutAttenuationSettings != nullptr)
		*OutAttenuationSettings = std::move(Parms.OutAttenuationSettings);

	return Parms.ReturnValue;

}


// Function Engine.ForceFeedbackComponent.AdjustAttenuation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FForceFeedbackAttenuationSettingsInAttenuationSettings                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UForceFeedbackComponent::AdjustAttenuation(struct FForceFeedbackAttenuationSettings& InAttenuationSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ForceFeedbackComponent", "AdjustAttenuation");

	Params::UForceFeedbackComponent_AdjustAttenuation_Params Parms{};

	Parms.InAttenuationSettings = InAttenuationSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.ForceFeedbackEffect
// (None)

class UClass* UForceFeedbackEffect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ForceFeedbackEffect");

	return Clss;
}


// ForceFeedbackEffect Engine.Default__ForceFeedbackEffect
// (Public, ClassDefaultObject, ArchetypeObject)

class UForceFeedbackEffect* UForceFeedbackEffect::GetDefaultObj()
{
	static class UForceFeedbackEffect* Default = nullptr;

	if (!Default)
		Default = static_cast<UForceFeedbackEffect*>(UForceFeedbackEffect::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.GameNetworkManager
// (Actor)

class UClass* AGameNetworkManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameNetworkManager");

	return Clss;
}


// GameNetworkManager Engine.Default__GameNetworkManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AGameNetworkManager* AGameNetworkManager::GetDefaultObj()
{
	static class AGameNetworkManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AGameNetworkManager*>(AGameNetworkManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.GameplayStatics
// (None)

class UClass* UGameplayStatics::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GameplayStatics");

	return Clss;
}


// GameplayStatics Engine.Default__GameplayStatics
// (Public, ClassDefaultObject, ArchetypeObject)

class UGameplayStatics* UGameplayStatics::GetDefaultObj()
{
	static class UGameplayStatics* Default = nullptr;

	if (!Default)
		Default = static_cast<UGameplayStatics*>(UGameplayStatics::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.GameplayStatics.UnloadStreamLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        LevelName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo           LatentInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bShouldBlockOnUnload                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::UnloadStreamLevel(class UObject* WorldContextObject, class FName LevelName, const struct FLatentActionInfo& LatentInfo, bool bShouldBlockOnUnload)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "UnloadStreamLevel");

	Params::UGameplayStatics_UnloadStreamLevel_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;
	Parms.LatentInfo = LatentInfo;
	Parms.bShouldBlockOnUnload = bShouldBlockOnUnload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SuggestProjectileVelocity_CustomArc
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutLaunchVelocity                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     StartPos                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     EndPos                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OverrideGravityZ                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ArcParam                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::SuggestProjectileVelocity_CustomArc(class UObject* WorldContextObject, struct FVector* OutLaunchVelocity, const struct FVector& StartPos, const struct FVector& EndPos, float OverrideGravityZ, float ArcParam)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SuggestProjectileVelocity_CustomArc");

	Params::UGameplayStatics_SuggestProjectileVelocity_CustomArc_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPos = StartPos;
	Parms.EndPos = EndPos;
	Parms.OverrideGravityZ = OverrideGravityZ;
	Parms.ArcParam = ArcParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutLaunchVelocity != nullptr)
		*OutLaunchVelocity = std::move(Parms.OutLaunchVelocity);

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnSoundAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USoundBase*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             AttachToComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        AttachPointName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// enum class EAttachLocation         LocationType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bStopWhenAttachedToDestroyed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*           AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnSoundAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, enum class EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnSoundAttached");

	Params::UGameplayStatics_SpawnSoundAttached_Params Parms{};

	Parms.Sound = Sound;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnSoundAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*           AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnSoundAtLocation(class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnSoundAtLocation");

	Params::UGameplayStatics_SpawnSoundAtLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnSound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPersistAcrossLevelTransition                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnSound2D(class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnSound2D");

	Params::UGameplayStatics_SpawnSound2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UObject>         ObjectClass                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     Outer                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UGameplayStatics::SpawnObject(TSubclassOf<class UObject> ObjectClass, class UObject* Outer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnObject");

	Params::UGameplayStatics_SpawnObject_Params Parms{};

	Parms.ObjectClass = ObjectClass;
	Parms.Outer = Outer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnForceFeedbackAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*        ForceFeedbackEffect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             AttachToComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        AttachPointName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// enum class EAttachLocation         LocationType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bStopWhenAttachedToDestroyed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLooping                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              IntensityMultiplier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackAttenuation*   AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackComponent*     ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UForceFeedbackComponent* UGameplayStatics::SpawnForceFeedbackAttached(class UForceFeedbackEffect* ForceFeedbackEffect, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, enum class EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnForceFeedbackAttached");

	Params::UGameplayStatics_SpawnForceFeedbackAttached_Params Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.bLooping = bLooping;
	Parms.IntensityMultiplier = IntensityMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnForceFeedbackAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*        ForceFeedbackEffect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                               bLooping                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              IntensityMultiplier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackAttenuation*   AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackComponent*     ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UForceFeedbackComponent* UGameplayStatics::SpawnForceFeedbackAtLocation(class UObject* WorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, const struct FVector& Location, const struct FRotator& Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnForceFeedbackAtLocation");

	Params::UGameplayStatics_SpawnForceFeedbackAtLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.bLooping = bLooping;
	Parms.IntensityMultiplier = IntensityMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnEmitterAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleSystem*             EmitterTemplate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             AttachToComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        AttachPointName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachLocation         LocationType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPSCPoolMethod          PoolingMethod                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*    ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UGameplayStatics::SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, enum class EAttachLocation LocationType, bool bAutoDestroy, enum class EPSCPoolMethod PoolingMethod)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnEmitterAttached");

	Params::UGameplayStatics_SpawnEmitterAttached_Params Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.Scale = Scale;
	Parms.LocationType = LocationType;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.PoolingMethod = PoolingMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnEmitterAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*             EmitterTemplate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EPSCPoolMethod          PoolingMethod                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*    ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UGameplayStatics::SpawnEmitterAtLocation(class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, enum class EPSCPoolMethod PoolingMethod)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnEmitterAtLocation");

	Params::UGameplayStatics_SpawnEmitterAtLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EmitterTemplate = EmitterTemplate;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.Scale = Scale;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.PoolingMethod = PoolingMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnDialogueAttached
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDialogueWave*               Dialogue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext            Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USceneComponent*             AttachToComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        AttachPointName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// enum class EAttachLocation         LocationType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bStopWhenAttachedToDestroyed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*           AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnDialogueAttached(class UDialogueWave* Dialogue, struct FDialogueContext& Context, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, enum class EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnDialogueAttached");

	Params::UGameplayStatics_SpawnDialogueAttached_Params Parms{};

	Parms.Dialogue = Dialogue;
	Parms.Context = Context;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnDialogueAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueWave*               Dialogue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext            Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*           AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnDialogueAtLocation(class UObject* WorldContextObject, class UDialogueWave* Dialogue, struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnDialogueAtLocation");

	Params::UGameplayStatics_SpawnDialogueAtLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Dialogue = Dialogue;
	Parms.Context = Context;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnDialogue2D
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueWave*               Dialogue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext            Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnDialogue2D(class UObject* WorldContextObject, class UDialogueWave* Dialogue, struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnDialogue2D");

	Params::UGameplayStatics_SpawnDialogue2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Dialogue = Dialogue;
	Parms.Context = Context;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnDecalAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          DecalMaterial                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     DecalSize                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*             AttachToComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        AttachPointName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// enum class EAttachLocation         LocationType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LifeSpan                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDecalComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalComponent* UGameplayStatics::SpawnDecalAttached(class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, enum class EAttachLocation LocationType, float LifeSpan)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnDecalAttached");

	Params::UGameplayStatics_SpawnDecalAttached_Params Parms{};

	Parms.DecalMaterial = DecalMaterial;
	Parms.DecalSize = DecalSize;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.LocationType = LocationType;
	Parms.LifeSpan = LifeSpan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SpawnDecalAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          DecalMaterial                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     DecalSize                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              LifeSpan                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDecalComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalComponent* UGameplayStatics::SpawnDecalAtLocation(class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SpawnDecalAtLocation");

	Params::UGameplayStatics_SpawnDecalAtLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DecalMaterial = DecalMaterial;
	Parms.DecalSize = DecalSize;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.LifeSpan = LifeSpan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SetWorldOriginLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                  NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetWorldOriginLocation(class UObject* WorldContextObject, const struct FIntVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetWorldOriginLocation");

	Params::UGameplayStatics_SetWorldOriginLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NewLocation = NewLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetSubtitlesEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetSubtitlesEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetSubtitlesEnabled");

	Params::UGameplayStatics_SetSubtitlesEnabled_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetSoundMixClassOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                   InSoundMixModifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundClass*                 InSoundClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Volume                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Pitch                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FadeInTime                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bApplyToChildren                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetSoundMixClassOverride(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetSoundMixClassOverride");

	Params::UGameplayStatics_SetSoundMixClassOverride_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMixModifier = InSoundMixModifier;
	Parms.InSoundClass = InSoundClass;
	Parms.Volume = Volume;
	Parms.Pitch = Pitch;
	Parms.FadeInTime = FadeInTime;
	Parms.bApplyToChildren = bApplyToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetPlayerControllerID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*           Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ControllerId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetPlayerControllerID(class APlayerController* Player, int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetPlayerControllerID");

	Params::UGameplayStatics_SetPlayerControllerID_Params Parms{};

	Parms.Player = Player;
	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetMaxAudioChannelsScaled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxChannelCountScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetMaxAudioChannelsScaled(class UObject* WorldContextObject, float MaxChannelCountScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetMaxAudioChannelsScaled");

	Params::UGameplayStatics_SetMaxAudioChannelsScaled_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MaxChannelCountScale = MaxChannelCountScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetGlobalTimeDilation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TimeDilation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetGlobalTimeDilation(class UObject* WorldContextObject, float TimeDilation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetGlobalTimeDilation");

	Params::UGameplayStatics_SetGlobalTimeDilation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TimeDilation = TimeDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetGlobalPitchModulation
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchModulation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TimeSec                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetGlobalPitchModulation(class UObject* WorldContextObject, float PitchModulation, float TimeSec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetGlobalPitchModulation");

	Params::UGameplayStatics_SetGlobalPitchModulation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PitchModulation = PitchModulation;
	Parms.TimeSec = TimeSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetGlobalListenerFocusParameters
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FocusAzimuthScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NonFocusAzimuthScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FocusDistanceScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NonFocusDistanceScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FocusVolumeScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NonFocusVolumeScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FocusPriorityScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NonFocusPriorityScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetGlobalListenerFocusParameters(class UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetGlobalListenerFocusParameters");

	Params::UGameplayStatics_SetGlobalListenerFocusParameters_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FocusAzimuthScale = FocusAzimuthScale;
	Parms.NonFocusAzimuthScale = NonFocusAzimuthScale;
	Parms.FocusDistanceScale = FocusDistanceScale;
	Parms.NonFocusDistanceScale = NonFocusDistanceScale;
	Parms.FocusVolumeScale = FocusVolumeScale;
	Parms.NonFocusVolumeScale = NonFocusVolumeScale;
	Parms.FocusPriorityScale = FocusPriorityScale;
	Parms.NonFocusPriorityScale = NonFocusPriorityScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetGamePaused
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPaused                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::SetGamePaused(class UObject* WorldContextObject, bool bPaused)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetGamePaused");

	Params::UGameplayStatics_SetGamePaused_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bPaused = bPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.SetEnableWorldRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetEnableWorldRendering(class UObject* WorldContextObject, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetEnableWorldRendering");

	Params::UGameplayStatics_SetEnableWorldRendering_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SetBaseSoundMix
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                   InSoundMix                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetBaseSoundMix(class UObject* WorldContextObject, class USoundMix* InSoundMix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SetBaseSoundMix");

	Params::UGameplayStatics_SetBaseSoundMix_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMix = InSoundMix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.SaveGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USaveGame*                   SaveGameObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SlotName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::SaveGameToSlot(class USaveGame* SaveGameObject, const class FString& SlotName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "SaveGameToSlot");

	Params::UGameplayStatics_SaveGameToSlot_Params Parms{};

	Parms.SaveGameObject = SaveGameObject;
	Parms.SlotName = SlotName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.RemovePlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*           Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDestroyPawn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::RemovePlayer(class APlayerController* Player, bool bDestroyPawn)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "RemovePlayer");

	Params::UGameplayStatics_RemovePlayer_Params Parms{};

	Parms.Player = Player;
	Parms.bDestroyPawn = bDestroyPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.RebaseZeroOriginOntoLocal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameplayStatics::RebaseZeroOriginOntoLocal(class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "RebaseZeroOriginOntoLocal");

	Params::UGameplayStatics_RebaseZeroOriginOntoLocal_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = WorldLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.RebaseLocalOriginOntoZero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameplayStatics::RebaseLocalOriginOntoZero(class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "RebaseLocalOriginOntoZero");

	Params::UGameplayStatics_RebaseLocalOriginOntoZero_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = WorldLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.PushSoundMixModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                   InSoundMixModifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PushSoundMixModifier(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "PushSoundMixModifier");

	Params::UGameplayStatics_PushSoundMixModifier_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMixModifier = InSoundMixModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.ProjectWorldToScreen
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*           Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldPosition                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPosition                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPlayerViewportRelative                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::ProjectWorldToScreen(class APlayerController* Player, struct FVector& WorldPosition, struct FVector2D* ScreenPosition, bool bPlayerViewportRelative)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ProjectWorldToScreen");

	Params::UGameplayStatics_ProjectWorldToScreen_Params Parms{};

	Parms.Player = Player;
	Parms.WorldPosition = WorldPosition;
	Parms.bPlayerViewportRelative = bPlayerViewportRelative;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ScreenPosition != nullptr)
		*ScreenPosition = std::move(Parms.ScreenPosition);

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.PopSoundMixModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                   InSoundMixModifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PopSoundMixModifier(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "PopSoundMixModifier");

	Params::UGameplayStatics_PopSoundMixModifier_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMixModifier = InSoundMixModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.PlayWorldCameraShake
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCameraShake>    Shake                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Epicenter                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InnerRadius                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OuterRadius                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Falloff                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bOrientShakeTowardsEpicenter                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlayWorldCameraShake(class UObject* WorldContextObject, TSubclassOf<class UCameraShake> Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "PlayWorldCameraShake");

	Params::UGameplayStatics_PlayWorldCameraShake_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Shake = Shake;
	Parms.Epicenter = Epicenter;
	Parms.InnerRadius = InnerRadius;
	Parms.OuterRadius = OuterRadius;
	Parms.Falloff = Falloff;
	Parms.bOrientShakeTowardsEpicenter = bOrientShakeTowardsEpicenter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.PlaySoundAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*           AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OwningActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlaySoundAtLocation(class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "PlaySoundAtLocation");

	Params::UGameplayStatics_PlaySoundAtLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.PlaySound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      OwningActor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlaySound2D(class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "PlaySound2D");

	Params::UGameplayStatics_PlaySound2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.PlayDialogueAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueWave*               Dialogue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext            Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*           AttenuationSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlayDialogueAtLocation(class UObject* WorldContextObject, class UDialogueWave* Dialogue, struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "PlayDialogueAtLocation");

	Params::UGameplayStatics_PlayDialogueAtLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Dialogue = Dialogue;
	Parms.Context = Context;
	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.PlayDialogue2D
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueWave*               Dialogue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext            Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlayDialogue2D(class UObject* WorldContextObject, class UDialogueWave* Dialogue, struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "PlayDialogue2D");

	Params::UGameplayStatics_PlayDialogue2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Dialogue = Dialogue;
	Parms.Context = Context;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.ParseOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Options                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameplayStatics::ParseOption(const class FString& Options, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ParseOption");

	Params::UGameplayStatics_ParseOption_Params Parms{};

	Parms.Options = Options;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.OpenLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        LevelName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAbsolute                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Options                                                          (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::OpenLevel(class UObject* WorldContextObject, class FName LevelName, bool bAbsolute, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "OpenLevel");

	Params::UGameplayStatics_OpenLevel_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;
	Parms.bAbsolute = bAbsolute;
	Parms.Options = Options;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.MakeHitResult
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               bBlockingHit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInitialOverlap                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Distance                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ImpactPoint                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Normal                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ImpactNormal                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*           PhysMat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      HitActor                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         HitComponent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        HitBoneName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              HitItem                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              FaceIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TraceStart                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TraceEnd                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UGameplayStatics::MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, float Distance, const struct FVector& Location, const struct FVector& ImpactPoint, const struct FVector& Normal, const struct FVector& ImpactNormal, class UPhysicalMaterial* PhysMat, class AActor* HitActor, class UPrimitiveComponent* HitComponent, class FName HitBoneName, int32 HitItem, int32 FaceIndex, const struct FVector& TraceStart, const struct FVector& TraceEnd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "MakeHitResult");

	Params::UGameplayStatics_MakeHitResult_Params Parms{};

	Parms.bBlockingHit = bBlockingHit;
	Parms.bInitialOverlap = bInitialOverlap;
	Parms.Time = Time;
	Parms.Distance = Distance;
	Parms.Location = Location;
	Parms.ImpactPoint = ImpactPoint;
	Parms.Normal = Normal;
	Parms.ImpactNormal = ImpactNormal;
	Parms.PhysMat = PhysMat;
	Parms.HitActor = HitActor;
	Parms.HitComponent = HitComponent;
	Parms.HitBoneName = HitBoneName;
	Parms.HitItem = HitItem;
	Parms.FaceIndex = FaceIndex;
	Parms.TraceStart = TraceStart;
	Parms.TraceEnd = TraceEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.LoadStreamLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        LevelName                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bMakeVisibleAfterLoad                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShouldBlockOnLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo           LatentInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGameplayStatics::LoadStreamLevel(class UObject* WorldContextObject, class FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "LoadStreamLevel");

	Params::UGameplayStatics_LoadStreamLevel_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;
	Parms.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	Parms.bShouldBlockOnLoad = bShouldBlockOnLoad;
	Parms.LatentInfo = LatentInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.LoadGameFromSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      SlotName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UGameplayStatics::LoadGameFromSlot(const class FString& SlotName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "LoadGameFromSlot");

	Params::UGameplayStatics_LoadGameFromSlot_Params Parms{};

	Parms.SlotName = SlotName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.IsGamePaused
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::IsGamePaused(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "IsGamePaused");

	Params::UGameplayStatics_IsGamePaused_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.HasOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Options                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InKey                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::HasOption(const class FString& Options, const class FString& InKey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "HasOption");

	Params::UGameplayStatics_HasOption_Params Parms{};

	Parms.Options = Options;
	Parms.InKey = InKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.HasLaunchOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      OptionToCheck                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::HasLaunchOption(const class FString& OptionToCheck)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "HasLaunchOption");

	Params::UGameplayStatics_HasLaunchOption_Params Parms{};

	Parms.OptionToCheck = OptionToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GrassOverlappingSphereCount
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                 StaticMesh                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     CenterPosition                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GrassOverlappingSphereCount(class UObject* WorldContextObject, class UStaticMesh* StaticMesh, const struct FVector& CenterPosition, float Radius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GrassOverlappingSphereCount");

	Params::UGameplayStatics_GrassOverlappingSphereCount_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StaticMesh = StaticMesh;
	Parms.CenterPosition = CenterPosition;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetWorldOriginLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UGameplayStatics::GetWorldOriginLocation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetWorldOriginLocation");

	Params::UGameplayStatics_GetWorldOriginLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetWorldDeltaSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetWorldDeltaSeconds(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetWorldDeltaSeconds");

	Params::UGameplayStatics_GetWorldDeltaSeconds_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetUnpausedTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetUnpausedTimeSeconds(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetUnpausedTimeSeconds");

	Params::UGameplayStatics_GetUnpausedTimeSeconds_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetTimeSeconds(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetTimeSeconds");

	Params::UGameplayStatics_GetTimeSeconds_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetSurfaceType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// enum class EPhysicalSurface        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class EPhysicalSurface UGameplayStatics::GetSurfaceType(struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetSurfaceType");

	Params::UGameplayStatics_GetSurfaceType_Params Parms{};

	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetStreamingLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PackageName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreaming*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreaming* UGameplayStatics::GetStreamingLevel(class UObject* WorldContextObject, class FName PackageName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetStreamingLevel");

	Params::UGameplayStatics_GetStreamingLevel_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PackageName = PackageName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetRealTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetRealTimeSeconds(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetRealTimeSeconds");

	Params::UGameplayStatics_GetRealTimeSeconds_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetPlayerPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PlayerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UGameplayStatics::GetPlayerPawn(class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetPlayerPawn");

	Params::UGameplayStatics_GetPlayerPawn_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetPlayerControllerID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*           Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetPlayerControllerID(class APlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetPlayerControllerID");

	Params::UGameplayStatics_GetPlayerControllerID_Params Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetPlayerControllerFromID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ControllerId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UGameplayStatics::GetPlayerControllerFromID(class UObject* WorldContextObject, int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetPlayerControllerFromID");

	Params::UGameplayStatics_GetPlayerControllerFromID_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PlayerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UGameplayStatics::GetPlayerController(class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetPlayerController");

	Params::UGameplayStatics_GetPlayerController_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetPlayerCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PlayerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UGameplayStatics::GetPlayerCharacter(class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetPlayerCharacter");

	Params::UGameplayStatics_GetPlayerCharacter_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetPlayerCameraManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              PlayerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerCameraManager*        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerCameraManager* UGameplayStatics::GetPlayerCameraManager(class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetPlayerCameraManager");

	Params::UGameplayStatics_GetPlayerCameraManager_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetPlatformName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameplayStatics::GetPlatformName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetPlatformName");

	Params::UGameplayStatics_GetPlatformName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetObjectClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UGameplayStatics::GetObjectClass(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetObjectClass");

	Params::UGameplayStatics_GetObjectClass_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetMaxAudioChannelCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetMaxAudioChannelCount(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetMaxAudioChannelCount");

	Params::UGameplayStatics_GetMaxAudioChannelCount_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetKeyValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Pair                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Value                                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::GetKeyValue(const class FString& Pair, class FString* Key, class FString* Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetKeyValue");

	Params::UGameplayStatics_GetKeyValue_Params Parms{};

	Parms.Pair = Pair;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Key != nullptr)
		*Key = std::move(Parms.Key);

	if (Value != nullptr)
		*Value = std::move(Parms.Value);

}


// Function Engine.GameplayStatics.GetIntOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Options                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              DefaultValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetIntOption(const class FString& Options, const class FString& Key, int32 DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetIntOption");

	Params::UGameplayStatics_GetIntOption_Params Parms{};

	Parms.Options = Options;
	Parms.Key = Key;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetGlobalTimeDilation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetGlobalTimeDilation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetGlobalTimeDilation");

	Params::UGameplayStatics_GetGlobalTimeDilation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameStateBase*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameStateBase* UGameplayStatics::GetGameState(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetGameState");

	Params::UGameplayStatics_GetGameState_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameModeBase*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameModeBase* UGameplayStatics::GetGameMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetGameMode");

	Params::UGameplayStatics_GetGameMode_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameInstance*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameInstance* UGameplayStatics::GetGameInstance(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetGameInstance");

	Params::UGameplayStatics_GetGameInstance_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetEnableWorldRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::GetEnableWorldRendering(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetEnableWorldRendering");

	Params::UGameplayStatics_GetEnableWorldRendering_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetCurrentReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReverbEffect*               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UReverbEffect* UGameplayStatics::GetCurrentReverbEffect(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetCurrentReverbEffect");

	Params::UGameplayStatics_GetCurrentReverbEffect_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetCurrentLevelName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRemovePrefixString                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameplayStatics::GetCurrentLevelName(class UObject* WorldContextObject, bool bRemovePrefixString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetCurrentLevelName");

	Params::UGameplayStatics_GetCurrentLevelName_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bRemovePrefixString = bRemovePrefixString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetAudioTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetAudioTimeSeconds(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetAudioTimeSeconds");

	Params::UGameplayStatics_GetAudioTimeSeconds_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetAllActorsWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Tag                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAllActorsWithTag(class UObject* WorldContextObject, class FName Tag, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetAllActorsWithTag");

	Params::UGameplayStatics_GetAllActorsWithTag_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

}


// Function Engine.GameplayStatics.GetAllActorsWithInterface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>      Interface                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAllActorsWithInterface(class UObject* WorldContextObject, TSubclassOf<class IInterface> Interface, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetAllActorsWithInterface");

	Params::UGameplayStatics_GetAllActorsWithInterface_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Interface = Interface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

}


// Function Engine.GameplayStatics.GetAllActorsOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>          ActorClass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAllActorsOfClass(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetAllActorsOfClass");

	Params::UGameplayStatics_GetAllActorsOfClass_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

}


// Function Engine.GameplayStatics.GetActorArrayBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>              Actors                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bOnlyCollidingComponents                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Center                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxExtent                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::GetActorArrayBounds(TArray<class AActor*>& Actors, bool bOnlyCollidingComponents, struct FVector* Center, struct FVector* BoxExtent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetActorArrayBounds");

	Params::UGameplayStatics_GetActorArrayBounds_Params Parms{};

	Parms.Actors = Actors;
	Parms.bOnlyCollidingComponents = bOnlyCollidingComponents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Center != nullptr)
		*Center = std::move(Parms.Center);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);

}


// Function Engine.GameplayStatics.GetActorArrayAverageLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>              Actors                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameplayStatics::GetActorArrayAverageLocation(TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetActorArrayAverageLocation");

	Params::UGameplayStatics_GetActorArrayAverageLocation_Params Parms{};

	Parms.Actors = Actors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.GetAccurateRealTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Seconds                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PartialSeconds                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAccurateRealTime(class UObject* WorldContextObject, int32* Seconds, float* PartialSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "GetAccurateRealTime");

	Params::UGameplayStatics_GetAccurateRealTime_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Seconds != nullptr)
		*Seconds = Parms.Seconds;

	if (PartialSeconds != nullptr)
		*PartialSeconds = Parms.PartialSeconds;

}


// Function Engine.GameplayStatics.FlushLevelStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::FlushLevelStreaming(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "FlushLevelStreaming");

	Params::UGameplayStatics_FlushLevelStreaming_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.FinishSpawningActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                      Actor                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  SpawnTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::FinishSpawningActor(class AActor* Actor, struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "FinishSpawningActor");

	Params::UGameplayStatics_FinishSpawningActor_Params Parms{};

	Parms.Actor = Actor;
	Parms.SpawnTransform = SpawnTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.FindCollisionUV
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                              UVChannel                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   UV                                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::FindCollisionUV(struct FHitResult& Hit, int32 UVChannel, struct FVector2D* UV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "FindCollisionUV");

	Params::UGameplayStatics_FindCollisionUV_Params Parms{};

	Parms.Hit = Hit;
	Parms.UVChannel = UVChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (UV != nullptr)
		*UV = std::move(Parms.UV);

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.EnableLiveStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               Enable                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::EnableLiveStreaming(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "EnableLiveStreaming");

	Params::UGameplayStatics_EnableLiveStreaming_Params Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.DoesSaveGameExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      SlotName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::DoesSaveGameExist(const class FString& SlotName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "DoesSaveGameExist");

	Params::UGameplayStatics_DoesSaveGameExist_Params Parms{};

	Parms.SlotName = SlotName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.DeprojectScreenToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*           Player                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ScreenPosition                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldPosition                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldDirection                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::DeprojectScreenToWorld(class APlayerController* Player, struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "DeprojectScreenToWorld");

	Params::UGameplayStatics_DeprojectScreenToWorld_Params Parms{};

	Parms.Player = Player;
	Parms.ScreenPosition = ScreenPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (WorldPosition != nullptr)
		*WorldPosition = std::move(Parms.WorldPosition);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.DeleteGameInSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      SlotName                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              UserIndex                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::DeleteGameInSlot(const class FString& SlotName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "DeleteGameInSlot");

	Params::UGameplayStatics_DeleteGameInSlot_Params Parms{};

	Parms.SlotName = SlotName;
	Parms.UserIndex = UserIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.DeactivateReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        TagName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::DeactivateReverbEffect(class UObject* WorldContextObject, class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "DeactivateReverbEffect");

	Params::UGameplayStatics_DeactivateReverbEffect_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.CreateSound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                  Sound                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VolumeMultiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PitchMultiplier                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StartTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*           ConcurrencySettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPersistAcrossLevelTransition                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAutoDestroy                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*             ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::CreateSound2D(class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "CreateSound2D");

	Params::UGameplayStatics_CreateSound2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.CreateSaveGameObjectFromBlueprint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBlueprint*                  SaveGameBlueprint                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UGameplayStatics::CreateSaveGameObjectFromBlueprint(class UBlueprint* SaveGameBlueprint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "CreateSaveGameObjectFromBlueprint");

	Params::UGameplayStatics_CreateSaveGameObjectFromBlueprint_Params Parms{};

	Parms.SaveGameBlueprint = SaveGameBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.CreateSaveGameObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class USaveGame>       SaveGameClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UGameplayStatics::CreateSaveGameObject(TSubclassOf<class USaveGame> SaveGameClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "CreateSaveGameObject");

	Params::UGameplayStatics_CreateSaveGameObject_Params Parms{};

	Parms.SaveGameClass = SaveGameClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.CreatePlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ControllerId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSpawnPlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UGameplayStatics::CreatePlayer(class UObject* WorldContextObject, int32 ControllerId, bool bSpawnPlayerController)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "CreatePlayer");

	Params::UGameplayStatics_CreatePlayer_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ControllerId = ControllerId;
	Parms.bSpawnPlayerController = bSpawnPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.ClearSoundMixModifiers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::ClearSoundMixModifiers(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ClearSoundMixModifiers");

	Params::UGameplayStatics_ClearSoundMixModifiers_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.ClearSoundMixClassOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                   InSoundMixModifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundClass*                 InSoundClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FadeOutTime                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::ClearSoundMixClassOverride(class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float FadeOutTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ClearSoundMixClassOverride");

	Params::UGameplayStatics_ClearSoundMixClassOverride_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMixModifier = InSoundMixModifier;
	Parms.InSoundClass = InSoundClass;
	Parms.FadeOutTime = FadeOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.CancelAsyncLoading
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UGameplayStatics::CancelAsyncLoading()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "CancelAsyncLoading");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.GameplayStatics.BreakHitResult
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                  Hit                                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bBlockingHit                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bInitialOverlap                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Distance                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ImpactPoint                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Normal                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ImpactNormal                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*           PhysMat                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      HitActor                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         HitComponent                                                     (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        HitBoneName                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              HitItem                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              FaceIndex                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TraceStart                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TraceEnd                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::BreakHitResult(struct FHitResult& Hit, bool* bBlockingHit, bool* bInitialOverlap, float* Time, float* Distance, struct FVector* Location, struct FVector* ImpactPoint, struct FVector* Normal, struct FVector* ImpactNormal, class UPhysicalMaterial** PhysMat, class AActor** HitActor, class UPrimitiveComponent** HitComponent, class FName* HitBoneName, int32* HitItem, int32* FaceIndex, struct FVector* TraceStart, struct FVector* TraceEnd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "BreakHitResult");

	Params::UGameplayStatics_BreakHitResult_Params Parms{};

	Parms.Hit = Hit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bBlockingHit != nullptr)
		*bBlockingHit = Parms.bBlockingHit;

	if (bInitialOverlap != nullptr)
		*bInitialOverlap = Parms.bInitialOverlap;

	if (Time != nullptr)
		*Time = Parms.Time;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (ImpactPoint != nullptr)
		*ImpactPoint = std::move(Parms.ImpactPoint);

	if (Normal != nullptr)
		*Normal = std::move(Parms.Normal);

	if (ImpactNormal != nullptr)
		*ImpactNormal = std::move(Parms.ImpactNormal);

	if (PhysMat != nullptr)
		*PhysMat = Parms.PhysMat;

	if (HitActor != nullptr)
		*HitActor = Parms.HitActor;

	if (HitComponent != nullptr)
		*HitComponent = Parms.HitComponent;

	if (HitBoneName != nullptr)
		*HitBoneName = Parms.HitBoneName;

	if (HitItem != nullptr)
		*HitItem = Parms.HitItem;

	if (FaceIndex != nullptr)
		*FaceIndex = Parms.FaceIndex;

	if (TraceStart != nullptr)
		*TraceStart = std::move(Parms.TraceStart);

	if (TraceEnd != nullptr)
		*TraceEnd = std::move(Parms.TraceEnd);

}


// Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TossVelocity                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     StartLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     EndLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LaunchSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OverrideGravityZ                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESuggestProjVelocityTraceOptionTraceOption                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CollisionRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFavorHighArc                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDrawDebug                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::BlueprintSuggestProjectileVelocity(class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, enum class ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "BlueprintSuggestProjectileVelocity");

	Params::UGameplayStatics_BlueprintSuggestProjectileVelocity_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartLocation = StartLocation;
	Parms.EndLocation = EndLocation;
	Parms.LaunchSpeed = LaunchSpeed;
	Parms.OverrideGravityZ = OverrideGravityZ;
	Parms.TraceOption = TraceOption;
	Parms.CollisionRadius = CollisionRadius;
	Parms.bFavorHighArc = bFavorHighArc;
	Parms.bDrawDebug = bDrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (TossVelocity != nullptr)
		*TossVelocity = std::move(Parms.TossVelocity);

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByTraceChannel
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FVector>             OutPathPositions                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                     OutLastTraceDestination                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     StartPos                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LaunchVelocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTracePath                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ProjectileRadius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECollisionChannel       TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawDebugTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SimFrequency                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxSimTime                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OverrideGravityZ                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::Blueprint_PredictProjectilePath_ByTraceChannel(class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, enum class ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "Blueprint_PredictProjectilePath_ByTraceChannel");

	Params::UGameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPos = StartPos;
	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bTracePath = bTracePath;
	Parms.ProjectileRadius = ProjectileRadius;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.DrawDebugTime = DrawDebugTime;
	Parms.SimFrequency = SimFrequency;
	Parms.MaxSimTime = MaxSimTime;
	Parms.OverrideGravityZ = OverrideGravityZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (OutPathPositions != nullptr)
		*OutPathPositions = std::move(Parms.OutPathPositions);

	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = std::move(Parms.OutLastTraceDestination);

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByObjectType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FVector>             OutPathPositions                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                     OutLastTraceDestination                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     StartPos                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LaunchVelocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTracePath                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ProjectileRadius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawDebugTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SimFrequency                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxSimTime                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OverrideGravityZ                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::Blueprint_PredictProjectilePath_ByObjectType(class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "Blueprint_PredictProjectilePath_ByObjectType");

	Params::UGameplayStatics_Blueprint_PredictProjectilePath_ByObjectType_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPos = StartPos;
	Parms.LaunchVelocity = LaunchVelocity;
	Parms.bTracePath = bTracePath;
	Parms.ProjectileRadius = ProjectileRadius;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.DrawDebugTime = DrawDebugTime;
	Parms.SimFrequency = SimFrequency;
	Parms.MaxSimTime = MaxSimTime;
	Parms.OverrideGravityZ = OverrideGravityZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (OutPathPositions != nullptr)
		*OutPathPositions = std::move(Parms.OutPathPositions);

	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = std::move(Parms.OutLastTraceDestination);

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_Advanced
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPredictProjectilePathParamsPredictParams                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPredictProjectilePathResultPredictResult                                                    (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::Blueprint_PredictProjectilePath_Advanced(class UObject* WorldContextObject, struct FPredictProjectilePathParams& PredictParams, struct FPredictProjectilePathResult* PredictResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "Blueprint_PredictProjectilePath_Advanced");

	Params::UGameplayStatics_Blueprint_PredictProjectilePath_Advanced_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PredictParams = PredictParams;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (PredictResult != nullptr)
		*PredictResult = std::move(Parms.PredictResult);

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.BeginSpawningActorFromClass
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>          ActorClass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  SpawnTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bNoCollisionFail                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Owner                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::BeginSpawningActorFromClass(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, struct FTransform& SpawnTransform, bool bNoCollisionFail, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "BeginSpawningActorFromClass");

	Params::UGameplayStatics_BeginSpawningActorFromClass_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = SpawnTransform;
	Parms.bNoCollisionFail = bNoCollisionFail;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprint*                  Blueprint                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  SpawnTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bNoCollisionFail                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::BeginSpawningActorFromBlueprint(class UObject* WorldContextObject, class UBlueprint* Blueprint, struct FTransform& SpawnTransform, bool bNoCollisionFail)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "BeginSpawningActorFromBlueprint");

	Params::UGameplayStatics_BeginSpawningActorFromBlueprint_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Blueprint = Blueprint;
	Parms.SpawnTransform = SpawnTransform;
	Parms.bNoCollisionFail = bNoCollisionFail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>          ActorClass                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  SpawnTransform                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// enum class ESpawnActorCollisionHandlingMethodCollisionHandlingOverride                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      Owner                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::BeginDeferredActorSpawnFromClass(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, struct FTransform& SpawnTransform, enum class ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "BeginDeferredActorSpawnFromClass");

	Params::UGameplayStatics_BeginDeferredActorSpawnFromClass_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = SpawnTransform;
	Parms.CollisionHandlingOverride = CollisionHandlingOverride;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.AreSubtitlesEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::AreSubtitlesEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "AreSubtitlesEnabled");

	Params::UGameplayStatics_AreSubtitlesEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.AreAnyListenersWithinRange
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaximumRange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::AreAnyListenersWithinRange(class UObject* WorldContextObject, const struct FVector& Location, float MaximumRange)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "AreAnyListenersWithinRange");

	Params::UGameplayStatics_AreAnyListenersWithinRange_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = Location;
	Parms.MaximumRange = MaximumRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BaseDamage                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MinimumDamage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DamageInnerRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DamageOuterRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DamageFalloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>     DamageTypeClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              IgnoreActors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 InstigatedByController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECollisionChannel       DamagePreventionChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::ApplyRadialDamageWithFalloff(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, enum class ECollisionChannel DamagePreventionChannel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ApplyRadialDamageWithFalloff");

	Params::UGameplayStatics_ApplyRadialDamageWithFalloff_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.MinimumDamage = MinimumDamage;
	Parms.Origin = Origin;
	Parms.DamageInnerRadius = DamageInnerRadius;
	Parms.DamageOuterRadius = DamageOuterRadius;
	Parms.DamageFalloff = DamageFalloff;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = IgnoreActors;
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.DamagePreventionChannel = DamagePreventionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.ApplyRadialDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BaseDamage                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DamageRadius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>     DamageTypeClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              IgnoreActors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 InstigatedByController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDoFullDamage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ECollisionChannel       DamagePreventionChannel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::ApplyRadialDamage(class UObject* WorldContextObject, float BaseDamage, struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, enum class ECollisionChannel DamagePreventionChannel)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ApplyRadialDamage");

	Params::UGameplayStatics_ApplyRadialDamage_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.Origin = Origin;
	Parms.DamageRadius = DamageRadius;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = IgnoreActors;
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.bDoFullDamage = bDoFullDamage;
	Parms.DamagePreventionChannel = DamagePreventionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.ApplyPointDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                      DamagedActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BaseDamage                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HitFromDirection                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  HitInfo                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                 EventInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>     DamageTypeClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, struct FVector& HitFromDirection, struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ApplyPointDamage");

	Params::UGameplayStatics_ApplyPointDamage_Params Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.BaseDamage = BaseDamage;
	Parms.HitFromDirection = HitFromDirection;
	Parms.HitInfo = HitInfo;
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.ApplyDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                      DamagedActor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BaseDamage                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                 EventInstigator                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      DamageCauser                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>     DamageTypeClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ApplyDamage");

	Params::UGameplayStatics_ApplyDamage_Params Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.BaseDamage = BaseDamage;
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.GameplayStatics.ActivateReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReverbEffect*               ReverbEffect                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        TagName                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Priority                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Volume                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              FadeTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::ActivateReverbEffect(class UObject* WorldContextObject, class UReverbEffect* ReverbEffect, class FName TagName, float Priority, float Volume, float FadeTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("GameplayStatics", "ActivateReverbEffect");

	Params::UGameplayStatics_ActivateReverbEffect_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ReverbEffect = ReverbEffect;
	Parms.TagName = TagName;
	Parms.Priority = Priority;
	Parms.Volume = Volume;
	Parms.FadeTime = FadeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SpotLight
// (Actor)

class UClass* ASpotLight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpotLight");

	return Clss;
}


// SpotLight Engine.Default__SpotLight
// (Public, ClassDefaultObject, ArchetypeObject)

class ASpotLight* ASpotLight::GetDefaultObj()
{
	static class ASpotLight* Default = nullptr;

	if (!Default)
		Default = static_cast<ASpotLight*>(ASpotLight::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SpotLight.SetOuterConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewOuterConeAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpotLight::SetOuterConeAngle(float NewOuterConeAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpotLight", "SetOuterConeAngle");

	Params::ASpotLight_SetOuterConeAngle_Params Parms{};

	Parms.NewOuterConeAngle = NewOuterConeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SpotLight.SetInnerConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewInnerConeAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpotLight::SetInnerConeAngle(float NewInnerConeAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpotLight", "SetInnerConeAngle");

	Params::ASpotLight_SetInnerConeAngle_Params Parms{};

	Parms.NewInnerConeAngle = NewInnerConeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.GeneratedMeshAreaLight
// (Actor)

class UClass* AGeneratedMeshAreaLight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("GeneratedMeshAreaLight");

	return Clss;
}


// GeneratedMeshAreaLight Engine.Default__GeneratedMeshAreaLight
// (Public, ClassDefaultObject, ArchetypeObject)

class AGeneratedMeshAreaLight* AGeneratedMeshAreaLight::GetDefaultObj()
{
	static class AGeneratedMeshAreaLight* Default = nullptr;

	if (!Default)
		Default = static_cast<AGeneratedMeshAreaLight*>(AGeneratedMeshAreaLight::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.HapticFeedbackEffect_Base
// (None)

class UClass* UHapticFeedbackEffect_Base::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HapticFeedbackEffect_Base");

	return Clss;
}


// HapticFeedbackEffect_Base Engine.Default__HapticFeedbackEffect_Base
// (Public, ClassDefaultObject, ArchetypeObject)

class UHapticFeedbackEffect_Base* UHapticFeedbackEffect_Base::GetDefaultObj()
{
	static class UHapticFeedbackEffect_Base* Default = nullptr;

	if (!Default)
		Default = static_cast<UHapticFeedbackEffect_Base*>(UHapticFeedbackEffect_Base::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.HapticFeedbackEffect_Buffer
// (None)

class UClass* UHapticFeedbackEffect_Buffer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HapticFeedbackEffect_Buffer");

	return Clss;
}


// HapticFeedbackEffect_Buffer Engine.Default__HapticFeedbackEffect_Buffer
// (Public, ClassDefaultObject, ArchetypeObject)

class UHapticFeedbackEffect_Buffer* UHapticFeedbackEffect_Buffer::GetDefaultObj()
{
	static class UHapticFeedbackEffect_Buffer* Default = nullptr;

	if (!Default)
		Default = static_cast<UHapticFeedbackEffect_Buffer*>(UHapticFeedbackEffect_Buffer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.HapticFeedbackEffect_Curve
// (None)

class UClass* UHapticFeedbackEffect_Curve::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HapticFeedbackEffect_Curve");

	return Clss;
}


// HapticFeedbackEffect_Curve Engine.Default__HapticFeedbackEffect_Curve
// (Public, ClassDefaultObject, ArchetypeObject)

class UHapticFeedbackEffect_Curve* UHapticFeedbackEffect_Curve::GetDefaultObj()
{
	static class UHapticFeedbackEffect_Curve* Default = nullptr;

	if (!Default)
		Default = static_cast<UHapticFeedbackEffect_Curve*>(UHapticFeedbackEffect_Curve::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.HapticFeedbackEffect_SoundWave
// (None)

class UClass* UHapticFeedbackEffect_SoundWave::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HapticFeedbackEffect_SoundWave");

	return Clss;
}


// HapticFeedbackEffect_SoundWave Engine.Default__HapticFeedbackEffect_SoundWave
// (Public, ClassDefaultObject, ArchetypeObject)

class UHapticFeedbackEffect_SoundWave* UHapticFeedbackEffect_SoundWave::GetDefaultObj()
{
	static class UHapticFeedbackEffect_SoundWave* Default = nullptr;

	if (!Default)
		Default = static_cast<UHapticFeedbackEffect_SoundWave*>(UHapticFeedbackEffect_SoundWave::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.HealthSnapshotBlueprintLibrary
// (None)

class UClass* UHealthSnapshotBlueprintLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HealthSnapshotBlueprintLibrary");

	return Clss;
}


// HealthSnapshotBlueprintLibrary Engine.Default__HealthSnapshotBlueprintLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UHealthSnapshotBlueprintLibrary* UHealthSnapshotBlueprintLibrary::GetDefaultObj()
{
	static class UHealthSnapshotBlueprintLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UHealthSnapshotBlueprintLibrary*>(UHealthSnapshotBlueprintLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.HealthSnapshotBlueprintLibrary.StopPerformanceSnapshots
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:

void UHealthSnapshotBlueprintLibrary::StopPerformanceSnapshots()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthSnapshotBlueprintLibrary", "StopPerformanceSnapshots");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HealthSnapshotBlueprintLibrary.StartPerformanceSnapshots
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:

void UHealthSnapshotBlueprintLibrary::StartPerformanceSnapshots()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthSnapshotBlueprintLibrary", "StartPerformanceSnapshots");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.HealthSnapshotBlueprintLibrary.LogPerformanceSnapshot
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      SnapshotTitle                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bResetStats                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthSnapshotBlueprintLibrary::LogPerformanceSnapshot(const class FString& SnapshotTitle, bool bResetStats)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("HealthSnapshotBlueprintLibrary", "LogPerformanceSnapshot");

	Params::UHealthSnapshotBlueprintLibrary_LogPerformanceSnapshot_Params Parms{};

	Parms.SnapshotTitle = SnapshotTitle;
	Parms.bResetStats = bResetStats;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.HLODProxy
// (None)

class UClass* UHLODProxy::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HLODProxy");

	return Clss;
}


// HLODProxy Engine.Default__HLODProxy
// (Public, ClassDefaultObject, ArchetypeObject)

class UHLODProxy* UHLODProxy::GetDefaultObj()
{
	static class UHLODProxy* Default = nullptr;

	if (!Default)
		Default = static_cast<UHLODProxy*>(UHLODProxy::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.AmbisonicsSubmixSettingsBase
// (None)

class UClass* UAmbisonicsSubmixSettingsBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("AmbisonicsSubmixSettingsBase");

	return Clss;
}


// AmbisonicsSubmixSettingsBase Engine.Default__AmbisonicsSubmixSettingsBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UAmbisonicsSubmixSettingsBase* UAmbisonicsSubmixSettingsBase::GetDefaultObj()
{
	static class UAmbisonicsSubmixSettingsBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UAmbisonicsSubmixSettingsBase*>(UAmbisonicsSubmixSettingsBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SpatializationPluginSourceSettingsBase
// (None)

class UClass* USpatializationPluginSourceSettingsBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpatializationPluginSourceSettingsBase");

	return Clss;
}


// SpatializationPluginSourceSettingsBase Engine.Default__SpatializationPluginSourceSettingsBase
// (Public, ClassDefaultObject, ArchetypeObject)

class USpatializationPluginSourceSettingsBase* USpatializationPluginSourceSettingsBase::GetDefaultObj()
{
	static class USpatializationPluginSourceSettingsBase* Default = nullptr;

	if (!Default)
		Default = static_cast<USpatializationPluginSourceSettingsBase*>(USpatializationPluginSourceSettingsBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.OcclusionPluginSourceSettingsBase
// (None)

class UClass* UOcclusionPluginSourceSettingsBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("OcclusionPluginSourceSettingsBase");

	return Clss;
}


// OcclusionPluginSourceSettingsBase Engine.Default__OcclusionPluginSourceSettingsBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UOcclusionPluginSourceSettingsBase* UOcclusionPluginSourceSettingsBase::GetDefaultObj()
{
	static class UOcclusionPluginSourceSettingsBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UOcclusionPluginSourceSettingsBase*>(UOcclusionPluginSourceSettingsBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ReverbPluginSourceSettingsBase
// (None)

class UClass* UReverbPluginSourceSettingsBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReverbPluginSourceSettingsBase");

	return Clss;
}


// ReverbPluginSourceSettingsBase Engine.Default__ReverbPluginSourceSettingsBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UReverbPluginSourceSettingsBase* UReverbPluginSourceSettingsBase::GetDefaultObj()
{
	static class UReverbPluginSourceSettingsBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UReverbPluginSourceSettingsBase*>(UReverbPluginSourceSettingsBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ImportanceSamplingLibrary
// (None)

class UClass* UImportanceSamplingLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ImportanceSamplingLibrary");

	return Clss;
}


// ImportanceSamplingLibrary Engine.Default__ImportanceSamplingLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UImportanceSamplingLibrary* UImportanceSamplingLibrary::GetDefaultObj()
{
	static class UImportanceSamplingLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UImportanceSamplingLibrary*>(UImportanceSamplingLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ImportanceSamplingLibrary.RandomSobolFloat
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Dimension                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Seed                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UImportanceSamplingLibrary::RandomSobolFloat(int32 Index, int32 Dimension, float Seed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "RandomSobolFloat");

	Params::UImportanceSamplingLibrary_RandomSobolFloat_Params Parms{};

	Parms.Index = Index;
	Parms.Dimension = Dimension;
	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ImportanceSamplingLibrary.RandomSobolCell3D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumCells                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Cell                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Seed                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UImportanceSamplingLibrary::RandomSobolCell3D(int32 Index, int32 NumCells, const struct FVector& Cell, const struct FVector& Seed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "RandomSobolCell3D");

	Params::UImportanceSamplingLibrary_RandomSobolCell3D_Params Parms{};

	Parms.Index = Index;
	Parms.NumCells = NumCells;
	Parms.Cell = Cell;
	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ImportanceSamplingLibrary.RandomSobolCell2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumCells                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Cell                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Seed                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UImportanceSamplingLibrary::RandomSobolCell2D(int32 Index, int32 NumCells, const struct FVector2D& Cell, const struct FVector2D& Seed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "RandomSobolCell2D");

	Params::UImportanceSamplingLibrary_RandomSobolCell2D_Params Parms{};

	Parms.Index = Index;
	Parms.NumCells = NumCells;
	Parms.Cell = Cell;
	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ImportanceSamplingLibrary.NextSobolFloat
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Dimension                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              PreviousValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UImportanceSamplingLibrary::NextSobolFloat(int32 Index, int32 Dimension, float PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "NextSobolFloat");

	Params::UImportanceSamplingLibrary_NextSobolFloat_Params Parms{};

	Parms.Index = Index;
	Parms.Dimension = Dimension;
	Parms.PreviousValue = PreviousValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ImportanceSamplingLibrary.NextSobolCell3D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumCells                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PreviousValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UImportanceSamplingLibrary::NextSobolCell3D(int32 Index, int32 NumCells, const struct FVector& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "NextSobolCell3D");

	Params::UImportanceSamplingLibrary_NextSobolCell3D_Params Parms{};

	Parms.Index = Index;
	Parms.NumCells = NumCells;
	Parms.PreviousValue = PreviousValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ImportanceSamplingLibrary.NextSobolCell2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumCells                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   PreviousValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UImportanceSamplingLibrary::NextSobolCell2D(int32 Index, int32 NumCells, const struct FVector2D& PreviousValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "NextSobolCell2D");

	Params::UImportanceSamplingLibrary_NextSobolCell2D_Params Parms{};

	Parms.Index = Index;
	Parms.NumCells = NumCells;
	Parms.PreviousValue = PreviousValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ImportanceSamplingLibrary.MakeImportanceTexture
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTexture2D*                  Texture                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EImportanceWeight       WeightingFunc                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImportanceTexture          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FImportanceTexture UImportanceSamplingLibrary::MakeImportanceTexture(class UTexture2D* Texture, enum class EImportanceWeight WeightingFunc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "MakeImportanceTexture");

	Params::UImportanceSamplingLibrary_MakeImportanceTexture_Params Parms{};

	Parms.Texture = Texture;
	Parms.WeightingFunc = WeightingFunc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ImportanceSamplingLibrary.ImportanceSample
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FImportanceTexture          Texture                                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                   Rand                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Samples                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Intensity                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   SamplePosition                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                SampleColor                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SampleIntensity                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SampleSize                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImportanceSamplingLibrary::ImportanceSample(struct FImportanceTexture& Texture, struct FVector2D& Rand, int32 Samples, float Intensity, struct FVector2D* SamplePosition, struct FLinearColor* SampleColor, float* SampleIntensity, float* SampleSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "ImportanceSample");

	Params::UImportanceSamplingLibrary_ImportanceSample_Params Parms{};

	Parms.Texture = Texture;
	Parms.Rand = Rand;
	Parms.Samples = Samples;
	Parms.Intensity = Intensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (SamplePosition != nullptr)
		*SamplePosition = std::move(Parms.SamplePosition);

	if (SampleColor != nullptr)
		*SampleColor = std::move(Parms.SampleColor);

	if (SampleIntensity != nullptr)
		*SampleIntensity = Parms.SampleIntensity;

	if (SampleSize != nullptr)
		*SampleSize = Parms.SampleSize;

}


// Function Engine.ImportanceSamplingLibrary.BreakImportanceTexture
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FImportanceTexture          ImportanceTexture                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                  Texture                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EImportanceWeight       WeightingFunc                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImportanceSamplingLibrary::BreakImportanceTexture(struct FImportanceTexture& ImportanceTexture, class UTexture2D** Texture, enum class EImportanceWeight* WeightingFunc)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ImportanceSamplingLibrary", "BreakImportanceTexture");

	Params::UImportanceSamplingLibrary_BreakImportanceTexture_Params Parms{};

	Parms.ImportanceTexture = ImportanceTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Texture != nullptr)
		*Texture = Parms.Texture;

	if (WeightingFunc != nullptr)
		*WeightingFunc = Parms.WeightingFunc;

}


// Class Engine.ImportantToggleSettingInterface
// (None)

class UClass* IImportantToggleSettingInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ImportantToggleSettingInterface");

	return Clss;
}


// ImportantToggleSettingInterface Engine.Default__ImportantToggleSettingInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IImportantToggleSettingInterface* IImportantToggleSettingInterface::GetDefaultObj()
{
	static class IImportantToggleSettingInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IImportantToggleSettingInterface*>(IImportantToggleSettingInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InGameAdManager
// (None)

class UClass* UInGameAdManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InGameAdManager");

	return Clss;
}


// InGameAdManager Engine.Default__InGameAdManager
// (Public, ClassDefaultObject, ArchetypeObject)

class UInGameAdManager* UInGameAdManager::GetDefaultObj()
{
	static class UInGameAdManager* Default = nullptr;

	if (!Default)
		Default = static_cast<UInGameAdManager*>(UInGameAdManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InheritableComponentHandler
// (None)

class UClass* UInheritableComponentHandler::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InheritableComponentHandler");

	return Clss;
}


// InheritableComponentHandler Engine.Default__InheritableComponentHandler
// (Public, ClassDefaultObject, ArchetypeObject)

class UInheritableComponentHandler* UInheritableComponentHandler::GetDefaultObj()
{
	static class UInheritableComponentHandler* Default = nullptr;

	if (!Default)
		Default = static_cast<UInheritableComponentHandler*>(UInheritableComponentHandler::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InputDelegateBinding
// (None)

class UClass* UInputDelegateBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputDelegateBinding");

	return Clss;
}


// InputDelegateBinding Engine.Default__InputDelegateBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputDelegateBinding* UInputDelegateBinding::GetDefaultObj()
{
	static class UInputDelegateBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputDelegateBinding*>(UInputDelegateBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InputActionDelegateBinding
// (None)

class UClass* UInputActionDelegateBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputActionDelegateBinding");

	return Clss;
}


// InputActionDelegateBinding Engine.Default__InputActionDelegateBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputActionDelegateBinding* UInputActionDelegateBinding::GetDefaultObj()
{
	static class UInputActionDelegateBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputActionDelegateBinding*>(UInputActionDelegateBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InputAxisDelegateBinding
// (None)

class UClass* UInputAxisDelegateBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputAxisDelegateBinding");

	return Clss;
}


// InputAxisDelegateBinding Engine.Default__InputAxisDelegateBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputAxisDelegateBinding* UInputAxisDelegateBinding::GetDefaultObj()
{
	static class UInputAxisDelegateBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputAxisDelegateBinding*>(UInputAxisDelegateBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InputAxisKeyDelegateBinding
// (None)

class UClass* UInputAxisKeyDelegateBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputAxisKeyDelegateBinding");

	return Clss;
}


// InputAxisKeyDelegateBinding Engine.Default__InputAxisKeyDelegateBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputAxisKeyDelegateBinding* UInputAxisKeyDelegateBinding::GetDefaultObj()
{
	static class UInputAxisKeyDelegateBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputAxisKeyDelegateBinding*>(UInputAxisKeyDelegateBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InputComponent
// (None)

class UClass* UInputComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputComponent");

	return Clss;
}


// InputComponent Engine.Default__InputComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputComponent* UInputComponent::GetDefaultObj()
{
	static class UInputComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputComponent*>(UInputComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.InputComponent.WasControllerKeyJustReleased
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputComponent::WasControllerKeyJustReleased(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "WasControllerKeyJustReleased");

	Params::UInputComponent_WasControllerKeyJustReleased_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InputComponent.WasControllerKeyJustPressed
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputComponent::WasControllerKeyJustPressed(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "WasControllerKeyJustPressed");

	Params::UInputComponent_WasControllerKeyJustPressed_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InputComponent.IsControllerKeyDown
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputComponent::IsControllerKeyDown(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "IsControllerKeyDown");

	Params::UInputComponent_IsControllerKeyDown_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InputComponent.GetTouchState
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              FingerIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LocationX                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LocationY                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIsCurrentlyPressed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputComponent::GetTouchState(int32 FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "GetTouchState");

	Params::UInputComponent_GetTouchState_Params Parms{};

	Parms.FingerIndex = FingerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (LocationX != nullptr)
		*LocationX = Parms.LocationX;

	if (LocationY != nullptr)
		*LocationY = Parms.LocationY;

	if (bIsCurrentlyPressed != nullptr)
		*bIsCurrentlyPressed = Parms.bIsCurrentlyPressed;

}


// Function Engine.InputComponent.GetControllerVectorKeyState
// (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInputComponent::GetControllerVectorKeyState(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "GetControllerVectorKeyState");

	Params::UInputComponent_GetControllerVectorKeyState_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InputComponent.GetControllerMouseDelta
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              DeltaX                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaY                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputComponent::GetControllerMouseDelta(float* DeltaX, float* DeltaY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "GetControllerMouseDelta");

	Params::UInputComponent_GetControllerMouseDelta_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (DeltaX != nullptr)
		*DeltaX = Parms.DeltaX;

	if (DeltaY != nullptr)
		*DeltaY = Parms.DeltaY;

}


// Function Engine.InputComponent.GetControllerKeyTimeDown
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInputComponent::GetControllerKeyTimeDown(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "GetControllerKeyTimeDown");

	Params::UInputComponent_GetControllerKeyTimeDown_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InputComponent.GetControllerAnalogStickState
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class EControllerAnalogStick  WhichStick                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StickX                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              StickY                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputComponent::GetControllerAnalogStickState(enum class EControllerAnalogStick WhichStick, float* StickX, float* StickY)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "GetControllerAnalogStickState");

	Params::UInputComponent_GetControllerAnalogStickState_Params Parms{};

	Parms.WhichStick = WhichStick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (StickX != nullptr)
		*StickX = Parms.StickX;

	if (StickY != nullptr)
		*StickY = Parms.StickY;

}


// Function Engine.InputComponent.GetControllerAnalogKeyState
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                        Key                                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInputComponent::GetControllerAnalogKeyState(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputComponent", "GetControllerAnalogKeyState");

	Params::UInputComponent_GetControllerAnalogKeyState_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.InputKeyDelegateBinding
// (None)

class UClass* UInputKeyDelegateBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputKeyDelegateBinding");

	return Clss;
}


// InputKeyDelegateBinding Engine.Default__InputKeyDelegateBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputKeyDelegateBinding* UInputKeyDelegateBinding::GetDefaultObj()
{
	static class UInputKeyDelegateBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputKeyDelegateBinding*>(UInputKeyDelegateBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InputSettings
// (None)

class UClass* UInputSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputSettings");

	return Clss;
}


// InputSettings Engine.Default__InputSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputSettings* UInputSettings::GetDefaultObj()
{
	static class UInputSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputSettings*>(UInputSettings::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.InputSettings.SaveKeyMappings
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInputSettings::SaveKeyMappings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "SaveKeyMappings");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.InputSettings.RemoveAxisMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputAxisKeyMapping        KeyMapping                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bForceRebuildKeymaps                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettings::RemoveAxisMapping(struct FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "RemoveAxisMapping");

	Params::UInputSettings_RemoveAxisMapping_Params Parms{};

	Parms.KeyMapping = KeyMapping;
	Parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.InputSettings.RemoveActionMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputActionKeyMapping      KeyMapping                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bForceRebuildKeymaps                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettings::RemoveActionMapping(struct FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "RemoveActionMapping");

	Params::UInputSettings_RemoveActionMapping_Params Parms{};

	Parms.KeyMapping = KeyMapping;
	Parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.InputSettings.GetInputSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UInputSettings*              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInputSettings* UInputSettings::GetInputSettings()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "GetInputSettings");

	Params::UInputSettings_GetInputSettings_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.InputSettings.GetAxisNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                AxisNames                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInputSettings::GetAxisNames(TArray<class FName>* AxisNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "GetAxisNames");

	Params::UInputSettings_GetAxisNames_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (AxisNames != nullptr)
		*AxisNames = std::move(Parms.AxisNames);

}


// Function Engine.InputSettings.GetAxisMappingByName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InAxisName                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputAxisKeyMapping>OutMappings                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInputSettings::GetAxisMappingByName(class FName InAxisName, TArray<struct FInputAxisKeyMapping>* OutMappings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "GetAxisMappingByName");

	Params::UInputSettings_GetAxisMappingByName_Params Parms{};

	Parms.InAxisName = InAxisName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutMappings != nullptr)
		*OutMappings = std::move(Parms.OutMappings);

}


// Function Engine.InputSettings.GetActionNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                ActionNames                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInputSettings::GetActionNames(TArray<class FName>* ActionNames)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "GetActionNames");

	Params::UInputSettings_GetActionNames_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (ActionNames != nullptr)
		*ActionNames = std::move(Parms.ActionNames);

}


// Function Engine.InputSettings.GetActionMappingByName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InActionName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputActionKeyMapping>OutMappings                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInputSettings::GetActionMappingByName(class FName InActionName, TArray<struct FInputActionKeyMapping>* OutMappings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "GetActionMappingByName");

	Params::UInputSettings_GetActionMappingByName_Params Parms{};

	Parms.InActionName = InActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutMappings != nullptr)
		*OutMappings = std::move(Parms.OutMappings);

}


// Function Engine.InputSettings.ForceRebuildKeymaps
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInputSettings::ForceRebuildKeymaps()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "ForceRebuildKeymaps");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.InputSettings.AddAxisMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputAxisKeyMapping        KeyMapping                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bForceRebuildKeymaps                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettings::AddAxisMapping(struct FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "AddAxisMapping");

	Params::UInputSettings_AddAxisMapping_Params Parms{};

	Parms.KeyMapping = KeyMapping;
	Parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.InputSettings.AddActionMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputActionKeyMapping      KeyMapping                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bForceRebuildKeymaps                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettings::AddActionMapping(struct FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InputSettings", "AddActionMapping");

	Params::UInputSettings_AddActionMapping_Params Parms{};

	Parms.KeyMapping = KeyMapping;
	Parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.InputTouchDelegateBinding
// (None)

class UClass* UInputTouchDelegateBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputTouchDelegateBinding");

	return Clss;
}


// InputTouchDelegateBinding Engine.Default__InputTouchDelegateBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputTouchDelegateBinding* UInputTouchDelegateBinding::GetDefaultObj()
{
	static class UInputTouchDelegateBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputTouchDelegateBinding*>(UInputTouchDelegateBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InputVectorAxisDelegateBinding
// (None)

class UClass* UInputVectorAxisDelegateBinding::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InputVectorAxisDelegateBinding");

	return Clss;
}


// InputVectorAxisDelegateBinding Engine.Default__InputVectorAxisDelegateBinding
// (Public, ClassDefaultObject, ArchetypeObject)

class UInputVectorAxisDelegateBinding* UInputVectorAxisDelegateBinding::GetDefaultObj()
{
	static class UInputVectorAxisDelegateBinding* Default = nullptr;

	if (!Default)
		Default = static_cast<UInputVectorAxisDelegateBinding*>(UInputVectorAxisDelegateBinding::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Interface_AssetUserData
// (None)

class UClass* IInterface_AssetUserData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Interface_AssetUserData");

	return Clss;
}


// Interface_AssetUserData Engine.Default__Interface_AssetUserData
// (Public, ClassDefaultObject, ArchetypeObject)

class IInterface_AssetUserData* IInterface_AssetUserData::GetDefaultObj()
{
	static class IInterface_AssetUserData* Default = nullptr;

	if (!Default)
		Default = static_cast<IInterface_AssetUserData*>(IInterface_AssetUserData::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Interface_CollisionDataProvider
// (None)

class UClass* IInterface_CollisionDataProvider::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Interface_CollisionDataProvider");

	return Clss;
}


// Interface_CollisionDataProvider Engine.Default__Interface_CollisionDataProvider
// (Public, ClassDefaultObject, ArchetypeObject)

class IInterface_CollisionDataProvider* IInterface_CollisionDataProvider::GetDefaultObj()
{
	static class IInterface_CollisionDataProvider* Default = nullptr;

	if (!Default)
		Default = static_cast<IInterface_CollisionDataProvider*>(IInterface_CollisionDataProvider::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Interface_PostProcessVolume
// (None)

class UClass* IInterface_PostProcessVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Interface_PostProcessVolume");

	return Clss;
}


// Interface_PostProcessVolume Engine.Default__Interface_PostProcessVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class IInterface_PostProcessVolume* IInterface_PostProcessVolume::GetDefaultObj()
{
	static class IInterface_PostProcessVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<IInterface_PostProcessVolume*>(IInterface_PostProcessVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Interface_PreviewMeshProvider
// (None)

class UClass* IInterface_PreviewMeshProvider::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Interface_PreviewMeshProvider");

	return Clss;
}


// Interface_PreviewMeshProvider Engine.Default__Interface_PreviewMeshProvider
// (Public, ClassDefaultObject, ArchetypeObject)

class IInterface_PreviewMeshProvider* IInterface_PreviewMeshProvider::GetDefaultObj()
{
	static class IInterface_PreviewMeshProvider* Default = nullptr;

	if (!Default)
		Default = static_cast<IInterface_PreviewMeshProvider*>(IInterface_PreviewMeshProvider::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpCurveEdSetup
// (None)

class UClass* UInterpCurveEdSetup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpCurveEdSetup");

	return Clss;
}


// InterpCurveEdSetup Engine.Default__InterpCurveEdSetup
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpCurveEdSetup* UInterpCurveEdSetup::GetDefaultObj()
{
	static class UInterpCurveEdSetup* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpCurveEdSetup*>(UInterpCurveEdSetup::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpData
// (None)

class UClass* UInterpData::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpData");

	return Clss;
}


// InterpData Engine.Default__InterpData
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpData* UInterpData::GetDefaultObj()
{
	static class UInterpData* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpData*>(UInterpData::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpFilter
// (None)

class UClass* UInterpFilter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpFilter");

	return Clss;
}


// InterpFilter Engine.Default__InterpFilter
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpFilter* UInterpFilter::GetDefaultObj()
{
	static class UInterpFilter* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpFilter*>(UInterpFilter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpFilter_Classes
// (None)

class UClass* UInterpFilter_Classes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpFilter_Classes");

	return Clss;
}


// InterpFilter_Classes Engine.Default__InterpFilter_Classes
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpFilter_Classes* UInterpFilter_Classes::GetDefaultObj()
{
	static class UInterpFilter_Classes* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpFilter_Classes*>(UInterpFilter_Classes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpFilter_Custom
// (None)

class UClass* UInterpFilter_Custom::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpFilter_Custom");

	return Clss;
}


// InterpFilter_Custom Engine.Default__InterpFilter_Custom
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpFilter_Custom* UInterpFilter_Custom::GetDefaultObj()
{
	static class UInterpFilter_Custom* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpFilter_Custom*>(UInterpFilter_Custom::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpGroup
// (None)

class UClass* UInterpGroup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpGroup");

	return Clss;
}


// InterpGroup Engine.Default__InterpGroup
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpGroup* UInterpGroup::GetDefaultObj()
{
	static class UInterpGroup* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpGroup*>(UInterpGroup::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpGroupCamera
// (None)

class UClass* UInterpGroupCamera::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpGroupCamera");

	return Clss;
}


// InterpGroupCamera Engine.Default__InterpGroupCamera
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpGroupCamera* UInterpGroupCamera::GetDefaultObj()
{
	static class UInterpGroupCamera* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpGroupCamera*>(UInterpGroupCamera::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpGroupDirector
// (None)

class UClass* UInterpGroupDirector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpGroupDirector");

	return Clss;
}


// InterpGroupDirector Engine.Default__InterpGroupDirector
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpGroupDirector* UInterpGroupDirector::GetDefaultObj()
{
	static class UInterpGroupDirector* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpGroupDirector*>(UInterpGroupDirector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpGroupInst
// (None)

class UClass* UInterpGroupInst::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpGroupInst");

	return Clss;
}


// InterpGroupInst Engine.Default__InterpGroupInst
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpGroupInst* UInterpGroupInst::GetDefaultObj()
{
	static class UInterpGroupInst* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpGroupInst*>(UInterpGroupInst::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpGroupInstCamera
// (None)

class UClass* UInterpGroupInstCamera::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpGroupInstCamera");

	return Clss;
}


// InterpGroupInstCamera Engine.Default__InterpGroupInstCamera
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpGroupInstCamera* UInterpGroupInstCamera::GetDefaultObj()
{
	static class UInterpGroupInstCamera* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpGroupInstCamera*>(UInterpGroupInstCamera::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpGroupInstDirector
// (None)

class UClass* UInterpGroupInstDirector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpGroupInstDirector");

	return Clss;
}


// InterpGroupInstDirector Engine.Default__InterpGroupInstDirector
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpGroupInstDirector* UInterpGroupInstDirector::GetDefaultObj()
{
	static class UInterpGroupInstDirector* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpGroupInstDirector*>(UInterpGroupInstDirector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpToMovementComponent
// (None)

class UClass* UInterpToMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpToMovementComponent");

	return Clss;
}


// InterpToMovementComponent Engine.Default__InterpToMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpToMovementComponent* UInterpToMovementComponent::GetDefaultObj()
{
	static class UInterpToMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpToMovementComponent*>(UInterpToMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.InterpToMovementComponent.StopSimulating
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                  HitResult                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::StopSimulating(struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpToMovementComponent", "StopSimulating");

	Params::UInterpToMovementComponent_StopSimulating_Params Parms{};

	Parms.HitResult = HitResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.InterpToMovementComponent.RestartMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InitialDirection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::RestartMovement(float InitialDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpToMovementComponent", "RestartMovement");

	Params::UInterpToMovementComponent_RestartMovement_Params Parms{};

	Parms.InitialDirection = InitialDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHitResult                  ImpactResult                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::OnInterpToWaitEndDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpToMovementComponent", "OnInterpToWaitEndDelegate__DelegateSignature");

	Params::UInterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature_Params Parms{};

	Parms.ImpactResult = ImpactResult;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHitResult                  ImpactResult                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::OnInterpToWaitBeginDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpToMovementComponent", "OnInterpToWaitBeginDelegate__DelegateSignature");

	Params::UInterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature_Params Parms{};

	Parms.ImpactResult = ImpactResult;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHitResult                  ImpactResult                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::OnInterpToStopDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpToMovementComponent", "OnInterpToStopDelegate__DelegateSignature");

	Params::UInterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature_Params Parms{};

	Parms.ImpactResult = ImpactResult;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHitResult                  ImpactResult                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::OnInterpToReverseDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpToMovementComponent", "OnInterpToReverseDelegate__DelegateSignature");

	Params::UInterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature_Params Parms{};

	Parms.ImpactResult = ImpactResult;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FHitResult                  ImpactResult                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::OnInterpToResetDelegate__DelegateSignature(struct FHitResult& ImpactResult, float Time)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpToMovementComponent", "OnInterpToResetDelegate__DelegateSignature");

	Params::UInterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature_Params Parms{};

	Parms.ImpactResult = ImpactResult;
	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.InterpToMovementComponent.FinaliseControlPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UInterpToMovementComponent::FinaliseControlPoints()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("InterpToMovementComponent", "FinaliseControlPoints");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.InterpTrack
// (None)

class UClass* UInterpTrack::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrack");

	return Clss;
}


// InterpTrack Engine.Default__InterpTrack
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrack* UInterpTrack::GetDefaultObj()
{
	static class UInterpTrack* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrack*>(UInterpTrack::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackFloatBase
// (None)

class UClass* UInterpTrackFloatBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackFloatBase");

	return Clss;
}


// InterpTrackFloatBase Engine.Default__InterpTrackFloatBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackFloatBase* UInterpTrackFloatBase::GetDefaultObj()
{
	static class UInterpTrackFloatBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackFloatBase*>(UInterpTrackFloatBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackAnimControl
// (None)

class UClass* UInterpTrackAnimControl::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackAnimControl");

	return Clss;
}


// InterpTrackAnimControl Engine.Default__InterpTrackAnimControl
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackAnimControl* UInterpTrackAnimControl::GetDefaultObj()
{
	static class UInterpTrackAnimControl* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackAnimControl*>(UInterpTrackAnimControl::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackVectorBase
// (None)

class UClass* UInterpTrackVectorBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackVectorBase");

	return Clss;
}


// InterpTrackVectorBase Engine.Default__InterpTrackVectorBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackVectorBase* UInterpTrackVectorBase::GetDefaultObj()
{
	static class UInterpTrackVectorBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackVectorBase*>(UInterpTrackVectorBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackAudioMaster
// (None)

class UClass* UInterpTrackAudioMaster::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackAudioMaster");

	return Clss;
}


// InterpTrackAudioMaster Engine.Default__InterpTrackAudioMaster
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackAudioMaster* UInterpTrackAudioMaster::GetDefaultObj()
{
	static class UInterpTrackAudioMaster* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackAudioMaster*>(UInterpTrackAudioMaster::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackBoolProp
// (None)

class UClass* UInterpTrackBoolProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackBoolProp");

	return Clss;
}


// InterpTrackBoolProp Engine.Default__InterpTrackBoolProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackBoolProp* UInterpTrackBoolProp::GetDefaultObj()
{
	static class UInterpTrackBoolProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackBoolProp*>(UInterpTrackBoolProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackColorProp
// (None)

class UClass* UInterpTrackColorProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackColorProp");

	return Clss;
}


// InterpTrackColorProp Engine.Default__InterpTrackColorProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackColorProp* UInterpTrackColorProp::GetDefaultObj()
{
	static class UInterpTrackColorProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackColorProp*>(UInterpTrackColorProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackColorScale
// (None)

class UClass* UInterpTrackColorScale::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackColorScale");

	return Clss;
}


// InterpTrackColorScale Engine.Default__InterpTrackColorScale
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackColorScale* UInterpTrackColorScale::GetDefaultObj()
{
	static class UInterpTrackColorScale* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackColorScale*>(UInterpTrackColorScale::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackDirector
// (None)

class UClass* UInterpTrackDirector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackDirector");

	return Clss;
}


// InterpTrackDirector Engine.Default__InterpTrackDirector
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackDirector* UInterpTrackDirector::GetDefaultObj()
{
	static class UInterpTrackDirector* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackDirector*>(UInterpTrackDirector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackEvent
// (None)

class UClass* UInterpTrackEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackEvent");

	return Clss;
}


// InterpTrackEvent Engine.Default__InterpTrackEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackEvent* UInterpTrackEvent::GetDefaultObj()
{
	static class UInterpTrackEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackEvent*>(UInterpTrackEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackFade
// (None)

class UClass* UInterpTrackFade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackFade");

	return Clss;
}


// InterpTrackFade Engine.Default__InterpTrackFade
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackFade* UInterpTrackFade::GetDefaultObj()
{
	static class UInterpTrackFade* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackFade*>(UInterpTrackFade::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackFloatAnimBPParam
// (None)

class UClass* UInterpTrackFloatAnimBPParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackFloatAnimBPParam");

	return Clss;
}


// InterpTrackFloatAnimBPParam Engine.Default__InterpTrackFloatAnimBPParam
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackFloatAnimBPParam* UInterpTrackFloatAnimBPParam::GetDefaultObj()
{
	static class UInterpTrackFloatAnimBPParam* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackFloatAnimBPParam*>(UInterpTrackFloatAnimBPParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackFloatMaterialParam
// (None)

class UClass* UInterpTrackFloatMaterialParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackFloatMaterialParam");

	return Clss;
}


// InterpTrackFloatMaterialParam Engine.Default__InterpTrackFloatMaterialParam
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackFloatMaterialParam* UInterpTrackFloatMaterialParam::GetDefaultObj()
{
	static class UInterpTrackFloatMaterialParam* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackFloatMaterialParam*>(UInterpTrackFloatMaterialParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackFloatParticleParam
// (None)

class UClass* UInterpTrackFloatParticleParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackFloatParticleParam");

	return Clss;
}


// InterpTrackFloatParticleParam Engine.Default__InterpTrackFloatParticleParam
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackFloatParticleParam* UInterpTrackFloatParticleParam::GetDefaultObj()
{
	static class UInterpTrackFloatParticleParam* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackFloatParticleParam*>(UInterpTrackFloatParticleParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackFloatProp
// (None)

class UClass* UInterpTrackFloatProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackFloatProp");

	return Clss;
}


// InterpTrackFloatProp Engine.Default__InterpTrackFloatProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackFloatProp* UInterpTrackFloatProp::GetDefaultObj()
{
	static class UInterpTrackFloatProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackFloatProp*>(UInterpTrackFloatProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInst
// (None)

class UClass* UInterpTrackInst::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInst");

	return Clss;
}


// InterpTrackInst Engine.Default__InterpTrackInst
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInst* UInterpTrackInst::GetDefaultObj()
{
	static class UInterpTrackInst* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInst*>(UInterpTrackInst::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstAnimControl
// (None)

class UClass* UInterpTrackInstAnimControl::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstAnimControl");

	return Clss;
}


// InterpTrackInstAnimControl Engine.Default__InterpTrackInstAnimControl
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstAnimControl* UInterpTrackInstAnimControl::GetDefaultObj()
{
	static class UInterpTrackInstAnimControl* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstAnimControl*>(UInterpTrackInstAnimControl::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstAudioMaster
// (None)

class UClass* UInterpTrackInstAudioMaster::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstAudioMaster");

	return Clss;
}


// InterpTrackInstAudioMaster Engine.Default__InterpTrackInstAudioMaster
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstAudioMaster* UInterpTrackInstAudioMaster::GetDefaultObj()
{
	static class UInterpTrackInstAudioMaster* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstAudioMaster*>(UInterpTrackInstAudioMaster::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstProperty
// (None)

class UClass* UInterpTrackInstProperty::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstProperty");

	return Clss;
}


// InterpTrackInstProperty Engine.Default__InterpTrackInstProperty
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstProperty* UInterpTrackInstProperty::GetDefaultObj()
{
	static class UInterpTrackInstProperty* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstProperty*>(UInterpTrackInstProperty::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstBoolProp
// (None)

class UClass* UInterpTrackInstBoolProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstBoolProp");

	return Clss;
}


// InterpTrackInstBoolProp Engine.Default__InterpTrackInstBoolProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstBoolProp* UInterpTrackInstBoolProp::GetDefaultObj()
{
	static class UInterpTrackInstBoolProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstBoolProp*>(UInterpTrackInstBoolProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstColorProp
// (None)

class UClass* UInterpTrackInstColorProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstColorProp");

	return Clss;
}


// InterpTrackInstColorProp Engine.Default__InterpTrackInstColorProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstColorProp* UInterpTrackInstColorProp::GetDefaultObj()
{
	static class UInterpTrackInstColorProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstColorProp*>(UInterpTrackInstColorProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstColorScale
// (None)

class UClass* UInterpTrackInstColorScale::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstColorScale");

	return Clss;
}


// InterpTrackInstColorScale Engine.Default__InterpTrackInstColorScale
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstColorScale* UInterpTrackInstColorScale::GetDefaultObj()
{
	static class UInterpTrackInstColorScale* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstColorScale*>(UInterpTrackInstColorScale::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstDirector
// (None)

class UClass* UInterpTrackInstDirector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstDirector");

	return Clss;
}


// InterpTrackInstDirector Engine.Default__InterpTrackInstDirector
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstDirector* UInterpTrackInstDirector::GetDefaultObj()
{
	static class UInterpTrackInstDirector* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstDirector*>(UInterpTrackInstDirector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstEvent
// (None)

class UClass* UInterpTrackInstEvent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstEvent");

	return Clss;
}


// InterpTrackInstEvent Engine.Default__InterpTrackInstEvent
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstEvent* UInterpTrackInstEvent::GetDefaultObj()
{
	static class UInterpTrackInstEvent* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstEvent*>(UInterpTrackInstEvent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstFade
// (None)

class UClass* UInterpTrackInstFade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstFade");

	return Clss;
}


// InterpTrackInstFade Engine.Default__InterpTrackInstFade
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstFade* UInterpTrackInstFade::GetDefaultObj()
{
	static class UInterpTrackInstFade* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstFade*>(UInterpTrackInstFade::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstFloatAnimBPParam
// (None)

class UClass* UInterpTrackInstFloatAnimBPParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstFloatAnimBPParam");

	return Clss;
}


// InterpTrackInstFloatAnimBPParam Engine.Default__InterpTrackInstFloatAnimBPParam
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstFloatAnimBPParam* UInterpTrackInstFloatAnimBPParam::GetDefaultObj()
{
	static class UInterpTrackInstFloatAnimBPParam* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstFloatAnimBPParam*>(UInterpTrackInstFloatAnimBPParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstFloatMaterialParam
// (None)

class UClass* UInterpTrackInstFloatMaterialParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstFloatMaterialParam");

	return Clss;
}


// InterpTrackInstFloatMaterialParam Engine.Default__InterpTrackInstFloatMaterialParam
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstFloatMaterialParam* UInterpTrackInstFloatMaterialParam::GetDefaultObj()
{
	static class UInterpTrackInstFloatMaterialParam* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstFloatMaterialParam*>(UInterpTrackInstFloatMaterialParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstFloatParticleParam
// (None)

class UClass* UInterpTrackInstFloatParticleParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstFloatParticleParam");

	return Clss;
}


// InterpTrackInstFloatParticleParam Engine.Default__InterpTrackInstFloatParticleParam
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstFloatParticleParam* UInterpTrackInstFloatParticleParam::GetDefaultObj()
{
	static class UInterpTrackInstFloatParticleParam* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstFloatParticleParam*>(UInterpTrackInstFloatParticleParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstFloatProp
// (None)

class UClass* UInterpTrackInstFloatProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstFloatProp");

	return Clss;
}


// InterpTrackInstFloatProp Engine.Default__InterpTrackInstFloatProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstFloatProp* UInterpTrackInstFloatProp::GetDefaultObj()
{
	static class UInterpTrackInstFloatProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstFloatProp*>(UInterpTrackInstFloatProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstLinearColorProp
// (None)

class UClass* UInterpTrackInstLinearColorProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstLinearColorProp");

	return Clss;
}


// InterpTrackInstLinearColorProp Engine.Default__InterpTrackInstLinearColorProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstLinearColorProp* UInterpTrackInstLinearColorProp::GetDefaultObj()
{
	static class UInterpTrackInstLinearColorProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstLinearColorProp*>(UInterpTrackInstLinearColorProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstMove
// (None)

class UClass* UInterpTrackInstMove::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstMove");

	return Clss;
}


// InterpTrackInstMove Engine.Default__InterpTrackInstMove
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstMove* UInterpTrackInstMove::GetDefaultObj()
{
	static class UInterpTrackInstMove* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstMove*>(UInterpTrackInstMove::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstParticleReplay
// (None)

class UClass* UInterpTrackInstParticleReplay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstParticleReplay");

	return Clss;
}


// InterpTrackInstParticleReplay Engine.Default__InterpTrackInstParticleReplay
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstParticleReplay* UInterpTrackInstParticleReplay::GetDefaultObj()
{
	static class UInterpTrackInstParticleReplay* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstParticleReplay*>(UInterpTrackInstParticleReplay::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstSlomo
// (None)

class UClass* UInterpTrackInstSlomo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstSlomo");

	return Clss;
}


// InterpTrackInstSlomo Engine.Default__InterpTrackInstSlomo
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstSlomo* UInterpTrackInstSlomo::GetDefaultObj()
{
	static class UInterpTrackInstSlomo* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstSlomo*>(UInterpTrackInstSlomo::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstSound
// (None)

class UClass* UInterpTrackInstSound::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstSound");

	return Clss;
}


// InterpTrackInstSound Engine.Default__InterpTrackInstSound
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstSound* UInterpTrackInstSound::GetDefaultObj()
{
	static class UInterpTrackInstSound* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstSound*>(UInterpTrackInstSound::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstToggle
// (None)

class UClass* UInterpTrackInstToggle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstToggle");

	return Clss;
}


// InterpTrackInstToggle Engine.Default__InterpTrackInstToggle
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstToggle* UInterpTrackInstToggle::GetDefaultObj()
{
	static class UInterpTrackInstToggle* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstToggle*>(UInterpTrackInstToggle::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstVectorMaterialParam
// (None)

class UClass* UInterpTrackInstVectorMaterialParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstVectorMaterialParam");

	return Clss;
}


// InterpTrackInstVectorMaterialParam Engine.Default__InterpTrackInstVectorMaterialParam
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstVectorMaterialParam* UInterpTrackInstVectorMaterialParam::GetDefaultObj()
{
	static class UInterpTrackInstVectorMaterialParam* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstVectorMaterialParam*>(UInterpTrackInstVectorMaterialParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstVectorProp
// (None)

class UClass* UInterpTrackInstVectorProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstVectorProp");

	return Clss;
}


// InterpTrackInstVectorProp Engine.Default__InterpTrackInstVectorProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstVectorProp* UInterpTrackInstVectorProp::GetDefaultObj()
{
	static class UInterpTrackInstVectorProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstVectorProp*>(UInterpTrackInstVectorProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackInstVisibility
// (None)

class UClass* UInterpTrackInstVisibility::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackInstVisibility");

	return Clss;
}


// InterpTrackInstVisibility Engine.Default__InterpTrackInstVisibility
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackInstVisibility* UInterpTrackInstVisibility::GetDefaultObj()
{
	static class UInterpTrackInstVisibility* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackInstVisibility*>(UInterpTrackInstVisibility::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackLinearColorBase
// (None)

class UClass* UInterpTrackLinearColorBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackLinearColorBase");

	return Clss;
}


// InterpTrackLinearColorBase Engine.Default__InterpTrackLinearColorBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackLinearColorBase* UInterpTrackLinearColorBase::GetDefaultObj()
{
	static class UInterpTrackLinearColorBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackLinearColorBase*>(UInterpTrackLinearColorBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackLinearColorProp
// (None)

class UClass* UInterpTrackLinearColorProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackLinearColorProp");

	return Clss;
}


// InterpTrackLinearColorProp Engine.Default__InterpTrackLinearColorProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackLinearColorProp* UInterpTrackLinearColorProp::GetDefaultObj()
{
	static class UInterpTrackLinearColorProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackLinearColorProp*>(UInterpTrackLinearColorProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackMove
// (None)

class UClass* UInterpTrackMove::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackMove");

	return Clss;
}


// InterpTrackMove Engine.Default__InterpTrackMove
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackMove* UInterpTrackMove::GetDefaultObj()
{
	static class UInterpTrackMove* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackMove*>(UInterpTrackMove::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackMoveAxis
// (None)

class UClass* UInterpTrackMoveAxis::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackMoveAxis");

	return Clss;
}


// InterpTrackMoveAxis Engine.Default__InterpTrackMoveAxis
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackMoveAxis* UInterpTrackMoveAxis::GetDefaultObj()
{
	static class UInterpTrackMoveAxis* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackMoveAxis*>(UInterpTrackMoveAxis::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackParticleReplay
// (None)

class UClass* UInterpTrackParticleReplay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackParticleReplay");

	return Clss;
}


// InterpTrackParticleReplay Engine.Default__InterpTrackParticleReplay
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackParticleReplay* UInterpTrackParticleReplay::GetDefaultObj()
{
	static class UInterpTrackParticleReplay* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackParticleReplay*>(UInterpTrackParticleReplay::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackSlomo
// (None)

class UClass* UInterpTrackSlomo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackSlomo");

	return Clss;
}


// InterpTrackSlomo Engine.Default__InterpTrackSlomo
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackSlomo* UInterpTrackSlomo::GetDefaultObj()
{
	static class UInterpTrackSlomo* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackSlomo*>(UInterpTrackSlomo::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackSound
// (None)

class UClass* UInterpTrackSound::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackSound");

	return Clss;
}


// InterpTrackSound Engine.Default__InterpTrackSound
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackSound* UInterpTrackSound::GetDefaultObj()
{
	static class UInterpTrackSound* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackSound*>(UInterpTrackSound::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackToggle
// (None)

class UClass* UInterpTrackToggle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackToggle");

	return Clss;
}


// InterpTrackToggle Engine.Default__InterpTrackToggle
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackToggle* UInterpTrackToggle::GetDefaultObj()
{
	static class UInterpTrackToggle* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackToggle*>(UInterpTrackToggle::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackVectorMaterialParam
// (None)

class UClass* UInterpTrackVectorMaterialParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackVectorMaterialParam");

	return Clss;
}


// InterpTrackVectorMaterialParam Engine.Default__InterpTrackVectorMaterialParam
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackVectorMaterialParam* UInterpTrackVectorMaterialParam::GetDefaultObj()
{
	static class UInterpTrackVectorMaterialParam* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackVectorMaterialParam*>(UInterpTrackVectorMaterialParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackVectorProp
// (None)

class UClass* UInterpTrackVectorProp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackVectorProp");

	return Clss;
}


// InterpTrackVectorProp Engine.Default__InterpTrackVectorProp
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackVectorProp* UInterpTrackVectorProp::GetDefaultObj()
{
	static class UInterpTrackVectorProp* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackVectorProp*>(UInterpTrackVectorProp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.InterpTrackVisibility
// (None)

class UClass* UInterpTrackVisibility::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("InterpTrackVisibility");

	return Clss;
}


// InterpTrackVisibility Engine.Default__InterpTrackVisibility
// (Public, ClassDefaultObject, ArchetypeObject)

class UInterpTrackVisibility* UInterpTrackVisibility::GetDefaultObj()
{
	static class UInterpTrackVisibility* Default = nullptr;

	if (!Default)
		Default = static_cast<UInterpTrackVisibility*>(UInterpTrackVisibility::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.IntSerialization
// (None)

class UClass* UIntSerialization::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("IntSerialization");

	return Clss;
}


// IntSerialization Engine.Default__IntSerialization
// (Public, ClassDefaultObject, ArchetypeObject)

class UIntSerialization* UIntSerialization::GetDefaultObj()
{
	static class UIntSerialization* Default = nullptr;

	if (!Default)
		Default = static_cast<UIntSerialization*>(UIntSerialization::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.KillZVolume
// (Actor)

class UClass* AKillZVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KillZVolume");

	return Clss;
}


// KillZVolume Engine.Default__KillZVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AKillZVolume* AKillZVolume::GetDefaultObj()
{
	static class AKillZVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AKillZVolume*>(AKillZVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.KismetArrayLibrary
// (None)

class UClass* UKismetArrayLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetArrayLibrary");

	return Clss;
}


// KismetArrayLibrary Engine.Default__KismetArrayLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetArrayLibrary* UKismetArrayLibrary::GetDefaultObj()
{
	static class UKismetArrayLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetArrayLibrary*>(UKismetArrayLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetArrayLibrary.SetArrayPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                      Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::SetArrayPropertyByName(class UObject* Object, class FName PropertyName, TArray<int32>& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "SetArrayPropertyByName");

	Params::UKismetArrayLibrary_SetArrayPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.FilterArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>              TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>          FilterClass                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              FilteredArray                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::FilterArray(TArray<class AActor*>& TargetArray, TSubclassOf<class AActor> FilterClass, TArray<class AActor*>* FilteredArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "FilterArray");

	Params::UKismetArrayLibrary_FilterArray_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.FilterClass = FilterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (FilteredArray != nullptr)
		*FilteredArray = std::move(Parms.FilteredArray);

}


// Function Engine.KismetArrayLibrary.Array_Swap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              FirstIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SecondIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Swap(TArray<int32>& TargetArray, int32 FirstIndex, int32 SecondIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Swap");

	Params::UKismetArrayLibrary_Array_Swap_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.FirstIndex = FirstIndex;
	Parms.SecondIndex = SecondIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.Array_Shuffle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Shuffle(TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Shuffle");

	Params::UKismetArrayLibrary_Array_Shuffle_Params Parms{};

	Parms.TargetArray = TargetArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.Array_Set
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Item                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSizeToFit                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Set(TArray<int32>& TargetArray, int32 Index, int32& Item, bool bSizeToFit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Set");

	Params::UKismetArrayLibrary_Array_Set_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.Index = Index;
	Parms.Item = Item;
	Parms.bSizeToFit = bSizeToFit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.Array_Resize
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Size                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Resize(TArray<int32>& TargetArray, int32 Size)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Resize");

	Params::UKismetArrayLibrary_Array_Resize_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.Array_RemoveItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Item                                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_RemoveItem(TArray<int32>& TargetArray, int32& Item)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_RemoveItem");

	Params::UKismetArrayLibrary_Array_RemoveItem_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetArrayLibrary.Array_Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              IndexToRemove                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Remove(TArray<int32>& TargetArray, int32 IndexToRemove)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Remove");

	Params::UKismetArrayLibrary_Array_Remove_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.IndexToRemove = IndexToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.Array_Length
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_Length(TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Length");

	Params::UKismetArrayLibrary_Array_Length_Params Parms{};

	Parms.TargetArray = TargetArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetArrayLibrary.Array_LastIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_LastIndex(TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_LastIndex");

	Params::UKismetArrayLibrary_Array_LastIndex_Params Parms{};

	Parms.TargetArray = TargetArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetArrayLibrary.Array_IsValidIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              IndexToTest                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_IsValidIndex(TArray<int32>& TargetArray, int32 IndexToTest)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_IsValidIndex");

	Params::UKismetArrayLibrary_Array_IsValidIndex_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.IndexToTest = IndexToTest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetArrayLibrary.Array_Insert
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              NewItem                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Insert(TArray<int32>& TargetArray, int32& NewItem, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Insert");

	Params::UKismetArrayLibrary_Array_Insert_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.NewItem = NewItem;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.Array_Identical
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      ArrayA                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      ArrayB                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_Identical(TArray<int32>& ArrayA, TArray<int32>& ArrayB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Identical");

	Params::UKismetArrayLibrary_Array_Identical_Params Parms{};

	Parms.ArrayA = ArrayA;
	Parms.ArrayB = ArrayB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetArrayLibrary.Array_Get
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Item                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Get(TArray<int32>& TargetArray, int32 Index, int32* Item)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Get");

	Params::UKismetArrayLibrary_Array_Get_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Item != nullptr)
		*Item = Parms.Item;

}


// Function Engine.KismetArrayLibrary.Array_Find
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ItemToFind                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_Find(TArray<int32>& TargetArray, int32& ItemToFind)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Find");

	Params::UKismetArrayLibrary_Array_Find_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.ItemToFind = ItemToFind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetArrayLibrary.Array_Contains
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ItemToFind                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_Contains(TArray<int32>& TargetArray, int32& ItemToFind)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Contains");

	Params::UKismetArrayLibrary_Array_Contains_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.ItemToFind = ItemToFind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetArrayLibrary.Array_Clear
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Clear(TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Clear");

	Params::UKismetArrayLibrary_Array_Clear_Params Parms{};

	Parms.TargetArray = TargetArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.Array_Append
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                      SourceArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Append(TArray<int32>& TargetArray, TArray<int32>& SourceArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Append");

	Params::UKismetArrayLibrary_Array_Append_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.SourceArray = SourceArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetArrayLibrary.Array_AddUnique
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              NewItem                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_AddUnique(TArray<int32>& TargetArray, int32& NewItem)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_AddUnique");

	Params::UKismetArrayLibrary_Array_AddUnique_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.NewItem = NewItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetArrayLibrary.Array_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                      TargetArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              NewItem                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_Add(TArray<int32>& TargetArray, int32& NewItem)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetArrayLibrary", "Array_Add");

	Params::UKismetArrayLibrary_Array_Add_Params Parms{};

	Parms.TargetArray = TargetArray;
	Parms.NewItem = NewItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.KismetGuidLibrary
// (None)

class UClass* UKismetGuidLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetGuidLibrary");

	return Clss;
}


// KismetGuidLibrary Engine.Default__KismetGuidLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetGuidLibrary* UKismetGuidLibrary::GetDefaultObj()
{
	static class UKismetGuidLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetGuidLibrary*>(UKismetGuidLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetGuidLibrary.Parse_StringToGuid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      GuidString                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                       OutGuid                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Success                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetGuidLibrary::Parse_StringToGuid(const class FString& GuidString, struct FGuid* OutGuid, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetGuidLibrary", "Parse_StringToGuid");

	Params::UKismetGuidLibrary_Parse_StringToGuid_Params Parms{};

	Parms.GuidString = GuidString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutGuid != nullptr)
		*OutGuid = std::move(Parms.OutGuid);

	if (Success != nullptr)
		*Success = Parms.Success;

}


// Function Engine.KismetGuidLibrary.NotEqual_GuidGuid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                       A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                       B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetGuidLibrary::NotEqual_GuidGuid(struct FGuid& A, struct FGuid& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetGuidLibrary", "NotEqual_GuidGuid");

	Params::UKismetGuidLibrary_NotEqual_GuidGuid_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetGuidLibrary.NewGuid
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid UKismetGuidLibrary::NewGuid()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetGuidLibrary", "NewGuid");

	Params::UKismetGuidLibrary_NewGuid_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetGuidLibrary.IsValid_Guid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                       InGuid                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetGuidLibrary::IsValid_Guid(struct FGuid& InGuid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetGuidLibrary", "IsValid_Guid");

	Params::UKismetGuidLibrary_IsValid_Guid_Params Parms{};

	Parms.InGuid = InGuid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetGuidLibrary.Invalidate_Guid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                       InGuid                                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetGuidLibrary::Invalidate_Guid(struct FGuid& InGuid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetGuidLibrary", "Invalidate_Guid");

	Params::UKismetGuidLibrary_Invalidate_Guid_Params Parms{};

	Parms.InGuid = InGuid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                       A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                       B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetGuidLibrary::EqualEqual_GuidGuid(struct FGuid& A, struct FGuid& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetGuidLibrary", "EqualEqual_GuidGuid");

	Params::UKismetGuidLibrary_EqualEqual_GuidGuid_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetGuidLibrary.Conv_GuidToString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                       InGuid                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetGuidLibrary::Conv_GuidToString(struct FGuid& InGuid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetGuidLibrary", "Conv_GuidToString");

	Params::UKismetGuidLibrary_Conv_GuidToString_Params Parms{};

	Parms.InGuid = InGuid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.KismetInputLibrary
// (None)

class UClass* UKismetInputLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetInputLibrary");

	return Clss;
}


// KismetInputLibrary Engine.Default__KismetInputLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetInputLibrary* UKismetInputLibrary::GetDefaultObj()
{
	static class UKismetInputLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetInputLibrary*>(UKismetInputLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::PointerEvent_IsTouchEvent(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_IsTouchEvent");

	Params::UKismetInputLibrary_PointerEvent_IsTouchEvent_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKey                        MouseButton                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::PointerEvent_IsMouseButtonDown(struct FPointerEvent& Input, const struct FKey& MouseButton)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_IsMouseButtonDown");

	Params::UKismetInputLibrary_PointerEvent_IsMouseButtonDown_Params Parms{};

	Parms.Input = Input;
	Parms.MouseButton = MouseButton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetInputLibrary::PointerEvent_GetWheelDelta(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetWheelDelta");

	Params::UKismetInputLibrary_PointerEvent_GetWheelDelta_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetInputLibrary::PointerEvent_GetUserIndex(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetUserIndex");

	Params::UKismetInputLibrary_PointerEvent_GetUserIndex_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetInputLibrary::PointerEvent_GetTouchpadIndex(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetTouchpadIndex");

	Params::UKismetInputLibrary_PointerEvent_GetTouchpadIndex_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetInputLibrary::PointerEvent_GetScreenSpacePosition(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetScreenSpacePosition");

	Params::UKismetInputLibrary_PointerEvent_GetScreenSpacePosition_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetInputLibrary::PointerEvent_GetPointerIndex(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetPointerIndex");

	Params::UKismetInputLibrary_PointerEvent_GetPointerIndex_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetInputLibrary::PointerEvent_GetLastScreenSpacePosition(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetLastScreenSpacePosition");

	Params::UKismetInputLibrary_PointerEvent_GetLastScreenSpacePosition_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetGestureType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// enum class ESlateGesture           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESlateGesture UKismetInputLibrary::PointerEvent_GetGestureType(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetGestureType");

	Params::UKismetInputLibrary_PointerEvent_GetGestureType_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetInputLibrary::PointerEvent_GetGestureDelta(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetGestureDelta");

	Params::UKismetInputLibrary_PointerEvent_GetGestureDelta_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKey                        ReturnValue                                                      (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UKismetInputLibrary::PointerEvent_GetEffectingButton(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetEffectingButton");

	Params::UKismetInputLibrary_PointerEvent_GetEffectingButton_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent               Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetInputLibrary::PointerEvent_GetCursorDelta(struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "PointerEvent_GetCursorDelta");

	Params::UKismetInputLibrary_PointerEvent_GetCursorDelta_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.Key_IsVectorAxis
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsVectorAxis(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "Key_IsVectorAxis");

	Params::UKismetInputLibrary_Key_IsVectorAxis_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.Key_IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsValid(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "Key_IsValid");

	Params::UKismetInputLibrary_Key_IsValid_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.Key_IsMouseButton
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsMouseButton(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "Key_IsMouseButton");

	Params::UKismetInputLibrary_Key_IsMouseButton_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.Key_IsModifierKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsModifierKey(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "Key_IsModifierKey");

	Params::UKismetInputLibrary_Key_IsModifierKey_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.Key_IsKeyboardKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsKeyboardKey(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "Key_IsKeyboardKey");

	Params::UKismetInputLibrary_Key_IsKeyboardKey_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.Key_IsGamepadKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsGamepadKey(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "Key_IsGamepadKey");

	Params::UKismetInputLibrary_Key_IsGamepadKey_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.Key_IsFloatAxis
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsFloatAxis(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "Key_IsFloatAxis");

	Params::UKismetInputLibrary_Key_IsFloatAxis_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.Key_GetDisplayName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        Key                                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetInputLibrary::Key_GetDisplayName(struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "Key_GetDisplayName");

	Params::UKismetInputLibrary_Key_GetDisplayName_Params Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsShiftDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsShiftDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsShiftDown");

	Params::UKismetInputLibrary_InputEvent_IsShiftDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRightShiftDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsRightShiftDown");

	Params::UKismetInputLibrary_InputEvent_IsRightShiftDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRightControlDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsRightControlDown");

	Params::UKismetInputLibrary_InputEvent_IsRightControlDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRightCommandDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsRightCommandDown");

	Params::UKismetInputLibrary_InputEvent_IsRightCommandDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRightAltDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsRightAltDown");

	Params::UKismetInputLibrary_InputEvent_IsRightAltDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsRepeat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRepeat(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsRepeat");

	Params::UKismetInputLibrary_InputEvent_IsRepeat_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsLeftShiftDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsLeftShiftDown");

	Params::UKismetInputLibrary_InputEvent_IsLeftShiftDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsLeftControlDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsLeftControlDown");

	Params::UKismetInputLibrary_InputEvent_IsLeftControlDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsLeftCommandDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsLeftCommandDown");

	Params::UKismetInputLibrary_InputEvent_IsLeftCommandDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsLeftAltDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsLeftAltDown");

	Params::UKismetInputLibrary_InputEvent_IsLeftAltDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsControlDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsControlDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsControlDown");

	Params::UKismetInputLibrary_InputEvent_IsControlDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsCommandDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsCommandDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsCommandDown");

	Params::UKismetInputLibrary_InputEvent_IsCommandDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.InputEvent_IsAltDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                 Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsAltDown(struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "InputEvent_IsAltDown");

	Params::UKismetInputLibrary_InputEvent_IsAltDown_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.GetUserIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyEvent                   Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetInputLibrary::GetUserIndex(struct FKeyEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "GetUserIndex");

	Params::UKismetInputLibrary_GetUserIndex_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.GetKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyEvent                   Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKey                        ReturnValue                                                      (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UKismetInputLibrary::GetKey(struct FKeyEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "GetKey");

	Params::UKismetInputLibrary_GetKey_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.GetAnalogValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnalogInputEvent           Input                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetInputLibrary::GetAnalogValue(struct FAnalogInputEvent& Input)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "GetAnalogValue");

	Params::UKismetInputLibrary_GetAnalogValue_Params Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.EqualEqual_KeyKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                        A                                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                        B                                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::EqualEqual_KeyKey(const struct FKey& A, const struct FKey& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "EqualEqual_KeyKey");

	Params::UKismetInputLibrary_EqualEqual_KeyKey_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.EqualEqual_InputChordInputChord
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputChord                 A                                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputChord                 B                                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::EqualEqual_InputChordInputChord(const struct FInputChord& A, const struct FInputChord& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "EqualEqual_InputChordInputChord");

	Params::UKismetInputLibrary_EqualEqual_InputChordInputChord_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInputLibrary.CalibrateTilt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetInputLibrary::CalibrateTilt()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInputLibrary", "CalibrateTilt");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.KismetInternationalizationLibrary
// (None)

class UClass* UKismetInternationalizationLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetInternationalizationLibrary");

	return Clss;
}


// KismetInternationalizationLibrary Engine.Default__KismetInternationalizationLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetInternationalizationLibrary* UKismetInternationalizationLibrary::GetDefaultObj()
{
	static class UKismetInternationalizationLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetInternationalizationLibrary*>(UKismetInternationalizationLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLocale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Culture                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SaveToConfig                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentLocale(const class FString& Culture, bool SaveToConfig)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "SetCurrentLocale");

	Params::UKismetInternationalizationLibrary_SetCurrentLocale_Params Parms{};

	Parms.Culture = Culture;
	Parms.SaveToConfig = SaveToConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLanguageAndLocale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Culture                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SaveToConfig                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentLanguageAndLocale(const class FString& Culture, bool SaveToConfig)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "SetCurrentLanguageAndLocale");

	Params::UKismetInternationalizationLibrary_SetCurrentLanguageAndLocale_Params Parms{};

	Parms.Culture = Culture;
	Parms.SaveToConfig = SaveToConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Culture                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SaveToConfig                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentLanguage(const class FString& Culture, bool SaveToConfig)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "SetCurrentLanguage");

	Params::UKismetInternationalizationLibrary_SetCurrentLanguage_Params Parms{};

	Parms.Culture = Culture;
	Parms.SaveToConfig = SaveToConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.SetCurrentCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Culture                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SaveToConfig                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentCulture(const class FString& Culture, bool SaveToConfig)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "SetCurrentCulture");

	Params::UKismetInternationalizationLibrary_SetCurrentCulture_Params Parms{};

	Parms.Culture = Culture;
	Parms.SaveToConfig = SaveToConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.SetCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        AssetGroup                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Culture                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SaveToConfig                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentAssetGroupCulture(class FName AssetGroup, const class FString& Culture, bool SaveToConfig)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "SetCurrentAssetGroupCulture");

	Params::UKismetInternationalizationLibrary_SetCurrentAssetGroupCulture_Params Parms{};

	Parms.AssetGroup = AssetGroup;
	Parms.Culture = Culture;
	Parms.SaveToConfig = SaveToConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.GetSuitableCulture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              AvailableCultures                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      CultureToMatch                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FallbackCulture                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetSuitableCulture(TArray<class FString>& AvailableCultures, const class FString& CultureToMatch, const class FString& FallbackCulture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "GetSuitableCulture");

	Params::UKismetInternationalizationLibrary_GetSuitableCulture_Params Parms{};

	Parms.AvailableCultures = AvailableCultures;
	Parms.CultureToMatch = CultureToMatch;
	Parms.FallbackCulture = FallbackCulture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.GetNativeCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ELocalizedTextSourceCategoryTextCategory                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetNativeCulture(enum class ELocalizedTextSourceCategory TextCategory)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "GetNativeCulture");

	Params::UKismetInternationalizationLibrary_GetNativeCulture_Params Parms{};

	Parms.TextCategory = TextCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.GetLocalizedCultures
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               IncludeGame                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IncludeEngine                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IncludeEditor                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IncludeAdditional                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetInternationalizationLibrary::GetLocalizedCultures(bool IncludeGame, bool IncludeEngine, bool IncludeEditor, bool IncludeAdditional)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "GetLocalizedCultures");

	Params::UKismetInternationalizationLibrary_GetLocalizedCultures_Params Parms{};

	Parms.IncludeGame = IncludeGame;
	Parms.IncludeEngine = IncludeEngine;
	Parms.IncludeEditor = IncludeEditor;
	Parms.IncludeAdditional = IncludeAdditional;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.GetCurrentLocale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCurrentLocale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "GetCurrentLocale");

	Params::UKismetInternationalizationLibrary_GetCurrentLocale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.GetCurrentLanguage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCurrentLanguage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "GetCurrentLanguage");

	Params::UKismetInternationalizationLibrary_GetCurrentLanguage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.GetCurrentCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCurrentCulture()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "GetCurrentCulture");

	Params::UKismetInternationalizationLibrary_GetCurrentCulture_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.GetCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        AssetGroup                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCurrentAssetGroupCulture(class FName AssetGroup)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "GetCurrentAssetGroupCulture");

	Params::UKismetInternationalizationLibrary_GetCurrentAssetGroupCulture_Params Parms{};

	Parms.AssetGroup = AssetGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.GetCultureDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Culture                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Localized                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCultureDisplayName(const class FString& Culture, bool Localized)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "GetCultureDisplayName");

	Params::UKismetInternationalizationLibrary_GetCultureDisplayName_Params Parms{};

	Parms.Culture = Culture;
	Parms.Localized = Localized;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetInternationalizationLibrary.ClearCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                        AssetGroup                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               SaveToConfig                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetInternationalizationLibrary::ClearCurrentAssetGroupCulture(class FName AssetGroup, bool SaveToConfig)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetInternationalizationLibrary", "ClearCurrentAssetGroupCulture");

	Params::UKismetInternationalizationLibrary_ClearCurrentAssetGroupCulture_Params Parms{};

	Parms.AssetGroup = AssetGroup;
	Parms.SaveToConfig = SaveToConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.KismetMaterialLibrary
// (None)

class UClass* UKismetMaterialLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetMaterialLibrary");

	return Clss;
}


// KismetMaterialLibrary Engine.Default__KismetMaterialLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetMaterialLibrary* UKismetMaterialLibrary::GetDefaultObj()
{
	static class UKismetMaterialLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetMaterialLibrary*>(UKismetMaterialLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetMaterialLibrary.SetVectorParameterValue
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*Collection                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ParameterValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMaterialLibrary::SetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, struct FLinearColor& ParameterValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMaterialLibrary", "SetVectorParameterValue");

	Params::UKismetMaterialLibrary_SetVectorParameterValue_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Collection = Collection;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMaterialLibrary.SetScalarParameterValue
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*Collection                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ParameterValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMaterialLibrary::SetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, float ParameterValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMaterialLibrary", "SetScalarParameterValue");

	Params::UKismetMaterialLibrary_SetScalarParameterValue_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Collection = Collection;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMaterialLibrary.GetVectorParameterValue
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*Collection                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMaterialLibrary::GetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMaterialLibrary", "GetVectorParameterValue");

	Params::UKismetMaterialLibrary_GetVectorParameterValue_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Collection = Collection;
	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMaterialLibrary.GetScalarParameterValue
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*Collection                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMaterialLibrary::GetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMaterialLibrary", "GetScalarParameterValue");

	Params::UKismetMaterialLibrary_GetScalarParameterValue_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Collection = Collection;
	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          Parent                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        OptionalName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UKismetMaterialLibrary::CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UMaterialInterface* Parent, class FName OptionalName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMaterialLibrary", "CreateDynamicMaterialInstance");

	Params::UKismetMaterialLibrary_CreateDynamicMaterialInstance_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Parent = Parent;
	Parms.OptionalName = OptionalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.KismetMathLibrary
// (None)

class UClass* UKismetMathLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetMathLibrary");

	return Clss;
}


// KismetMathLibrary Engine.Default__KismetMathLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetMathLibrary* UKismetMathLibrary::GetDefaultObj()
{
	static class UKismetMathLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetMathLibrary*>(UKismetMathLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetMathLibrary.Xor_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Xor_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Xor_IntInt");

	Params::UKismetMathLibrary_Xor_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Xor_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Xor_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Xor_Int64Int64");

	Params::UKismetMathLibrary_Xor_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VSizeXYSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSizeXYSquared(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VSizeXYSquared");

	Params::UKismetMathLibrary_VSizeXYSquared_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VSizeXY
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSizeXY(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VSizeXY");

	Params::UKismetMathLibrary_VSizeXY_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VSizeSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSizeSquared(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VSizeSquared");

	Params::UKismetMathLibrary_VSizeSquared_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VSize2DSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSize2DSquared(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VSize2DSquared");

	Params::UKismetMathLibrary_VSize2DSquared_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VSize2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSize2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VSize2D");

	Params::UKismetMathLibrary_VSize2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSize(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VSize");

	Params::UKismetMathLibrary_VSize_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VLerp(const struct FVector& A, const struct FVector& B, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VLerp");

	Params::UKismetMathLibrary_VLerp_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VInterpTo_Constant(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VInterpTo_Constant");

	Params::UKismetMathLibrary_VInterpTo_Constant_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VInterpTo(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VInterpTo");

	Params::UKismetMathLibrary_VInterpTo_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VectorSpringInterp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVectorSpringState          SpringState                                                      (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                              Stiffness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CriticalDampingFactor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Mass                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VectorSpringInterp(const struct FVector& Current, const struct FVector& Target, struct FVectorSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VectorSpringInterp");

	Params::UKismetMathLibrary_VectorSpringInterp_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.SpringState = SpringState;
	Parms.Stiffness = Stiffness;
	Parms.CriticalDampingFactor = CriticalDampingFactor;
	Parms.DeltaTime = DeltaTime;
	Parms.Mass = Mass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Zero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Zero");

	Params::UKismetMathLibrary_Vector_Zero_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Up
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Up()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Up");

	Params::UKismetMathLibrary_Vector_Up_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_UnwindEuler
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_UnwindEuler(struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_UnwindEuler");

	Params::UKismetMathLibrary_Vector_UnwindEuler_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Vector_UnitCartesianToSpherical
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector_UnitCartesianToSpherical(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_UnitCartesianToSpherical");

	Params::UKismetMathLibrary_Vector_UnitCartesianToSpherical_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_ToRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ToRadians(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_ToRadians");

	Params::UKismetMathLibrary_Vector_ToRadians_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_ToDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ToDegrees(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_ToDegrees");

	Params::UKismetMathLibrary_Vector_ToDegrees_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_SnappedToGrid
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVect                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InGridSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_SnappedToGrid(const struct FVector& InVect, float InGridSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_SnappedToGrid");

	Params::UKismetMathLibrary_Vector_SnappedToGrid_Params Parms{};

	Parms.InVect = InVect;
	Parms.InGridSize = InGridSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Set
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_Set(struct FVector& A, float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Set");

	Params::UKismetMathLibrary_Vector_Set_Params Parms{};

	Parms.A = A;
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Vector_Right
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Right()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Right");

	Params::UKismetMathLibrary_Vector_Right_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Reciprocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Reciprocal(struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Reciprocal");

	Params::UKismetMathLibrary_Vector_Reciprocal_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_ProjectOnToNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     V                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InNormal                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ProjectOnToNormal(const struct FVector& V, const struct FVector& InNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_ProjectOnToNormal");

	Params::UKismetMathLibrary_Vector_ProjectOnToNormal_Params Parms{};

	Parms.V = V;
	Parms.InNormal = InNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_One
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_One()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_One");

	Params::UKismetMathLibrary_Vector_One_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_NormalUnsafe
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_NormalUnsafe(struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_NormalUnsafe");

	Params::UKismetMathLibrary_Vector_NormalUnsafe_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Normalize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_Normalize(struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Normalize");

	Params::UKismetMathLibrary_Vector_Normalize_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Vector_Normal2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Normal2D(const struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Normal2D");

	Params::UKismetMathLibrary_Vector_Normal2D_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_MirrorByPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                      InPlane                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_MirrorByPlane(const struct FVector& A, struct FPlane& InPlane)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_MirrorByPlane");

	Params::UKismetMathLibrary_Vector_MirrorByPlane_Params Parms{};

	Parms.A = A;
	Parms.InPlane = InPlane;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Left
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Left()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Left");

	Params::UKismetMathLibrary_Vector_Left_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_IsZero
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsZero(struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_IsZero");

	Params::UKismetMathLibrary_Vector_IsZero_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_IsUnit
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SquaredLenthTolerance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsUnit(struct FVector& A, float SquaredLenthTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_IsUnit");

	Params::UKismetMathLibrary_Vector_IsUnit_Params Parms{};

	Parms.A = A;
	Parms.SquaredLenthTolerance = SquaredLenthTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_IsUniform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsUniform(struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_IsUniform");

	Params::UKismetMathLibrary_Vector_IsUniform_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_IsNormal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsNormal(struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_IsNormal");

	Params::UKismetMathLibrary_Vector_IsNormal_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_IsNearlyZero
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsNearlyZero(struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_IsNearlyZero");

	Params::UKismetMathLibrary_Vector_IsNearlyZero_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_IsNAN
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsNAN(struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_IsNAN");

	Params::UKismetMathLibrary_Vector_IsNAN_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_HeadingAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_HeadingAngle(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_HeadingAngle");

	Params::UKismetMathLibrary_Vector_HeadingAngle_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_GetSignVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_GetSignVector(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_GetSignVector");

	Params::UKismetMathLibrary_Vector_GetSignVector_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_GetProjection
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_GetProjection(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_GetProjection");

	Params::UKismetMathLibrary_Vector_GetProjection_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_GetAbsMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_GetAbsMin(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_GetAbsMin");

	Params::UKismetMathLibrary_Vector_GetAbsMin_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_GetAbsMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_GetAbsMax(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_GetAbsMax");

	Params::UKismetMathLibrary_Vector_GetAbsMax_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_GetAbs
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_GetAbs(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_GetAbs");

	Params::UKismetMathLibrary_Vector_GetAbs_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Forward
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Forward()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Forward");

	Params::UKismetMathLibrary_Vector_Forward_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Down
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Down()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Down");

	Params::UKismetMathLibrary_Vector_Down_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_DistanceSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     V1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     V2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_DistanceSquared(const struct FVector& V1, const struct FVector& V2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_DistanceSquared");

	Params::UKismetMathLibrary_Vector_DistanceSquared_Params Parms{};

	Parms.V1 = V1;
	Parms.V2 = V2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Distance2DSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     V1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     V2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_Distance2DSquared(const struct FVector& V1, const struct FVector& V2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Distance2DSquared");

	Params::UKismetMathLibrary_Vector_Distance2DSquared_Params Parms{};

	Parms.V1 = V1;
	Parms.V2 = V2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Distance2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     V1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     V2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_Distance2D(const struct FVector& V1, const struct FVector& V2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Distance2D");

	Params::UKismetMathLibrary_Vector_Distance2D_Params Parms{};

	Parms.V1 = V1;
	Parms.V2 = V2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Distance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     V1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     V2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_Distance(const struct FVector& V1, const struct FVector& V2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Distance");

	Params::UKismetMathLibrary_Vector_Distance_Params Parms{};

	Parms.V1 = V1;
	Parms.V2 = V2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_CosineAngle2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_CosineAngle2D(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_CosineAngle2D");

	Params::UKismetMathLibrary_Vector_CosineAngle2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_ComponentMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ComponentMin(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_ComponentMin");

	Params::UKismetMathLibrary_Vector_ComponentMin_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_ComponentMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ComponentMax(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_ComponentMax");

	Params::UKismetMathLibrary_Vector_ComponentMax_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_ClampSizeMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ClampSizeMax2D(const struct FVector& A, float Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_ClampSizeMax2D");

	Params::UKismetMathLibrary_Vector_ClampSizeMax2D_Params Parms{};

	Parms.A = A;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_ClampSizeMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ClampSizeMax(const struct FVector& A, float Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_ClampSizeMax");

	Params::UKismetMathLibrary_Vector_ClampSizeMax_Params Parms{};

	Parms.A = A;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_ClampSize2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ClampSize2D(const struct FVector& A, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_ClampSize2D");

	Params::UKismetMathLibrary_Vector_ClampSize2D_Params Parms{};

	Parms.A = A;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_BoundedToCube
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVect                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRadius                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_BoundedToCube(const struct FVector& InVect, float InRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_BoundedToCube");

	Params::UKismetMathLibrary_Vector_BoundedToCube_Params Parms{};

	Parms.InVect = InVect;
	Parms.InRadius = InRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_BoundedToBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVect                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InBoxMin                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InBoxMax                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_BoundedToBox(const struct FVector& InVect, const struct FVector& InBoxMin, const struct FVector& InBoxMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_BoundedToBox");

	Params::UKismetMathLibrary_Vector_BoundedToBox_Params Parms{};

	Parms.InVect = InVect;
	Parms.InBoxMin = InBoxMin;
	Parms.InBoxMax = InBoxMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Backward
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Backward()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Backward");

	Params::UKismetMathLibrary_Vector_Backward_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector_Assign
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InVector                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_Assign(struct FVector& A, struct FVector& InVector)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_Assign");

	Params::UKismetMathLibrary_Vector_Assign_Params Parms{};

	Parms.A = A;
	Parms.InVector = InVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Vector_AddBounded
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InAddVect                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRadius                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_AddBounded(struct FVector& A, const struct FVector& InAddVect, float InRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector_AddBounded");

	Params::UKismetMathLibrary_Vector_AddBounded_Params Parms{};

	Parms.A = A;
	Parms.InAddVect = InAddVect;
	Parms.InRadius = InRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Vector4_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_Zero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_Zero");

	Params::UKismetMathLibrary_Vector4_Zero_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_SizeSquared3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_SizeSquared3(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_SizeSquared3");

	Params::UKismetMathLibrary_Vector4_SizeSquared3_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_SizeSquared
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_SizeSquared(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_SizeSquared");

	Params::UKismetMathLibrary_Vector4_SizeSquared_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_Size3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_Size3(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_Size3");

	Params::UKismetMathLibrary_Vector4_Size3_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_Size
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_Size(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_Size");

	Params::UKismetMathLibrary_Vector4_Size_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_Set
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                    A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              W                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector4_Set(struct FVector4& A, float X, float Y, float Z, float W)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_Set");

	Params::UKismetMathLibrary_Vector4_Set_Params Parms{};

	Parms.A = A;
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.W = W;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Vector4_NormalUnsafe3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_NormalUnsafe3(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_NormalUnsafe3");

	Params::UKismetMathLibrary_Vector4_NormalUnsafe3_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_Normalize3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                    A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector4_Normalize3(struct FVector4& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_Normalize3");

	Params::UKismetMathLibrary_Vector4_Normalize3_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Vector4_Normal3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_Normal3(struct FVector4& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_Normal3");

	Params::UKismetMathLibrary_Vector4_Normal3_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_Negated
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_Negated(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_Negated");

	Params::UKismetMathLibrary_Vector4_Negated_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_MirrorByVector3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    Direction                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    SurfaceNormal                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_MirrorByVector3(struct FVector4& Direction, struct FVector4& SurfaceNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_MirrorByVector3");

	Params::UKismetMathLibrary_Vector4_MirrorByVector3_Params Parms{};

	Parms.Direction = Direction;
	Parms.SurfaceNormal = SurfaceNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_IsZero
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsZero(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_IsZero");

	Params::UKismetMathLibrary_Vector4_IsZero_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_IsUnit3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SquaredLenthTolerance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsUnit3(struct FVector4& A, float SquaredLenthTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_IsUnit3");

	Params::UKismetMathLibrary_Vector4_IsUnit3_Params Parms{};

	Parms.A = A;
	Parms.SquaredLenthTolerance = SquaredLenthTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_IsNormal3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsNormal3(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_IsNormal3");

	Params::UKismetMathLibrary_Vector4_IsNormal3_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_IsNearlyZero3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsNearlyZero3(struct FVector4& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_IsNearlyZero3");

	Params::UKismetMathLibrary_Vector4_IsNearlyZero3_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_IsNAN
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsNAN(struct FVector4& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_IsNAN");

	Params::UKismetMathLibrary_Vector4_IsNAN_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_DotProduct3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_DotProduct3(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_DotProduct3");

	Params::UKismetMathLibrary_Vector4_DotProduct3_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_DotProduct
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_DotProduct(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_DotProduct");

	Params::UKismetMathLibrary_Vector4_DotProduct_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_CrossProduct3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_CrossProduct3(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_CrossProduct3");

	Params::UKismetMathLibrary_Vector4_CrossProduct3_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector4_Assign
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                    A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    InVector                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector4_Assign(struct FVector4& A, struct FVector4& InVector)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector4_Assign");

	Params::UKismetMathLibrary_Vector4_Assign_Params Parms{};

	Parms.A = A;
	Parms.InVector = InVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2DInterpTo_Constant(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector2DInterpTo_Constant");

	Params::UKismetMathLibrary_Vector2DInterpTo_Constant_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector2DInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2DInterpTo(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector2DInterpTo");

	Params::UKismetMathLibrary_Vector2DInterpTo_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector2D_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2D_Zero()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector2D_Zero");

	Params::UKismetMathLibrary_Vector2D_Zero_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector2D_Unit45Deg
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2D_Unit45Deg()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector2D_Unit45Deg");

	Params::UKismetMathLibrary_Vector2D_Unit45Deg_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Vector2D_One
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2D_One()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Vector2D_One");

	Params::UKismetMathLibrary_Vector2D_One_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.VEase
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEasingFunc             EasingFunc                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendExp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Steps                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VEase(const struct FVector& A, const struct FVector& B, float Alpha, enum class EEasingFunc EasingFunc, float BlendExp, int32 Steps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "VEase");

	Params::UKismetMathLibrary_VEase_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.EasingFunc = EasingFunc;
	Parms.BlendExp = BlendExp;
	Parms.Steps = Steps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.UtcNow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::UtcNow()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "UtcNow");

	Params::UKismetMathLibrary_UtcNow_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TransformRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  T                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::TransformRotation(struct FTransform& T, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TransformRotation");

	Params::UKismetMathLibrary_TransformRotation_Params Parms{};

	Parms.T = T;
	Parms.Rotation = Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TransformLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  T                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::TransformLocation(struct FTransform& T, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TransformLocation");

	Params::UKismetMathLibrary_TransformLocation_Params Parms{};

	Parms.T = T;
	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TransformDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  T                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Direction                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::TransformDirection(struct FTransform& T, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TransformDirection");

	Params::UKismetMathLibrary_TransformDirection_Params Parms{};

	Parms.T = T;
	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Transform_Determinant
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  Transform                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Transform_Determinant(struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Transform_Determinant");

	Params::UKismetMathLibrary_Transform_Determinant_Params Parms{};

	Parms.Transform = Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ToSign2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::ToSign2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ToSign2D");

	Params::UKismetMathLibrary_ToSign2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ToRounded2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::ToRounded2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ToRounded2D");

	Params::UKismetMathLibrary_ToRounded2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ToDirectionAndLength2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   OutDir                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutLength                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ToDirectionAndLength2D(const struct FVector2D& A, struct FVector2D* OutDir, float* OutLength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ToDirectionAndLength2D");

	Params::UKismetMathLibrary_ToDirectionAndLength2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutDir != nullptr)
		*OutDir = std::move(Parms.OutDir);

	if (OutLength != nullptr)
		*OutLength = Parms.OutLength;

}


// Function Engine.KismetMathLibrary.Today
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Today()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Today");

	Params::UKismetMathLibrary_Today_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TLerp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ELerpInterpolationMode  InterpMode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::TLerp(struct FTransform& A, struct FTransform& B, float Alpha, enum class ELerpInterpolationMode InterpMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TLerp");

	Params::UKismetMathLibrary_TLerp_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.InterpMode = InterpMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TInterpTo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  Current                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  Target                                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::TInterpTo(struct FTransform& Current, struct FTransform& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TInterpTo");

	Params::UKismetMathLibrary_TInterpTo_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TimespanZeroValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::TimespanZeroValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TimespanZeroValue");

	Params::UKismetMathLibrary_TimespanZeroValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TimespanRatio
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::TimespanRatio(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TimespanRatio");

	Params::UKismetMathLibrary_TimespanRatio_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TimespanMinValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::TimespanMinValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TimespanMinValue");

	Params::UKismetMathLibrary_TimespanMinValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TimespanMaxValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::TimespanMaxValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TimespanMaxValue");

	Params::UKismetMathLibrary_TimespanMaxValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TimespanFromString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      TimespanString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   Result                                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::TimespanFromString(const class FString& TimespanString, struct FTimespan* Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TimespanFromString");

	Params::UKismetMathLibrary_TimespanFromString_Params Parms{};

	Parms.TimespanString = TimespanString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.TEase
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEasingFunc             EasingFunc                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendExp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Steps                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::TEase(struct FTransform& A, struct FTransform& B, float Alpha, enum class EEasingFunc EasingFunc, float BlendExp, int32 Steps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "TEase");

	Params::UKismetMathLibrary_TEase_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.EasingFunc = EasingFunc;
	Parms.BlendExp = BlendExp;
	Parms.Steps = Steps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Tan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Tan(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Tan");

	Params::UKismetMathLibrary_Tan_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Subtract_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_VectorVector");

	Params::UKismetMathLibrary_Subtract_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Subtract_VectorInt(const struct FVector& A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_VectorInt");

	Params::UKismetMathLibrary_Subtract_VectorInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Subtract_VectorFloat(const struct FVector& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_VectorFloat");

	Params::UKismetMathLibrary_Subtract_VectorFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Subtract_Vector4Vector4(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_Vector4Vector4");

	Params::UKismetMathLibrary_Subtract_Vector4Vector4_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Subtract_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_Vector2DVector2D");

	Params::UKismetMathLibrary_Subtract_Vector2DVector2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Subtract_Vector2DFloat(const struct FVector2D& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_Vector2DFloat");

	Params::UKismetMathLibrary_Subtract_Vector2DFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Subtract_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_TimespanTimespan");

	Params::UKismetMathLibrary_Subtract_TimespanTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Subtract_QuatQuat(struct FQuat& A, struct FQuat& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_QuatQuat");

	Params::UKismetMathLibrary_Subtract_QuatQuat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Subtract_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_LinearColorLinearColor");

	Params::UKismetMathLibrary_Subtract_LinearColorLinearColor_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Subtract_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_IntInt");

	Params::UKismetMathLibrary_Subtract_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Subtract_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_Int64Int64");

	Params::UKismetMathLibrary_Subtract_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Subtract_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_FloatFloat");

	Params::UKismetMathLibrary_Subtract_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Subtract_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_DateTimeTimespan");

	Params::UKismetMathLibrary_Subtract_DateTimeTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Subtract_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_DateTimeDateTime");

	Params::UKismetMathLibrary_Subtract_DateTimeDateTime_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Subtract_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Subtract_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Subtract_ByteByte");

	Params::UKismetMathLibrary_Subtract_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Square
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Square(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Square");

	Params::UKismetMathLibrary_Square_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Sqrt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Sqrt(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Sqrt");

	Params::UKismetMathLibrary_Sqrt_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Spherical2DToUnitCartesian
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Spherical2DToUnitCartesian(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Spherical2DToUnitCartesian");

	Params::UKismetMathLibrary_Spherical2DToUnitCartesian_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Sin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Sin(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Sin");

	Params::UKismetMathLibrary_Sin_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SignOfInteger64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::SignOfInteger64(int64 A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SignOfInteger64");

	Params::UKismetMathLibrary_SignOfInteger64_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SignOfInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::SignOfInteger(int32 A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SignOfInteger");

	Params::UKismetMathLibrary_SignOfInteger_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SignOfFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::SignOfFloat(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SignOfFloat");

	Params::UKismetMathLibrary_SignOfFloat_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SetRandomStreamSeed
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream               Stream                                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                              NewSeed                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::SetRandomStreamSeed(struct FRandomStream& Stream, int32 NewSeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SetRandomStreamSeed");

	Params::UKismetMathLibrary_SetRandomStreamSeed_Params Parms{};

	Parms.Stream = Stream;
	Parms.NewSeed = NewSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Set2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Set2D(struct FVector2D& A, float X, float Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Set2D");

	Params::UKismetMathLibrary_Set2D_Params Parms{};

	Parms.A = A;
	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.SelectVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPickA                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::SelectVector(const struct FVector& A, const struct FVector& B, bool bPickA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectVector");

	Params::UKismetMathLibrary_SelectVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SelectTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bPickA                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::SelectTransform(struct FTransform& A, struct FTransform& B, bool bPickA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectTransform");

	Params::UKismetMathLibrary_SelectTransform_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SelectString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      A                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      B                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPickA                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetMathLibrary::SelectString(const class FString& A, const class FString& B, bool bPickA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectString");

	Params::UKismetMathLibrary_SelectString_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SelectRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bPickA                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::SelectRotator(const struct FRotator& A, const struct FRotator& B, bool bPickA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectRotator");

	Params::UKismetMathLibrary_SelectRotator_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SelectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSelectA                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetMathLibrary::SelectObject(class UObject* A, class UObject* B, bool bSelectA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectObject");

	Params::UKismetMathLibrary_SelectObject_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bSelectA = bSelectA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SelectInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPickA                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::SelectInt(int32 A, int32 B, bool bPickA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectInt");

	Params::UKismetMathLibrary_SelectInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SelectFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPickA                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::SelectFloat(float A, float B, bool bPickA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectFloat");

	Params::UKismetMathLibrary_SelectFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SelectColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPickA                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::SelectColor(const struct FLinearColor& A, const struct FLinearColor& B, bool bPickA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectColor");

	Params::UKismetMathLibrary_SelectColor_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SelectClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                      A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSelectA                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UKismetMathLibrary::SelectClass(class UClass* A, class UClass* B, bool bSelectA)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SelectClass");

	Params::UKismetMathLibrary_SelectClass_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bSelectA = bSelectA;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.SeedRandomStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream               Stream                                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::SeedRandomStream(struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "SeedRandomStream");

	Params::UKismetMathLibrary_SeedRandomStream_Params Parms{};

	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Round64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Round64(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Round64");

	Params::UKismetMathLibrary_Round64_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Round
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Round(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Round");

	Params::UKismetMathLibrary_Round_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Angle                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RotatorFromAxisAndAngle(const struct FVector& Axis, float Angle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RotatorFromAxisAndAngle");

	Params::UKismetMathLibrary_RotatorFromAxisAndAngle_Params Parms{};

	Parms.Axis = Axis;
	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RotateAngleAxis
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVect                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AngleDeg                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RotateAngleAxis(const struct FVector& InVect, float AngleDeg, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RotateAngleAxis");

	Params::UKismetMathLibrary_RotateAngleAxis_Params Parms{};

	Parms.InVect = InVect;
	Parms.AngleDeg = AngleDeg;
	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShortestPath                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RLerp(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RLerp");

	Params::UKismetMathLibrary_RLerp_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.bShortestPath = bShortestPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RInterpTo_Constant(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RInterpTo_Constant");

	Params::UKismetMathLibrary_RInterpTo_Constant_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RInterpTo");

	Params::UKismetMathLibrary_RInterpTo_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RGBToHSV_Vector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                RGB                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                HSV                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::RGBToHSV_Vector(const struct FLinearColor& RGB, struct FLinearColor* HSV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RGBToHSV_Vector");

	Params::UKismetMathLibrary_RGBToHSV_Vector_Params Parms{};

	Parms.RGB = RGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (HSV != nullptr)
		*HSV = std::move(Parms.HSV);

}


// Function Engine.KismetMathLibrary.RGBToHSV
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              H                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              S                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              V                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              A                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::RGBToHSV(const struct FLinearColor& InColor, float* H, float* S, float* V, float* A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RGBToHSV");

	Params::UKismetMathLibrary_RGBToHSV_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (H != nullptr)
		*H = Parms.H;

	if (S != nullptr)
		*S = Parms.S;

	if (V != nullptr)
		*V = Parms.V;

	if (A != nullptr)
		*A = Parms.A;

}


// Function Engine.KismetMathLibrary.RGBLinearToHSV
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                RGB                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::RGBLinearToHSV(const struct FLinearColor& RGB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RGBLinearToHSV");

	Params::UKismetMathLibrary_RGBLinearToHSV_Params Parms{};

	Parms.RGB = RGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ResetVectorSpringState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVectorSpringState          SpringState                                                      (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ResetVectorSpringState(struct FVectorSpringState& SpringState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ResetVectorSpringState");

	Params::UKismetMathLibrary_ResetVectorSpringState_Params Parms{};

	Parms.SpringState = SpringState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.ResetRandomStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ResetRandomStream(struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ResetRandomStream");

	Params::UKismetMathLibrary_ResetRandomStream_Params Parms{};

	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.ResetFloatSpringState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFloatSpringState           SpringState                                                      (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ResetFloatSpringState(struct FFloatSpringState& SpringState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ResetFloatSpringState");

	Params::UKismetMathLibrary_ResetFloatSpringState_Params Parms{};

	Parms.SpringState = SpringState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.REase
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShortestPath                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEasingFunc             EasingFunc                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendExp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Steps                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::REase(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath, enum class EEasingFunc EasingFunc, float BlendExp, int32 Steps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "REase");

	Params::UKismetMathLibrary_REase_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.bShortestPath = bShortestPath;
	Parms.EasingFunc = EasingFunc;
	Parms.BlendExp = BlendExp;
	Parms.Steps = Steps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadiansFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ConeDir                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxYawInRadians                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxPitchInRadians                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInRadiansFromStream(struct FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians, struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorInEllipticalConeInRadiansFromStream");

	Params::UKismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream_Params Parms{};

	Parms.ConeDir = ConeDir;
	Parms.MaxYawInRadians = MaxYawInRadians;
	Parms.MaxPitchInRadians = MaxPitchInRadians;
	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ConeDir                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxYawInRadians                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxPitchInRadians                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInRadians(const struct FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorInEllipticalConeInRadians");

	Params::UKismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians_Params Parms{};

	Parms.ConeDir = ConeDir;
	Parms.MaxYawInRadians = MaxYawInRadians;
	Parms.MaxPitchInRadians = MaxPitchInRadians;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegreesFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ConeDir                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxYawInDegrees                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxPitchInDegrees                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInDegreesFromStream(struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees, struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorInEllipticalConeInDegreesFromStream");

	Params::UKismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream_Params Parms{};

	Parms.ConeDir = ConeDir;
	Parms.MaxYawInDegrees = MaxYawInDegrees;
	Parms.MaxPitchInDegrees = MaxPitchInDegrees;
	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ConeDir                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxYawInDegrees                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxPitchInDegrees                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInDegrees(const struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorInEllipticalConeInDegrees");

	Params::UKismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees_Params Parms{};

	Parms.ConeDir = ConeDir;
	Parms.MaxYawInDegrees = MaxYawInDegrees;
	Parms.MaxPitchInDegrees = MaxPitchInDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadiansFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ConeDir                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ConeHalfAngleInRadians                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInRadiansFromStream(struct FVector& ConeDir, float ConeHalfAngleInRadians, struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorInConeInRadiansFromStream");

	Params::UKismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream_Params Parms{};

	Parms.ConeDir = ConeDir;
	Parms.ConeHalfAngleInRadians = ConeHalfAngleInRadians;
	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ConeDir                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ConeHalfAngleInRadians                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInRadians(const struct FVector& ConeDir, float ConeHalfAngleInRadians)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorInConeInRadians");

	Params::UKismetMathLibrary_RandomUnitVectorInConeInRadians_Params Parms{};

	Parms.ConeDir = ConeDir;
	Parms.ConeHalfAngleInRadians = ConeHalfAngleInRadians;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegreesFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ConeDir                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ConeHalfAngleInDegrees                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInDegreesFromStream(struct FVector& ConeDir, float ConeHalfAngleInDegrees, struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorInConeInDegreesFromStream");

	Params::UKismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream_Params Parms{};

	Parms.ConeDir = ConeDir;
	Parms.ConeHalfAngleInDegrees = ConeHalfAngleInDegrees;
	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ConeDir                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ConeHalfAngleInDegrees                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInDegrees(const struct FVector& ConeDir, float ConeHalfAngleInDegrees)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorInConeInDegrees");

	Params::UKismetMathLibrary_RandomUnitVectorInConeInDegrees_Params Parms{};

	Parms.ConeDir = ConeDir;
	Parms.ConeHalfAngleInDegrees = ConeHalfAngleInDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVectorFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorFromStream(struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVectorFromStream");

	Params::UKismetMathLibrary_RandomUnitVectorFromStream_Params Parms{};

	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomUnitVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVector()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomUnitVector");

	Params::UKismetMathLibrary_RandomUnitVector_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomRotatorFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               bRoll                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RandomRotatorFromStream(bool bRoll, struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomRotatorFromStream");

	Params::UKismetMathLibrary_RandomRotatorFromStream_Params Parms{};

	Parms.bRoll = bRoll;
	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               bRoll                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RandomRotator(bool bRoll)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomRotator");

	Params::UKismetMathLibrary_RandomRotator_Params Parms{};

	Parms.bRoll = bRoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomPointInBoundingBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Origin                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxExtent                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomPointInBoundingBox(const struct FVector& Origin, const struct FVector& BoxExtent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomPointInBoundingBox");

	Params::UKismetMathLibrary_RandomPointInBoundingBox_Params Parms{};

	Parms.Origin = Origin;
	Parms.BoxExtent = BoxExtent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::RandomIntegerInRangeFromStream(int32 Min, int32 Max, struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomIntegerInRangeFromStream");

	Params::UKismetMathLibrary_RandomIntegerInRangeFromStream_Params Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomIntegerInRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::RandomIntegerInRange(int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomIntegerInRange");

	Params::UKismetMathLibrary_RandomIntegerInRange_Params Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomIntegerFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::RandomIntegerFromStream(int32 Max, struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomIntegerFromStream");

	Params::UKismetMathLibrary_RandomIntegerFromStream_Params Parms{};

	Parms.Max = Max;
	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomInteger64InRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::RandomInteger64InRange(int64 Min, int64 Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomInteger64InRange");

	Params::UKismetMathLibrary_RandomInteger64InRange_Params Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomInteger64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::RandomInteger64(int64 Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomInteger64");

	Params::UKismetMathLibrary_RandomInteger64_Params Parms{};

	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::RandomInteger(int32 Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomInteger");

	Params::UKismetMathLibrary_RandomInteger_Params Parms{};

	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RandomFloatInRangeFromStream(float Min, float Max, struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomFloatInRangeFromStream");

	Params::UKismetMathLibrary_RandomFloatInRangeFromStream_Params Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomFloatInRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RandomFloatInRange(float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomFloatInRange");

	Params::UKismetMathLibrary_RandomFloatInRange_Params Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomFloatFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RandomFloatFromStream(struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomFloatFromStream");

	Params::UKismetMathLibrary_RandomFloatFromStream_Params Parms{};

	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RandomFloat()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomFloat");

	Params::UKismetMathLibrary_RandomFloat_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomBoolWithWeightFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Weight                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               RandomStream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::RandomBoolWithWeightFromStream(float Weight, struct FRandomStream& RandomStream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomBoolWithWeightFromStream");

	Params::UKismetMathLibrary_RandomBoolWithWeightFromStream_Params Parms{};

	Parms.Weight = Weight;
	Parms.RandomStream = RandomStream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomBoolWithWeight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Weight                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::RandomBoolWithWeight(float Weight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomBoolWithWeight");

	Params::UKismetMathLibrary_RandomBoolWithWeight_Params Parms{};

	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomBoolFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream               Stream                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::RandomBoolFromStream(struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomBoolFromStream");

	Params::UKismetMathLibrary_RandomBoolFromStream_Params Parms{};

	Parms.Stream = Stream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RandomBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::RandomBool()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RandomBool");

	Params::UKismetMathLibrary_RandomBool_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.RadiansToDegrees
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RadiansToDegrees(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "RadiansToDegrees");

	Params::UKismetMathLibrary_RadiansToDegrees_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_VectorUp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_VectorUp(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_VectorUp");

	Params::UKismetMathLibrary_Quat_VectorUp_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_VectorRight
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_VectorRight(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_VectorRight");

	Params::UKismetMathLibrary_Quat_VectorRight_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_VectorForward
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_VectorForward(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_VectorForward");

	Params::UKismetMathLibrary_Quat_VectorForward_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_UnrotateVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     V                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_UnrotateVector(struct FQuat& Q, struct FVector& V)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_UnrotateVector");

	Params::UKismetMathLibrary_Quat_UnrotateVector_Params Parms{};

	Parms.Q = Q;
	Parms.V = V;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_SizeSquared
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Quat_SizeSquared(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_SizeSquared");

	Params::UKismetMathLibrary_Quat_SizeSquared_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_Size
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Quat_Size(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Size");

	Params::UKismetMathLibrary_Quat_Size_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_SetFromEuler
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                       Q                                                                (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Euler                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Quat_SetFromEuler(struct FQuat& Q, struct FVector& Euler)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_SetFromEuler");

	Params::UKismetMathLibrary_Quat_SetFromEuler_Params Parms{};

	Parms.Q = Q;
	Parms.Euler = Euler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Quat_SetComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                       Q                                                                (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              W                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Quat_SetComponents(struct FQuat& Q, float X, float Y, float Z, float W)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_SetComponents");

	Params::UKismetMathLibrary_Quat_SetComponents_Params Parms{};

	Parms.Q = Q;
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.W = W;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Quat_Rotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Quat_Rotator(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Rotator");

	Params::UKismetMathLibrary_Quat_Rotator_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_RotateVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     V                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_RotateVector(struct FQuat& Q, struct FVector& V)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_RotateVector");

	Params::UKismetMathLibrary_Quat_RotateVector_Params Parms{};

	Parms.Q = Q;
	Parms.V = V;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_Normalized
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Normalized(struct FQuat& Q, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Normalized");

	Params::UKismetMathLibrary_Quat_Normalized_Params Parms{};

	Parms.Q = Q;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_Normalize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                       Q                                                                (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Quat_Normalize(struct FQuat& Q, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Normalize");

	Params::UKismetMathLibrary_Quat_Normalize_Params Parms{};

	Parms.Q = Q;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Quat_MakeFromEuler
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Euler                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_MakeFromEuler(struct FVector& Euler)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_MakeFromEuler");

	Params::UKismetMathLibrary_Quat_MakeFromEuler_Params Parms{};

	Parms.Euler = Euler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_Log
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Log(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Log");

	Params::UKismetMathLibrary_Quat_Log_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_IsNormalized
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Quat_IsNormalized(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_IsNormalized");

	Params::UKismetMathLibrary_Quat_IsNormalized_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_IsNonFinite
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Quat_IsNonFinite(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_IsNonFinite");

	Params::UKismetMathLibrary_Quat_IsNonFinite_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_IsIdentity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Quat_IsIdentity(struct FQuat& Q, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_IsIdentity");

	Params::UKismetMathLibrary_Quat_IsIdentity_Params Parms{};

	Parms.Q = Q;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_IsFinite
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Quat_IsFinite(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_IsFinite");

	Params::UKismetMathLibrary_Quat_IsFinite_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_Inversed
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Inversed(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Inversed");

	Params::UKismetMathLibrary_Quat_Inversed_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_Identity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Identity()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Identity");

	Params::UKismetMathLibrary_Quat_Identity_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_GetRotationAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_GetRotationAxis(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_GetRotationAxis");

	Params::UKismetMathLibrary_Quat_GetRotationAxis_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_GetAxisZ
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_GetAxisZ(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_GetAxisZ");

	Params::UKismetMathLibrary_Quat_GetAxisZ_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_GetAxisY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_GetAxisY(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_GetAxisY");

	Params::UKismetMathLibrary_Quat_GetAxisY_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_GetAxisX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_GetAxisX(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_GetAxisX");

	Params::UKismetMathLibrary_Quat_GetAxisX_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_GetAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Quat_GetAngle(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_GetAngle");

	Params::UKismetMathLibrary_Quat_GetAngle_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_Exp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Exp(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Exp");

	Params::UKismetMathLibrary_Quat_Exp_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_Euler
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       Q                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_Euler(struct FQuat& Q)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_Euler");

	Params::UKismetMathLibrary_Quat_Euler_Params Parms{};

	Parms.Q = Q;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Quat_EnforceShortestArcWith
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                       A                                                                (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Quat_EnforceShortestArcWith(struct FQuat& A, struct FQuat& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_EnforceShortestArcWith");

	Params::UKismetMathLibrary_Quat_EnforceShortestArcWith_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Quat_AngularDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Quat_AngularDistance(struct FQuat& A, struct FQuat& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Quat_AngularDistance");

	Params::UKismetMathLibrary_Quat_AngularDistance_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ProjectVectorOnToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     V                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::ProjectVectorOnToVector(const struct FVector& V, const struct FVector& Target)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ProjectVectorOnToVector");

	Params::UKismetMathLibrary_ProjectVectorOnToVector_Params Parms{};

	Parms.V = V;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ProjectVectorOnToPlane
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     V                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PlaneNormal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::ProjectVectorOnToPlane(const struct FVector& V, const struct FVector& PlaneNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ProjectVectorOnToPlane");

	Params::UKismetMathLibrary_ProjectVectorOnToPlane_Params Parms{};

	Parms.V = V;
	Parms.PlaneNormal = PlaneNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ProjectPointOnToPlane
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PlaneBase                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PlaneNormal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::ProjectPointOnToPlane(const struct FVector& Point, const struct FVector& PlaneBase, const struct FVector& PlaneNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ProjectPointOnToPlane");

	Params::UKismetMathLibrary_ProjectPointOnToPlane_Params Parms{};

	Parms.Point = Point;
	Parms.PlaneBase = PlaneBase;
	Parms.PlaneNormal = PlaneNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.PointsAreCoplanar
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>             Points                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::PointsAreCoplanar(TArray<struct FVector>& Points, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "PointsAreCoplanar");

	Params::UKismetMathLibrary_PointsAreCoplanar_Params Parms{};

	Parms.Points = Points;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.PerlinNoise1D
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::PerlinNoise1D(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "PerlinNoise1D");

	Params::UKismetMathLibrary_PerlinNoise1D_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Percent_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Percent_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Percent_IntInt");

	Params::UKismetMathLibrary_Percent_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Percent_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Percent_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Percent_FloatFloat");

	Params::UKismetMathLibrary_Percent_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Percent_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Percent_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Percent_ByteByte");

	Params::UKismetMathLibrary_Percent_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Or_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Or_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Or_IntInt");

	Params::UKismetMathLibrary_Or_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Or_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Or_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Or_Int64Int64");

	Params::UKismetMathLibrary_Or_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Now
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Now()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Now");

	Params::UKismetMathLibrary_Now_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqualExactly_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqualExactly_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqualExactly_VectorVector");

	Params::UKismetMathLibrary_NotEqualExactly_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqualExactly_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqualExactly_Vector4Vector4(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqualExactly_Vector4Vector4");

	Params::UKismetMathLibrary_NotEqualExactly_Vector4Vector4_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqualExactly_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqualExactly_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqualExactly_Vector2DVector2D");

	Params::UKismetMathLibrary_NotEqualExactly_Vector2DVector2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_VectorVector");

	Params::UKismetMathLibrary_NotEqual_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_Vector4Vector4(struct FVector4& A, struct FVector4& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_Vector4Vector4");

	Params::UKismetMathLibrary_NotEqual_Vector4Vector4_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_Vector2DVector2D");

	Params::UKismetMathLibrary_NotEqual_Vector2DVector2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_TimespanTimespan");

	Params::UKismetMathLibrary_NotEqual_TimespanTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_RotatorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_RotatorRotator");

	Params::UKismetMathLibrary_NotEqual_RotatorRotator_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_QuatQuat(struct FQuat& A, struct FQuat& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_QuatQuat");

	Params::UKismetMathLibrary_NotEqual_QuatQuat_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_ObjectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_ObjectObject(class UObject* A, class UObject* B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_ObjectObject");

	Params::UKismetMathLibrary_NotEqual_ObjectObject_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_NameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_NameName(class FName A, class FName B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_NameName");

	Params::UKismetMathLibrary_NotEqual_NameName_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_LinearColorLinearColor");

	Params::UKismetMathLibrary_NotEqual_LinearColorLinearColor_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_IntInt");

	Params::UKismetMathLibrary_NotEqual_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_Int64Int64");

	Params::UKismetMathLibrary_NotEqual_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_FloatFloat");

	Params::UKismetMathLibrary_NotEqual_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_DateTimeDateTime");

	Params::UKismetMathLibrary_NotEqual_DateTimeDateTime_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_ClassClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                      A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_ClassClass(class UClass* A, class UClass* B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_ClassClass");

	Params::UKismetMathLibrary_NotEqual_ClassClass_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_ByteByte");

	Params::UKismetMathLibrary_NotEqual_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NotEqual_BoolBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_BoolBool(bool A, bool B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NotEqual_BoolBool");

	Params::UKismetMathLibrary_NotEqual_BoolBool_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Not_PreBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Not_PreBool(bool A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Not_PreBool");

	Params::UKismetMathLibrary_Not_PreBool_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Not_Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Not_Int64(int64 A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Not_Int64");

	Params::UKismetMathLibrary_Not_Int64_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Not_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Not_Int(int32 A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Not_Int");

	Params::UKismetMathLibrary_Not_Int_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NormalSafe2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::NormalSafe2D(const struct FVector2D& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NormalSafe2D");

	Params::UKismetMathLibrary_NormalSafe2D_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NormalizeToRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RangeMin                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RangeMax                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::NormalizeToRange(float Value, float RangeMin, float RangeMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NormalizeToRange");

	Params::UKismetMathLibrary_NormalizeToRange_Params Parms{};

	Parms.Value = Value;
	Parms.RangeMin = RangeMin;
	Parms.RangeMax = RangeMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NormalizedDeltaRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::NormalizedDeltaRotator(const struct FRotator& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NormalizedDeltaRotator");

	Params::UKismetMathLibrary_NormalizedDeltaRotator_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NormalizeAxis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Angle                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::NormalizeAxis(float Angle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NormalizeAxis");

	Params::UKismetMathLibrary_NormalizeAxis_Params Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Normalize2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   A                                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Normalize2D(struct FVector2D& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Normalize2D");

	Params::UKismetMathLibrary_Normalize2D_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.Normal2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Normal2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Normal2D");

	Params::UKismetMathLibrary_Normal2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Normal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Normal(const struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Normal");

	Params::UKismetMathLibrary_Normal_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NegateVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::NegateVector(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NegateVector");

	Params::UKismetMathLibrary_NegateVector_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NegateRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::NegateRotator(const struct FRotator& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NegateRotator");

	Params::UKismetMathLibrary_NegateRotator_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Negated2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Negated2D(struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Negated2D");

	Params::UKismetMathLibrary_Negated2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              LocationTolerance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              RotationTolerance                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scale3DTolerance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NearlyEqual_TransformTransform(struct FTransform& A, struct FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NearlyEqual_TransformTransform");

	Params::UKismetMathLibrary_NearlyEqual_TransformTransform_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.LocationTolerance = LocationTolerance;
	Parms.RotationTolerance = RotationTolerance;
	Parms.Scale3DTolerance = Scale3DTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "NearlyEqual_FloatFloat");

	Params::UKismetMathLibrary_NearlyEqual_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Base                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Exp                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MultiplyMultiply_FloatFloat(float Base, float Exp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MultiplyMultiply_FloatFloat");

	Params::UKismetMathLibrary_MultiplyMultiply_FloatFloat_Params Parms{};

	Parms.Base = Base;
	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MultiplyByPi
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MultiplyByPi(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MultiplyByPi");

	Params::UKismetMathLibrary_MultiplyByPi_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Multiply_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_VectorVector");

	Params::UKismetMathLibrary_Multiply_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Multiply_VectorInt(const struct FVector& A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_VectorInt");

	Params::UKismetMathLibrary_Multiply_VectorInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Multiply_VectorFloat(const struct FVector& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_VectorFloat");

	Params::UKismetMathLibrary_Multiply_VectorFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Multiply_Vector4Vector4(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_Vector4Vector4");

	Params::UKismetMathLibrary_Multiply_Vector4Vector4_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Multiply_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_Vector2DVector2D");

	Params::UKismetMathLibrary_Multiply_Vector2DVector2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Multiply_Vector2DFloat(const struct FVector2D& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_Vector2DFloat");

	Params::UKismetMathLibrary_Multiply_Vector2DFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_TimespanFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scalar                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Multiply_TimespanFloat(const struct FTimespan& A, float Scalar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_TimespanFloat");

	Params::UKismetMathLibrary_Multiply_TimespanFloat_Params Parms{};

	Parms.A = A;
	Parms.Scalar = Scalar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_RotatorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Multiply_RotatorInt(const struct FRotator& A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_RotatorInt");

	Params::UKismetMathLibrary_Multiply_RotatorInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_RotatorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Multiply_RotatorFloat(const struct FRotator& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_RotatorFloat");

	Params::UKismetMathLibrary_Multiply_RotatorFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Multiply_QuatQuat(struct FQuat& A, struct FQuat& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_QuatQuat");

	Params::UKismetMathLibrary_Multiply_QuatQuat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Multiply_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_LinearColorLinearColor");

	Params::UKismetMathLibrary_Multiply_LinearColorLinearColor_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_LinearColorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Multiply_LinearColorFloat(const struct FLinearColor& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_LinearColorFloat");

	Params::UKismetMathLibrary_Multiply_LinearColorFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Multiply_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_IntInt");

	Params::UKismetMathLibrary_Multiply_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_IntFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Multiply_IntFloat(int32 A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_IntFloat");

	Params::UKismetMathLibrary_Multiply_IntFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Multiply_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_Int64Int64");

	Params::UKismetMathLibrary_Multiply_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Multiply_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_FloatFloat");

	Params::UKismetMathLibrary_Multiply_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Multiply_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Multiply_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Multiply_ByteByte");

	Params::UKismetMathLibrary_Multiply_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MirrorVectorByNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVect                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InNormal                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::MirrorVectorByNormal(const struct FVector& InVect, const struct FVector& InNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MirrorVectorByNormal");

	Params::UKismetMathLibrary_MirrorVectorByNormal_Params Parms{};

	Parms.InVect = InVect;
	Parms.InNormal = InNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MinOfIntArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      IntArray                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              IndexOfMinValue                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MinOfIntArray(TArray<int32>& IntArray, int32* IndexOfMinValue, int32* MinValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MinOfIntArray");

	Params::UKismetMathLibrary_MinOfIntArray_Params Parms{};

	Parms.IntArray = IntArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = Parms.IndexOfMinValue;

	if (MinValue != nullptr)
		*MinValue = Parms.MinValue;

}


// Function Engine.KismetMathLibrary.MinOfFloatArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                      FloatArray                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              IndexOfMinValue                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MinValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MinOfFloatArray(TArray<float>& FloatArray, int32* IndexOfMinValue, float* MinValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MinOfFloatArray");

	Params::UKismetMathLibrary_MinOfFloatArray_Params Parms{};

	Parms.FloatArray = FloatArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = Parms.IndexOfMinValue;

	if (MinValue != nullptr)
		*MinValue = Parms.MinValue;

}


// Function Engine.KismetMathLibrary.MinOfByteArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                      ByteArray                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              IndexOfMinValue                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              MinValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MinOfByteArray(TArray<uint8>& ByteArray, int32* IndexOfMinValue, uint8* MinValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MinOfByteArray");

	Params::UKismetMathLibrary_MinOfByteArray_Params Parms{};

	Parms.ByteArray = ByteArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = Parms.IndexOfMinValue;

	if (MinValue != nullptr)
		*MinValue = Parms.MinValue;

}


// Function Engine.KismetMathLibrary.MinInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::MinInt64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MinInt64");

	Params::UKismetMathLibrary_MinInt64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MinimumAreaRectangle
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>             InVerts                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                     SampleSurfaceNormal                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutRectCenter                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    OutRectRotation                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              OutSideLengthX                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutSideLengthY                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDebugDraw                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MinimumAreaRectangle(class UObject* WorldContextObject, TArray<struct FVector>& InVerts, struct FVector& SampleSurfaceNormal, struct FVector* OutRectCenter, struct FRotator* OutRectRotation, float* OutSideLengthX, float* OutSideLengthY, bool bDebugDraw)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MinimumAreaRectangle");

	Params::UKismetMathLibrary_MinimumAreaRectangle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InVerts = InVerts;
	Parms.SampleSurfaceNormal = SampleSurfaceNormal;
	Parms.bDebugDraw = bDebugDraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutRectCenter != nullptr)
		*OutRectCenter = std::move(Parms.OutRectCenter);

	if (OutRectRotation != nullptr)
		*OutRectRotation = std::move(Parms.OutRectRotation);

	if (OutSideLengthX != nullptr)
		*OutSideLengthX = Parms.OutSideLengthX;

	if (OutSideLengthY != nullptr)
		*OutSideLengthY = Parms.OutSideLengthY;

}


// Function Engine.KismetMathLibrary.min
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Min(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "min");

	Params::UKismetMathLibrary_Min_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MaxOfIntArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                      IntArray                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              IndexOfMaxValue                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaxValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MaxOfIntArray(TArray<int32>& IntArray, int32* IndexOfMaxValue, int32* MaxValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MaxOfIntArray");

	Params::UKismetMathLibrary_MaxOfIntArray_Params Parms{};

	Parms.IntArray = IntArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = Parms.IndexOfMaxValue;

	if (MaxValue != nullptr)
		*MaxValue = Parms.MaxValue;

}


// Function Engine.KismetMathLibrary.MaxOfFloatArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                      FloatArray                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              IndexOfMaxValue                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MaxOfFloatArray(TArray<float>& FloatArray, int32* IndexOfMaxValue, float* MaxValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MaxOfFloatArray");

	Params::UKismetMathLibrary_MaxOfFloatArray_Params Parms{};

	Parms.FloatArray = FloatArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = Parms.IndexOfMaxValue;

	if (MaxValue != nullptr)
		*MaxValue = Parms.MaxValue;

}


// Function Engine.KismetMathLibrary.MaxOfByteArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                      ByteArray                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                              IndexOfMaxValue                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              MaxValue                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MaxOfByteArray(TArray<uint8>& ByteArray, int32* IndexOfMaxValue, uint8* MaxValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MaxOfByteArray");

	Params::UKismetMathLibrary_MaxOfByteArray_Params Parms{};

	Parms.ByteArray = ByteArray;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = Parms.IndexOfMaxValue;

	if (MaxValue != nullptr)
		*MaxValue = Parms.MaxValue;

}


// Function Engine.KismetMathLibrary.MaxInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::MaxInt64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MaxInt64");

	Params::UKismetMathLibrary_MaxInt64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.max
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Max(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "max");

	Params::UKismetMathLibrary_Max_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Matrix_GetOrigin
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                     InMatrix                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Matrix_GetOrigin(struct FMatrix& InMatrix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Matrix_GetOrigin");

	Params::UKismetMathLibrary_Matrix_GetOrigin_Params Parms{};

	Parms.InMatrix = InMatrix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MapRangeUnclamped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRangeA                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRangeB                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutRangeA                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutRangeB                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MapRangeUnclamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MapRangeUnclamped");

	Params::UKismetMathLibrary_MapRangeUnclamped_Params Parms{};

	Parms.Value = Value;
	Parms.InRangeA = InRangeA;
	Parms.InRangeB = InRangeB;
	Parms.OutRangeA = OutRangeA;
	Parms.OutRangeB = OutRangeB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MapRangeClamped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRangeA                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InRangeB                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutRangeA                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutRangeB                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MapRangeClamped");

	Params::UKismetMathLibrary_MapRangeClamped_Params Parms{};

	Parms.Value = Value;
	Parms.InRangeA = InRangeA;
	Parms.InRangeB = InRangeB;
	Parms.OutRangeA = OutRangeA;
	Parms.OutRangeB = OutRangeB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeVector4
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              W                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::MakeVector4(float X, float Y, float Z, float W)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeVector4");

	Params::UKismetMathLibrary_MakeVector4_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.W = W;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::MakeVector2D(float X, float Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeVector2D");

	Params::UKismetMathLibrary_MakeVector2D_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::MakeVector(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeVector");

	Params::UKismetMathLibrary_MakeVector_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::MakeTransform(const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeTransform");

	Params::UKismetMathLibrary_MakeTransform_Params Parms{};

	Parms.Location = Location;
	Parms.Rotation = Rotation;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeTimespan2
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Days                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Hours                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Minutes                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Seconds                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              FractionNano                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::MakeTimespan2(int32 Days, int32 Hours, int32 Minutes, int32 Seconds, int32 FractionNano)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeTimespan2");

	Params::UKismetMathLibrary_MakeTimespan2_Params Parms{};

	Parms.Days = Days;
	Parms.Hours = Hours;
	Parms.Minutes = Minutes;
	Parms.Seconds = Seconds;
	Parms.FractionNano = FractionNano;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Days                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Hours                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Minutes                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Seconds                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Milliseconds                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::MakeTimespan(int32 Days, int32 Hours, int32 Minutes, int32 Seconds, int32 Milliseconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeTimespan");

	Params::UKismetMathLibrary_MakeTimespan_Params Parms{};

	Parms.Days = Days;
	Parms.Hours = Hours;
	Parms.Minutes = Minutes;
	Parms.Seconds = Seconds;
	Parms.Milliseconds = Milliseconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromZY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Z                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Y                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromZY(struct FVector& Z, struct FVector& Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromZY");

	Params::UKismetMathLibrary_MakeRotFromZY_Params Parms{};

	Parms.Z = Z;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromZX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Z                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     X                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromZX(struct FVector& Z, struct FVector& X)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromZX");

	Params::UKismetMathLibrary_MakeRotFromZX_Params Parms{};

	Parms.Z = Z;
	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromZ
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Z                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromZ(struct FVector& Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromZ");

	Params::UKismetMathLibrary_MakeRotFromZ_Params Parms{};

	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromYZ
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Y                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Z                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromYZ(struct FVector& Y, struct FVector& Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromYZ");

	Params::UKismetMathLibrary_MakeRotFromYZ_Params Parms{};

	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromYX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Y                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     X                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromYX(struct FVector& Y, struct FVector& X)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromYX");

	Params::UKismetMathLibrary_MakeRotFromYX_Params Parms{};

	Parms.Y = Y;
	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Y                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromY(struct FVector& Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromY");

	Params::UKismetMathLibrary_MakeRotFromY_Params Parms{};

	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromXZ
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     X                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Z                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromXZ(struct FVector& X, struct FVector& Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromXZ");

	Params::UKismetMathLibrary_MakeRotFromXZ_Params Parms{};

	Parms.X = X;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromXY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     X                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Y                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromXY(struct FVector& X, struct FVector& Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromXY");

	Params::UKismetMathLibrary_MakeRotFromXY_Params Parms{};

	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotFromX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     X                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromX(struct FVector& X)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotFromX");

	Params::UKismetMathLibrary_MakeRotFromX_Params Parms{};

	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Roll                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Pitch                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Yaw                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotator(float Roll, float Pitch, float Yaw)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotator");

	Params::UKismetMathLibrary_MakeRotator_Params Parms{};

	Parms.Roll = Roll;
	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRotationFromAxes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Forward                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Right                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Up                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotationFromAxes(const struct FVector& Forward, const struct FVector& Right, const struct FVector& Up)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRotationFromAxes");

	Params::UKismetMathLibrary_MakeRotationFromAxes_Params Parms{};

	Parms.Forward = Forward;
	Parms.Right = Right;
	Parms.Up = Up;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRelativeTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  RelativeTo                                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::MakeRelativeTransform(struct FTransform& A, struct FTransform& RelativeTo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRelativeTransform");

	Params::UKismetMathLibrary_MakeRelativeTransform_Params Parms{};

	Parms.A = A;
	Parms.RelativeTo = RelativeTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeRandomStream
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InitialSeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRandomStream UKismetMathLibrary::MakeRandomStream(int32 InitialSeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeRandomStream");

	Params::UKismetMathLibrary_MakeRandomStream_Params Parms{};

	Parms.InitialSeed = InitialSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeQualifiedFrameTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFrameNumber                Frame                                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameRate                  FrameRate                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SubFrame                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQualifiedFrameTime         ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQualifiedFrameTime UKismetMathLibrary::MakeQualifiedFrameTime(const struct FFrameNumber& Frame, const struct FFrameRate& FrameRate, float SubFrame)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeQualifiedFrameTime");

	Params::UKismetMathLibrary_MakeQualifiedFrameTime_Params Parms{};

	Parms.Frame = Frame;
	Parms.FrameRate = FrameRate;
	Parms.SubFrame = SubFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakePulsatingValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InCurrentTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPulsesPerSecond                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InPhase                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakePulsatingValue");

	Params::UKismetMathLibrary_MakePulsatingValue_Params Parms{};

	Parms.InCurrentTime = InCurrentTime;
	Parms.InPulsesPerSecond = InPulsesPerSecond;
	Parms.InPhase = InPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakePlaneFromPointAndNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Normal                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FPlane UKismetMathLibrary::MakePlaneFromPointAndNormal(const struct FVector& Point, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakePlaneFromPointAndNormal");

	Params::UKismetMathLibrary_MakePlaneFromPointAndNormal_Params Parms{};

	Parms.Point = Point;
	Parms.Normal = Normal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeFrameRate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Numerator                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Denominator                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameRate                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFrameRate UKismetMathLibrary::MakeFrameRate(int32 Numerator, int32 Denominator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeFrameRate");

	Params::UKismetMathLibrary_MakeFrameRate_Params Parms{};

	Parms.Numerator = Numerator;
	Parms.Denominator = Denominator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Year                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Month                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Day                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Hour                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Minute                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Second                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Millisecond                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::MakeDateTime(int32 Year, int32 Month, int32 Day, int32 Hour, int32 Minute, int32 Second, int32 Millisecond)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeDateTime");

	Params::UKismetMathLibrary_MakeDateTime_Params Parms{};

	Parms.Year = Year;
	Parms.Month = Month;
	Parms.Day = Day;
	Parms.Hour = Hour;
	Parms.Minute = Minute;
	Parms.Second = Second;
	Parms.Millisecond = Millisecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              R                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              G                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::MakeColor(float R, float G, float B, float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeColor");

	Params::UKismetMathLibrary_MakeColor_Params Parms{};

	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeBox2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBox2D UKismetMathLibrary::MakeBox2D(const struct FVector2D& Min, const struct FVector2D& Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeBox2D");

	Params::UKismetMathLibrary_MakeBox2D_Params Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.MakeBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UKismetMathLibrary::MakeBox(const struct FVector& Min, const struct FVector& Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "MakeBox");

	Params::UKismetMathLibrary_MakeBox_Params Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Loge
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Loge(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Loge");

	Params::UKismetMathLibrary_Loge_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Log
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Base                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Log(float A, float Base)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Log");

	Params::UKismetMathLibrary_Log_Params Parms{};

	Parms.A = A;
	Parms.Base = Base;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     LineStart                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineEnd                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PlaneOrigin                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PlaneNormal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              T                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Intersection                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LinePlaneIntersection_OriginNormal(struct FVector& LineStart, struct FVector& LineEnd, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal, float* T, struct FVector* Intersection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinePlaneIntersection_OriginNormal");

	Params::UKismetMathLibrary_LinePlaneIntersection_OriginNormal_Params Parms{};

	Parms.LineStart = LineStart;
	Parms.LineEnd = LineEnd;
	Parms.PlaneOrigin = PlaneOrigin;
	Parms.PlaneNormal = PlaneNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (T != nullptr)
		*T = Parms.T;

	if (Intersection != nullptr)
		*Intersection = std::move(Parms.Intersection);

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinePlaneIntersection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     LineStart                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineEnd                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                      APlane                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              T                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Intersection                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LinePlaneIntersection(struct FVector& LineStart, struct FVector& LineEnd, struct FPlane& APlane, float* T, struct FVector* Intersection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinePlaneIntersection");

	Params::UKismetMathLibrary_LinePlaneIntersection_Params Parms{};

	Parms.LineStart = LineStart;
	Parms.LineEnd = LineEnd;
	Parms.APlane = APlane;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (T != nullptr)
		*T = Parms.T;

	if (Intersection != nullptr)
		*Intersection = std::move(Parms.Intersection);

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColorLerpUsingHSV(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColorLerpUsingHSV");

	Params::UKismetMathLibrary_LinearColorLerpUsingHSV_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColorLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColorLerp(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColorLerp");

	Params::UKismetMathLibrary_LinearColorLerp_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Yellow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Yellow()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Yellow");

	Params::UKismetMathLibrary_LinearColor_Yellow_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_White
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_White()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_White");

	Params::UKismetMathLibrary_LinearColor_White_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Transparent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Transparent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Transparent");

	Params::UKismetMathLibrary_LinearColor_Transparent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_ToRGBE
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InLinearColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetMathLibrary::LinearColor_ToRGBE(const struct FLinearColor& InLinearColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_ToRGBE");

	Params::UKismetMathLibrary_LinearColor_ToRGBE_Params Parms{};

	Parms.InLinearColor = InLinearColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_ToNewOpacity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InOpacity                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_ToNewOpacity(const struct FLinearColor& InColor, float InOpacity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_ToNewOpacity");

	Params::UKismetMathLibrary_LinearColor_ToNewOpacity_Params Parms{};

	Parms.InColor = InColor;
	Parms.InOpacity = InOpacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_SetTemperature
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                InOutColor                                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InTemperature                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetTemperature(struct FLinearColor& InOutColor, float InTemperature)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_SetTemperature");

	Params::UKismetMathLibrary_LinearColor_SetTemperature_Params Parms{};

	Parms.InOutColor = InOutColor;
	Parms.InTemperature = InTemperature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.LinearColor_SetRGBA
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                InOutColor                                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              R                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              G                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetRGBA(struct FLinearColor& InOutColor, float R, float G, float B, float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_SetRGBA");

	Params::UKismetMathLibrary_LinearColor_SetRGBA_Params Parms{};

	Parms.InOutColor = InOutColor;
	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.LinearColor_SetRandomHue
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                InOutColor                                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetRandomHue(struct FLinearColor& InOutColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_SetRandomHue");

	Params::UKismetMathLibrary_LinearColor_SetRandomHue_Params Parms{};

	Parms.InOutColor = InOutColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.LinearColor_SetFromSRGB
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                InOutColor                                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      InSRGB                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetFromSRGB(struct FLinearColor& InOutColor, struct FColor& InSRGB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_SetFromSRGB");

	Params::UKismetMathLibrary_LinearColor_SetFromSRGB_Params Parms{};

	Parms.InOutColor = InOutColor;
	Parms.InSRGB = InSRGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.LinearColor_SetFromPow22
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                InOutColor                                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      InColor                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetFromPow22(struct FLinearColor& InOutColor, struct FColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_SetFromPow22");

	Params::UKismetMathLibrary_LinearColor_SetFromPow22_Params Parms{};

	Parms.InOutColor = InOutColor;
	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.LinearColor_SetFromHSV
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                InOutColor                                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              H                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              S                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              V                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetFromHSV(struct FLinearColor& InOutColor, float H, float S, float V, float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_SetFromHSV");

	Params::UKismetMathLibrary_LinearColor_SetFromHSV_Params Parms{};

	Parms.InOutColor = InOutColor;
	Parms.H = H;
	Parms.S = S;
	Parms.V = V;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.LinearColor_Set
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                InOutColor                                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_Set(struct FLinearColor& InOutColor, const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Set");

	Params::UKismetMathLibrary_LinearColor_Set_Params Parms{};

	Parms.InOutColor = InOutColor;
	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetMathLibrary.LinearColor_Red
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Red()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Red");

	Params::UKismetMathLibrary_LinearColor_Red_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_QuantizeRound
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetMathLibrary::LinearColor_QuantizeRound(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_QuantizeRound");

	Params::UKismetMathLibrary_LinearColor_QuantizeRound_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Quantize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetMathLibrary::LinearColor_Quantize(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Quantize");

	Params::UKismetMathLibrary_LinearColor_Quantize_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_IsNearEqual
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LinearColor_IsNearEqual(const struct FLinearColor& A, const struct FLinearColor& B, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_IsNearEqual");

	Params::UKismetMathLibrary_LinearColor_IsNearEqual_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Green
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Green()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Green");

	Params::UKismetMathLibrary_LinearColor_Green_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Gray
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Gray()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Gray");

	Params::UKismetMathLibrary_LinearColor_Gray_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_GetMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::LinearColor_GetMin(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_GetMin");

	Params::UKismetMathLibrary_LinearColor_GetMin_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_GetMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::LinearColor_GetMax(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_GetMax");

	Params::UKismetMathLibrary_LinearColor_GetMax_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_GetLuminance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::LinearColor_GetLuminance(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_GetLuminance");

	Params::UKismetMathLibrary_LinearColor_GetLuminance_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Distance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                C1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                C2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::LinearColor_Distance(const struct FLinearColor& C1, const struct FLinearColor& C2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Distance");

	Params::UKismetMathLibrary_LinearColor_Distance_Params Parms{};

	Parms.C1 = C1;
	Parms.C2 = C2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Desaturated
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDesaturation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Desaturated(const struct FLinearColor& InColor, float InDesaturation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Desaturated");

	Params::UKismetMathLibrary_LinearColor_Desaturated_Params Parms{};

	Parms.InColor = InColor;
	Parms.InDesaturation = InDesaturation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Blue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Blue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Blue");

	Params::UKismetMathLibrary_LinearColor_Blue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LinearColor_Black
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Black()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LinearColor_Black");

	Params::UKismetMathLibrary_LinearColor_Black_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LessLess_VectorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::LessLess_VectorRotator(const struct FVector& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LessLess_VectorRotator");

	Params::UKismetMathLibrary_LessLess_VectorRotator_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LessEqual_TimespanTimespan");

	Params::UKismetMathLibrary_LessEqual_TimespanTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LessEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LessEqual_IntInt");

	Params::UKismetMathLibrary_LessEqual_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LessEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LessEqual_Int64Int64");

	Params::UKismetMathLibrary_LessEqual_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LessEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LessEqual_FloatFloat");

	Params::UKismetMathLibrary_LessEqual_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LessEqual_DateTimeDateTime");

	Params::UKismetMathLibrary_LessEqual_DateTimeDateTime_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.LessEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "LessEqual_ByteByte");

	Params::UKismetMathLibrary_LessEqual_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Less_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Less_TimespanTimespan");

	Params::UKismetMathLibrary_Less_TimespanTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Less_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Less_IntInt");

	Params::UKismetMathLibrary_Less_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Less_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Less_Int64Int64");

	Params::UKismetMathLibrary_Less_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Less_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Less_FloatFloat");

	Params::UKismetMathLibrary_Less_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Less_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Less_DateTimeDateTime");

	Params::UKismetMathLibrary_Less_DateTimeDateTime_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Less_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Less_ByteByte");

	Params::UKismetMathLibrary_Less_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Lerp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Lerp(float A, float B, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Lerp");

	Params::UKismetMathLibrary_Lerp_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.IsZero2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsZero2D(struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "IsZero2D");

	Params::UKismetMathLibrary_IsZero2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.IsPointInBoxWithTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  BoxWorldTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     BoxExtent                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsPointInBoxWithTransform(const struct FVector& Point, struct FTransform& BoxWorldTransform, const struct FVector& BoxExtent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "IsPointInBoxWithTransform");

	Params::UKismetMathLibrary_IsPointInBoxWithTransform_Params Parms{};

	Parms.Point = Point;
	Parms.BoxWorldTransform = BoxWorldTransform;
	Parms.BoxExtent = BoxExtent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.IsPointInBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxOrigin                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxExtent                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsPointInBox(const struct FVector& Point, const struct FVector& BoxOrigin, const struct FVector& BoxExtent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "IsPointInBox");

	Params::UKismetMathLibrary_IsPointInBox_Params Parms{};

	Parms.Point = Point;
	Parms.BoxOrigin = BoxOrigin;
	Parms.BoxExtent = BoxExtent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.IsNearlyZero2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsNearlyZero2D(struct FVector2D& A, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "IsNearlyZero2D");

	Params::UKismetMathLibrary_IsNearlyZero2D_Params Parms{};

	Parms.A = A;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.IsMorning
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsMorning(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "IsMorning");

	Params::UKismetMathLibrary_IsMorning_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.IsLeapYear
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Year                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsLeapYear(int32 Year)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "IsLeapYear");

	Params::UKismetMathLibrary_IsLeapYear_Params Parms{};

	Parms.Year = Year;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.IsAfternoon
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsAfternoon(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "IsAfternoon");

	Params::UKismetMathLibrary_IsAfternoon_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.InvertTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  T                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::InvertTransform(struct FTransform& T)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "InvertTransform");

	Params::UKismetMathLibrary_InvertTransform_Params Parms{};

	Parms.T = T;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.InverseTransformRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  T                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::InverseTransformRotation(struct FTransform& T, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "InverseTransformRotation");

	Params::UKismetMathLibrary_InverseTransformRotation_Params Parms{};

	Parms.T = T;
	Parms.Rotation = Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.InverseTransformLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  T                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::InverseTransformLocation(struct FTransform& T, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "InverseTransformLocation");

	Params::UKismetMathLibrary_InverseTransformLocation_Params Parms{};

	Parms.T = T;
	Parms.Location = Location;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.InverseTransformDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  T                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Direction                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::InverseTransformDirection(struct FTransform& T, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "InverseTransformDirection");

	Params::UKismetMathLibrary_InverseTransformDirection_Params Parms{};

	Parms.T = T;
	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.InRange_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InclusiveMin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InclusiveMax                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::InRange_IntInt(int32 Value, int32 Min, int32 Max, bool InclusiveMin, bool InclusiveMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "InRange_IntInt");

	Params::UKismetMathLibrary_InRange_IntInt_Params Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.InclusiveMin = InclusiveMin;
	Parms.InclusiveMax = InclusiveMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.InRange_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InclusiveMin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InclusiveMax                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::InRange_Int64Int64(int64 Value, int64 Min, int64 Max, bool InclusiveMin, bool InclusiveMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "InRange_Int64Int64");

	Params::UKismetMathLibrary_InRange_Int64Int64_Params Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.InclusiveMin = InclusiveMin;
	Parms.InclusiveMax = InclusiveMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.InRange_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InclusiveMin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InclusiveMax                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::InRange_FloatFloat(float Value, float Min, float Max, bool InclusiveMin, bool InclusiveMax)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "InRange_FloatFloat");

	Params::UKismetMathLibrary_InRange_FloatFloat_Params Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.InclusiveMin = InclusiveMin;
	Parms.InclusiveMax = InclusiveMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Hypotenuse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Width                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Height                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Hypotenuse(float Width, float Height)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Hypotenuse");

	Params::UKismetMathLibrary_Hypotenuse_Params Parms{};

	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.HSVToRGBLinear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                HSV                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::HSVToRGBLinear(const struct FLinearColor& HSV)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "HSVToRGBLinear");

	Params::UKismetMathLibrary_HSVToRGBLinear_Params Parms{};

	Parms.HSV = HSV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.HSVToRGB_Vector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                HSV                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                RGB                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::HSVToRGB_Vector(const struct FLinearColor& HSV, struct FLinearColor* RGB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "HSVToRGB_Vector");

	Params::UKismetMathLibrary_HSVToRGB_Vector_Params Parms{};

	Parms.HSV = HSV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (RGB != nullptr)
		*RGB = std::move(Parms.RGB);

}


// Function Engine.KismetMathLibrary.HSVToRGB
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              H                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              S                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              V                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::HSVToRGB(float H, float S, float V, float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "HSVToRGB");

	Params::UKismetMathLibrary_HSVToRGB_Params Parms{};

	Parms.H = H;
	Parms.S = S;
	Parms.V = V;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GridSnap_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              GridSize                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GridSnap_Float(float Location, float GridSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GridSnap_Float");

	Params::UKismetMathLibrary_GridSnap_Float_Params Parms{};

	Parms.Location = Location;
	Parms.GridSize = GridSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GreaterGreater_VectorRotator(const struct FVector& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GreaterGreater_VectorRotator");

	Params::UKismetMathLibrary_GreaterGreater_VectorRotator_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GreaterEqual_TimespanTimespan");

	Params::UKismetMathLibrary_GreaterEqual_TimespanTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GreaterEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GreaterEqual_IntInt");

	Params::UKismetMathLibrary_GreaterEqual_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GreaterEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GreaterEqual_Int64Int64");

	Params::UKismetMathLibrary_GreaterEqual_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GreaterEqual_FloatFloat");

	Params::UKismetMathLibrary_GreaterEqual_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GreaterEqual_DateTimeDateTime");

	Params::UKismetMathLibrary_GreaterEqual_DateTimeDateTime_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GreaterEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GreaterEqual_ByteByte");

	Params::UKismetMathLibrary_GreaterEqual_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Greater_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Greater_TimespanTimespan");

	Params::UKismetMathLibrary_Greater_TimespanTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Greater_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Greater_IntInt");

	Params::UKismetMathLibrary_Greater_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Greater_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Greater_Int64Int64");

	Params::UKismetMathLibrary_Greater_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Greater_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Greater_FloatFloat");

	Params::UKismetMathLibrary_Greater_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Greater_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Greater_DateTimeDateTime");

	Params::UKismetMathLibrary_Greater_DateTimeDateTime_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Greater_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Greater_ByteByte");

	Params::UKismetMathLibrary_Greater_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetYear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetYear(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetYear");

	Params::UKismetMathLibrary_GetYear_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetYawPitchFromVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Yaw                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Pitch                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::GetYawPitchFromVector(const struct FVector& InVec, float* Yaw, float* Pitch)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetYawPitchFromVector");

	Params::UKismetMathLibrary_GetYawPitchFromVector_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Yaw != nullptr)
		*Yaw = Parms.Yaw;

	if (Pitch != nullptr)
		*Pitch = Parms.Pitch;

}


// Function Engine.KismetMathLibrary.GetVectorArrayAverage
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>             Vectors                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetVectorArrayAverage(TArray<struct FVector>& Vectors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetVectorArrayAverage");

	Params::UKismetMathLibrary_GetVectorArrayAverage_Params Parms{};

	Parms.Vectors = Vectors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetUpVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetUpVector(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetUpVector");

	Params::UKismetMathLibrary_GetUpVector_Params Parms{};

	Parms.InRot = InRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetTotalSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalSeconds(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetTotalSeconds");

	Params::UKismetMathLibrary_GetTotalSeconds_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetTotalMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalMinutes(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetTotalMinutes");

	Params::UKismetMathLibrary_GetTotalMinutes_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetTotalMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalMilliseconds(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetTotalMilliseconds");

	Params::UKismetMathLibrary_GetTotalMilliseconds_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetTotalHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalHours(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetTotalHours");

	Params::UKismetMathLibrary_GetTotalHours_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetTotalDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalDays(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetTotalDays");

	Params::UKismetMathLibrary_GetTotalDays_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetTimeOfDay
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::GetTimeOfDay(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetTimeOfDay");

	Params::UKismetMathLibrary_GetTimeOfDay_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetTAU
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTAU()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetTAU");

	Params::UKismetMathLibrary_GetTAU_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetSlopeDegreeAngles
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     MyRightYAxis                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     FloorNormal                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     UpVector                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutSlopePitchDegreeAngle                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutSlopeRollDegreeAngle                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::GetSlopeDegreeAngles(struct FVector& MyRightYAxis, struct FVector& FloorNormal, struct FVector& UpVector, float* OutSlopePitchDegreeAngle, float* OutSlopeRollDegreeAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetSlopeDegreeAngles");

	Params::UKismetMathLibrary_GetSlopeDegreeAngles_Params Parms{};

	Parms.MyRightYAxis = MyRightYAxis;
	Parms.FloorNormal = FloorNormal;
	Parms.UpVector = UpVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSlopePitchDegreeAngle != nullptr)
		*OutSlopePitchDegreeAngle = Parms.OutSlopePitchDegreeAngle;

	if (OutSlopeRollDegreeAngle != nullptr)
		*OutSlopeRollDegreeAngle = Parms.OutSlopeRollDegreeAngle;

}


// Function Engine.KismetMathLibrary.GetSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetSeconds(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetSeconds");

	Params::UKismetMathLibrary_GetSeconds_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetSecond
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetSecond(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetSecond");

	Params::UKismetMathLibrary_GetSecond_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetRotated2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AngleDeg                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::GetRotated2D(const struct FVector2D& A, float AngleDeg)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetRotated2D");

	Params::UKismetMathLibrary_GetRotated2D_Params Parms{};

	Parms.A = A;
	Parms.AngleDeg = AngleDeg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetRightVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetRightVector(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetRightVector");

	Params::UKismetMathLibrary_GetRightVector_Params Parms{};

	Parms.InRot = InRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetReflectionVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Direction                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SurfaceNormal                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetReflectionVector(const struct FVector& Direction, const struct FVector& SurfaceNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetReflectionVector");

	Params::UKismetMathLibrary_GetReflectionVector_Params Parms{};

	Parms.Direction = Direction;
	Parms.SurfaceNormal = SurfaceNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetPointDistanceToSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SegmentStart                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SegmentEnd                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetPointDistanceToSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetPointDistanceToSegment");

	Params::UKismetMathLibrary_GetPointDistanceToSegment_Params Parms{};

	Parms.Point = Point;
	Parms.SegmentStart = SegmentStart;
	Parms.SegmentEnd = SegmentEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetPointDistanceToLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineOrigin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineDirection                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetPointDistanceToLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetPointDistanceToLine");

	Params::UKismetMathLibrary_GetPointDistanceToLine_Params Parms{};

	Parms.Point = Point;
	Parms.LineOrigin = LineOrigin;
	Parms.LineDirection = LineDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetPI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetPI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetPI");

	Params::UKismetMathLibrary_GetPI_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMonth
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMonth(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMonth");

	Params::UKismetMathLibrary_GetMonth_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMinutes(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMinutes");

	Params::UKismetMathLibrary_GetMinutes_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMinute
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMinute(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMinute");

	Params::UKismetMathLibrary_GetMinute_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMinElement
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetMinElement(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMinElement");

	Params::UKismetMathLibrary_GetMinElement_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMin2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetMin2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMin2D");

	Params::UKismetMathLibrary_GetMin2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMilliseconds(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMilliseconds");

	Params::UKismetMathLibrary_GetMilliseconds_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMillisecond
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMillisecond(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMillisecond");

	Params::UKismetMathLibrary_GetMillisecond_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMaxElement
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetMaxElement(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMaxElement");

	Params::UKismetMathLibrary_GetMaxElement_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetMax2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetMax2D");

	Params::UKismetMathLibrary_GetMax2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetHours(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetHours");

	Params::UKismetMathLibrary_GetHours_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetHour12
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetHour12(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetHour12");

	Params::UKismetMathLibrary_GetHour12_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetHour
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetHour(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetHour");

	Params::UKismetMathLibrary_GetHour_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetForwardVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetForwardVector(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetForwardVector");

	Params::UKismetMathLibrary_GetForwardVector_Params Parms{};

	Parms.InRot = InRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetDuration
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::GetDuration(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetDuration");

	Params::UKismetMathLibrary_GetDuration_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetDirectionUnitVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     From                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     To                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetDirectionUnitVector(const struct FVector& From, const struct FVector& To)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetDirectionUnitVector");

	Params::UKismetMathLibrary_GetDirectionUnitVector_Params Parms{};

	Parms.From = From;
	Parms.To = To;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetDays(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetDays");

	Params::UKismetMathLibrary_GetDays_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetDayOfYear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetDayOfYear(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetDayOfYear");

	Params::UKismetMathLibrary_GetDayOfYear_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetDay
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetDay(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetDay");

	Params::UKismetMathLibrary_GetDay_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetDate
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::GetDate(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetDate");

	Params::UKismetMathLibrary_GetDate_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetAzimuthAndElevation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InDirection                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReferenceFrame                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Azimuth                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Elevation                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::GetAzimuthAndElevation(const struct FVector& InDirection, struct FTransform& ReferenceFrame, float* Azimuth, float* Elevation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetAzimuthAndElevation");

	Params::UKismetMathLibrary_GetAzimuthAndElevation_Params Parms{};

	Parms.InDirection = InDirection;
	Parms.ReferenceFrame = ReferenceFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Azimuth != nullptr)
		*Azimuth = Parms.Azimuth;

	if (Elevation != nullptr)
		*Elevation = Parms.Elevation;

}


// Function Engine.KismetMathLibrary.GetAxes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     X                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Y                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Z                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::GetAxes(const struct FRotator& A, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetAxes");

	Params::UKismetMathLibrary_GetAxes_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (X != nullptr)
		*X = std::move(Parms.X);

	if (Y != nullptr)
		*Y = std::move(Parms.Y);

	if (Z != nullptr)
		*Z = std::move(Parms.Z);

}


// Function Engine.KismetMathLibrary.GetAbsMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetAbsMax2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetAbsMax2D");

	Params::UKismetMathLibrary_GetAbsMax2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.GetAbs2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::GetAbs2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "GetAbs2D");

	Params::UKismetMathLibrary_GetAbs2D_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FTruncVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVector                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UKismetMathLibrary::FTruncVector(struct FVector& InVector)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FTruncVector");

	Params::UKismetMathLibrary_FTruncVector_Params Parms{};

	Parms.InVector = InVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FTrunc64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::FTrunc64(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FTrunc64");

	Params::UKismetMathLibrary_FTrunc64_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FTrunc
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::FTrunc(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FTrunc");

	Params::UKismetMathLibrary_FTrunc_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FromSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Seconds                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FromSeconds");

	Params::UKismetMathLibrary_FromSeconds_Params Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FromMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Minutes                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromMinutes(float Minutes)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FromMinutes");

	Params::UKismetMathLibrary_FromMinutes_Params Parms{};

	Parms.Minutes = Minutes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FromMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Milliseconds                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromMilliseconds(float Milliseconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FromMilliseconds");

	Params::UKismetMathLibrary_FromMilliseconds_Params Parms{};

	Parms.Milliseconds = Milliseconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FromHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Hours                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromHours(float Hours)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FromHours");

	Params::UKismetMathLibrary_FromHours_Params Parms{};

	Parms.Hours = Hours;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FromDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Days                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromDays(float Days)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FromDays");

	Params::UKismetMathLibrary_FromDays_Params Parms{};

	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Fraction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Fraction(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Fraction");

	Params::UKismetMathLibrary_Fraction_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FMod
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Dividend                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Divisor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Remainder                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::FMod(float Dividend, float Divisor, float* Remainder)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FMod");

	Params::UKismetMathLibrary_FMod_Params Parms{};

	Parms.Dividend = Dividend;
	Parms.Divisor = Divisor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Remainder != nullptr)
		*Remainder = Parms.Remainder;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FMin(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FMin");

	Params::UKismetMathLibrary_FMin_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FMax(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FMax");

	Params::UKismetMathLibrary_FMax_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FloatSpringInterp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                              Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloatSpringState           SpringState                                                      (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                              Stiffness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CriticalDampingFactor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Mass                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FloatSpringInterp(float Current, float Target, struct FFloatSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FloatSpringInterp");

	Params::UKismetMathLibrary_FloatSpringInterp_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.SpringState = SpringState;
	Parms.Stiffness = Stiffness;
	Parms.CriticalDampingFactor = CriticalDampingFactor;
	Parms.DeltaTime = DeltaTime;
	Parms.Mass = Mass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FixedTurn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InCurrent                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDesired                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InDeltaRate                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FixedTurn(float InCurrent, float InDesired, float InDeltaRate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FixedTurn");

	Params::UKismetMathLibrary_FixedTurn_Params Parms{};

	Parms.InCurrent = InCurrent;
	Parms.InDesired = InDesired;
	Parms.InDeltaRate = InDeltaRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FInterpTo_Constant
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FInterpTo_Constant(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FInterpTo_Constant");

	Params::UKismetMathLibrary_FInterpTo_Constant_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FInterpTo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FInterpTo");

	Params::UKismetMathLibrary_FInterpTo_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FInterpEaseInOut
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Exponent                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FInterpEaseInOut(float A, float B, float Alpha, float Exponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FInterpEaseInOut");

	Params::UKismetMathLibrary_FInterpEaseInOut_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.Exponent = Exponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FindNearestPointsOnLineSegments
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Segment1Start                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Segment1End                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Segment2Start                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Segment2End                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Segment1Point                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Segment2Point                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::FindNearestPointsOnLineSegments(const struct FVector& Segment1Start, const struct FVector& Segment1End, const struct FVector& Segment2Start, const struct FVector& Segment2End, struct FVector* Segment1Point, struct FVector* Segment2Point)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FindNearestPointsOnLineSegments");

	Params::UKismetMathLibrary_FindNearestPointsOnLineSegments_Params Parms{};

	Parms.Segment1Start = Segment1Start;
	Parms.Segment1End = Segment1End;
	Parms.Segment2Start = Segment2Start;
	Parms.Segment2End = Segment2End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Segment1Point != nullptr)
		*Segment1Point = std::move(Parms.Segment1Point);

	if (Segment2Point != nullptr)
		*Segment2Point = std::move(Parms.Segment2Point);

}


// Function Engine.KismetMathLibrary.FindLookAtRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Start                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Target                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::FindLookAtRotation(struct FVector& Start, struct FVector& Target)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FindLookAtRotation");

	Params::UKismetMathLibrary_FindLookAtRotation_Params Parms{};

	Parms.Start = Start;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FindClosestPointOnSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SegmentStart                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SegmentEnd                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::FindClosestPointOnSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FindClosestPointOnSegment");

	Params::UKismetMathLibrary_FindClosestPointOnSegment_Params Parms{};

	Parms.Point = Point;
	Parms.SegmentStart = SegmentStart;
	Parms.SegmentEnd = SegmentEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FindClosestPointOnLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     Point                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineOrigin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineDirection                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::FindClosestPointOnLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FindClosestPointOnLine");

	Params::UKismetMathLibrary_FindClosestPointOnLine_Params Parms{};

	Parms.Point = Point;
	Parms.LineOrigin = LineOrigin;
	Parms.LineDirection = LineDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FFloor64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::FFloor64(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FFloor64");

	Params::UKismetMathLibrary_FFloor64_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FFloor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::FFloor(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FFloor");

	Params::UKismetMathLibrary_FFloor_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FClamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FClamp(float Value, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FClamp");

	Params::UKismetMathLibrary_FClamp_Params Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FCeil64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::FCeil64(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FCeil64");

	Params::UKismetMathLibrary_FCeil64_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.FCeil
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::FCeil(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "FCeil");

	Params::UKismetMathLibrary_FCeil_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Exp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Exp(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Exp");

	Params::UKismetMathLibrary_Exp_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualExactly_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualExactly_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualExactly_VectorVector");

	Params::UKismetMathLibrary_EqualExactly_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualExactly_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualExactly_Vector4Vector4(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualExactly_Vector4Vector4");

	Params::UKismetMathLibrary_EqualExactly_Vector4Vector4_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualExactly_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualExactly_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualExactly_Vector2DVector2D");

	Params::UKismetMathLibrary_EqualExactly_Vector2DVector2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_VectorVector");

	Params::UKismetMathLibrary_EqualEqual_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_Vector4Vector4(struct FVector4& A, struct FVector4& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_Vector4Vector4");

	Params::UKismetMathLibrary_EqualEqual_Vector4Vector4_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_Vector2DVector2D");

	Params::UKismetMathLibrary_EqualEqual_Vector2DVector2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_TransformTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_TransformTransform(struct FTransform& A, struct FTransform& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_TransformTransform");

	Params::UKismetMathLibrary_EqualEqual_TransformTransform_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_TimespanTimespan");

	Params::UKismetMathLibrary_EqualEqual_TimespanTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              ErrorTolerance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_RotatorRotator");

	Params::UKismetMathLibrary_EqualEqual_RotatorRotator_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Tolerance                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_QuatQuat(struct FQuat& A, struct FQuat& B, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_QuatQuat");

	Params::UKismetMathLibrary_EqualEqual_QuatQuat_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_ObjectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_ObjectObject(class UObject* A, class UObject* B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_ObjectObject");

	Params::UKismetMathLibrary_EqualEqual_ObjectObject_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_NameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_NameName(class FName A, class FName B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_NameName");

	Params::UKismetMathLibrary_EqualEqual_NameName_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_LinearColorLinearColor");

	Params::UKismetMathLibrary_EqualEqual_LinearColorLinearColor_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_IntInt");

	Params::UKismetMathLibrary_EqualEqual_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_Int64Int64");

	Params::UKismetMathLibrary_EqualEqual_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_FloatFloat");

	Params::UKismetMathLibrary_EqualEqual_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_DateTimeDateTime");

	Params::UKismetMathLibrary_EqualEqual_DateTimeDateTime_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_ClassClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                      A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                      B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_ClassClass(class UClass* A, class UClass* B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_ClassClass");

	Params::UKismetMathLibrary_EqualEqual_ClassClass_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_ByteByte");

	Params::UKismetMathLibrary_EqualEqual_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.EqualEqual_BoolBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_BoolBool(bool A, bool B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "EqualEqual_BoolBool");

	Params::UKismetMathLibrary_EqualEqual_BoolBool_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Ease
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EEasingFunc             EasingFunc                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BlendExp                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Steps                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Ease(float A, float B, float Alpha, enum class EEasingFunc EasingFunc, float BlendExp, int32 Steps)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Ease");

	Params::UKismetMathLibrary_Ease_Params Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.EasingFunc = EasingFunc;
	Parms.BlendExp = BlendExp;
	Parms.Steps = Steps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DotProduct2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DotProduct2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DotProduct2D");

	Params::UKismetMathLibrary_DotProduct2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Dot_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Dot_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Dot_VectorVector");

	Params::UKismetMathLibrary_Dot_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Divide_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_VectorVector");

	Params::UKismetMathLibrary_Divide_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Divide_VectorInt(const struct FVector& A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_VectorInt");

	Params::UKismetMathLibrary_Divide_VectorInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Divide_VectorFloat(const struct FVector& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_VectorFloat");

	Params::UKismetMathLibrary_Divide_VectorFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Divide_Vector4Vector4(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_Vector4Vector4");

	Params::UKismetMathLibrary_Divide_Vector4Vector4_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Divide_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_Vector2DVector2D");

	Params::UKismetMathLibrary_Divide_Vector2DVector2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Divide_Vector2DFloat(const struct FVector2D& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_Vector2DFloat");

	Params::UKismetMathLibrary_Divide_Vector2DFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_TimespanFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Scalar                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Divide_TimespanFloat(const struct FTimespan& A, float Scalar)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_TimespanFloat");

	Params::UKismetMathLibrary_Divide_TimespanFloat_Params Parms{};

	Parms.A = A;
	Parms.Scalar = Scalar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Divide_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_LinearColorLinearColor");

	Params::UKismetMathLibrary_Divide_LinearColorLinearColor_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Divide_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_IntInt");

	Params::UKismetMathLibrary_Divide_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Divide_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_Int64Int64");

	Params::UKismetMathLibrary_Divide_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Divide_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_FloatFloat");

	Params::UKismetMathLibrary_Divide_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Divide_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Divide_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Divide_ByteByte");

	Params::UKismetMathLibrary_Divide_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DistanceSquared2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   V1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   V2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DistanceSquared2D(const struct FVector2D& V1, const struct FVector2D& V2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DistanceSquared2D");

	Params::UKismetMathLibrary_DistanceSquared2D_Params Parms{};

	Parms.V1 = V1;
	Parms.V2 = V2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Distance2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   V1                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   V2                                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Distance2D(const struct FVector2D& V1, const struct FVector2D& V2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Distance2D");

	Params::UKismetMathLibrary_Distance2D_Params Parms{};

	Parms.V1 = V1;
	Parms.V2 = V2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DegTan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegTan(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DegTan");

	Params::UKismetMathLibrary_DegTan_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DegSin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegSin(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DegSin");

	Params::UKismetMathLibrary_DegSin_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DegreesToRadians
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegreesToRadians(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DegreesToRadians");

	Params::UKismetMathLibrary_DegreesToRadians_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DegCos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegCos(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DegCos");

	Params::UKismetMathLibrary_DegCos_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DegAtan2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegAtan2(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DegAtan2");

	Params::UKismetMathLibrary_DegAtan2_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DegAtan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegAtan(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DegAtan");

	Params::UKismetMathLibrary_DegAtan_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DegAsin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegAsin(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DegAsin");

	Params::UKismetMathLibrary_DegAsin_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DegAcos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegAcos(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DegAcos");

	Params::UKismetMathLibrary_DegAcos_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DaysInYear
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Year                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::DaysInYear(int32 Year)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DaysInYear");

	Params::UKismetMathLibrary_DaysInYear_Params Parms{};

	Parms.Year = Year;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DaysInMonth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Year                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Month                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::DaysInMonth(int32 Year, int32 Month)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DaysInMonth");

	Params::UKismetMathLibrary_DaysInMonth_Params Parms{};

	Parms.Year = Year;
	Parms.Month = Month;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DateTimeMinValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::DateTimeMinValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DateTimeMinValue");

	Params::UKismetMathLibrary_DateTimeMinValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DateTimeMaxValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::DateTimeMaxValue()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DateTimeMaxValue");

	Params::UKismetMathLibrary_DateTimeMaxValue_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DateTimeFromString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      DateTimeString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   Result                                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::DateTimeFromString(const class FString& DateTimeString, struct FDateTime* Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DateTimeFromString");

	Params::UKismetMathLibrary_DateTimeFromString_Params Parms{};

	Parms.DateTimeString = DateTimeString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.DateTimeFromIsoString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      IsoString                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   Result                                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::DateTimeFromIsoString(const class FString& IsoString, struct FDateTime* Result)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "DateTimeFromIsoString");

	Params::UKismetMathLibrary_DateTimeFromIsoString_Params Parms{};

	Parms.IsoString = IsoString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.CrossProduct2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::CrossProduct2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "CrossProduct2D");

	Params::UKismetMathLibrary_CrossProduct2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Cross_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Cross_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Cross_VectorVector");

	Params::UKismetMathLibrary_Cross_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.CreateVectorFromYawPitch
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Yaw                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Pitch                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Length                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::CreateVectorFromYawPitch(float Yaw, float Pitch, float Length)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "CreateVectorFromYawPitch");

	Params::UKismetMathLibrary_CreateVectorFromYawPitch_Params Parms{};

	Parms.Yaw = Yaw;
	Parms.Pitch = Pitch;
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Cos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Cos(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Cos");

	Params::UKismetMathLibrary_Cos_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ConvertTransformToRelative
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  Transform                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  ParentTransform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::ConvertTransformToRelative(struct FTransform& Transform, struct FTransform& ParentTransform)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ConvertTransformToRelative");

	Params::UKismetMathLibrary_ConvertTransformToRelative_Params Parms{};

	Parms.Transform = Transform;
	Parms.ParentTransform = ParentTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_VectorToVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVector                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Conv_VectorToVector2D(const struct FVector& InVector)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_VectorToVector2D");

	Params::UKismetMathLibrary_Conv_VectorToVector2D_Params Parms{};

	Parms.InVector = InVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_VectorToTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InLocation                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::Conv_VectorToTransform(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_VectorToTransform");

	Params::UKismetMathLibrary_Conv_VectorToTransform_Params Parms{};

	Parms.InLocation = InLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_VectorToRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Conv_VectorToRotator(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_VectorToRotator");

	Params::UKismetMathLibrary_Conv_VectorToRotator_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_VectorToQuaterion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Conv_VectorToQuaterion(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_VectorToQuaterion");

	Params::UKismetMathLibrary_Conv_VectorToQuaterion_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_VectorToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Conv_VectorToLinearColor(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_VectorToLinearColor");

	Params::UKismetMathLibrary_Conv_VectorToLinearColor_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_Vector4ToVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    InVector4                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_Vector4ToVector(struct FVector4& InVector4)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_Vector4ToVector");

	Params::UKismetMathLibrary_Conv_Vector4ToVector_Params Parms{};

	Parms.InVector4 = InVector4;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_Vector4ToRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    InVec                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Conv_Vector4ToRotator(struct FVector4& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_Vector4ToRotator");

	Params::UKismetMathLibrary_Conv_Vector4ToRotator_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_Vector4ToQuaterion
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    InVec                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Conv_Vector4ToQuaterion(struct FVector4& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_Vector4ToQuaterion");

	Params::UKismetMathLibrary_Conv_Vector4ToQuaterion_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_Vector2DToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   InVector2D                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_Vector2DToVector(const struct FVector2D& InVector2D, float Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_Vector2DToVector");

	Params::UKismetMathLibrary_Conv_Vector2DToVector_Params Parms{};

	Parms.InVector2D = InVector2D;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_Vector2DToIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   InVector2D                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Conv_Vector2DToIntPoint(const struct FVector2D& InVector2D)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_Vector2DToIntPoint");

	Params::UKismetMathLibrary_Conv_Vector2DToIntPoint_Params Parms{};

	Parms.InVector2D = InVector2D;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_RotatorToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_RotatorToVector(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_RotatorToVector");

	Params::UKismetMathLibrary_Conv_RotatorToVector_Params Parms{};

	Parms.InRot = InRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_RotatorToTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRotator                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::Conv_RotatorToTransform(struct FRotator& InRotator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_RotatorToTransform");

	Params::UKismetMathLibrary_Conv_RotatorToTransform_Params Parms{};

	Parms.InRotator = InRotator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_MatrixToTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                     InMatrix                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::Conv_MatrixToTransform(struct FMatrix& InMatrix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_MatrixToTransform");

	Params::UKismetMathLibrary_Conv_MatrixToTransform_Params Parms{};

	Parms.InMatrix = InMatrix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_MatrixToRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                     InMatrix                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Conv_MatrixToRotator(struct FMatrix& InMatrix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_MatrixToRotator");

	Params::UKismetMathLibrary_Conv_MatrixToRotator_Params Parms{};

	Parms.InMatrix = InMatrix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_LinearColorToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InLinearColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_LinearColorToVector(const struct FLinearColor& InLinearColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_LinearColorToVector");

	Params::UKismetMathLibrary_Conv_LinearColorToVector_Params Parms{};

	Parms.InLinearColor = InLinearColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_LinearColorToColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InLinearColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InUseSRGB                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetMathLibrary::Conv_LinearColorToColor(const struct FLinearColor& InLinearColor, bool InUseSRGB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_LinearColorToColor");

	Params::UKismetMathLibrary_Conv_LinearColorToColor_Params Parms{};

	Parms.InLinearColor = InLinearColor;
	Parms.InUseSRGB = InUseSRGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_IntVectorToVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                  InIntVector                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_IntVectorToVector(struct FIntVector& InIntVector)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_IntVectorToVector");

	Params::UKismetMathLibrary_Conv_IntVectorToVector_Params Parms{};

	Parms.InIntVector = InIntVector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_IntToIntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InInt                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UKismetMathLibrary::Conv_IntToIntVector(int32 InInt)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_IntToIntVector");

	Params::UKismetMathLibrary_Conv_IntToIntVector_Params Parms{};

	Parms.InInt = InInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_IntToInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InInt                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Conv_IntToInt64(int32 InInt)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_IntToInt64");

	Params::UKismetMathLibrary_Conv_IntToInt64_Params Parms{};

	Parms.InInt = InInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_IntToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InInt                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Conv_IntToFloat(int32 InInt)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_IntToFloat");

	Params::UKismetMathLibrary_Conv_IntToFloat_Params Parms{};

	Parms.InInt = InInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_IntToByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InInt                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Conv_IntToByte(int32 InInt)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_IntToByte");

	Params::UKismetMathLibrary_Conv_IntToByte_Params Parms{};

	Parms.InInt = InInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_IntToBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InInt                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Conv_IntToBool(int32 InInt)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_IntToBool");

	Params::UKismetMathLibrary_Conv_IntToBool_Params Parms{};

	Parms.InInt = InInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_FloatToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_FloatToVector(float InFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_FloatToVector");

	Params::UKismetMathLibrary_Conv_FloatToVector_Params Parms{};

	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_FloatToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Conv_FloatToLinearColor(float InFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_FloatToLinearColor");

	Params::UKismetMathLibrary_Conv_FloatToLinearColor_Params Parms{};

	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_ColorToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FColor                      InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Conv_ColorToLinearColor(const struct FColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_ColorToLinearColor");

	Params::UKismetMathLibrary_Conv_ColorToLinearColor_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_ByteToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              InByte                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Conv_ByteToInt(uint8 InByte)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_ByteToInt");

	Params::UKismetMathLibrary_Conv_ByteToInt_Params Parms{};

	Parms.InByte = InByte;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_ByteToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              InByte                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Conv_ByteToFloat(uint8 InByte)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_ByteToFloat");

	Params::UKismetMathLibrary_Conv_ByteToFloat_Params Parms{};

	Parms.InByte = InByte;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_BoolToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               InBool                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Conv_BoolToInt(bool InBool)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_BoolToInt");

	Params::UKismetMathLibrary_Conv_BoolToInt_Params Parms{};

	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_BoolToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               InBool                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Conv_BoolToFloat(bool InBool)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_BoolToFloat");

	Params::UKismetMathLibrary_Conv_BoolToFloat_Params Parms{};

	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Conv_BoolToByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               InBool                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Conv_BoolToByte(bool InBool)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Conv_BoolToByte");

	Params::UKismetMathLibrary_Conv_BoolToByte_Params Parms{};

	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ComposeTransforms
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::ComposeTransforms(struct FTransform& A, struct FTransform& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ComposeTransforms");

	Params::UKismetMathLibrary_ComposeTransforms_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ComposeRotators
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::ComposeRotators(const struct FRotator& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ComposeRotators");

	Params::UKismetMathLibrary_ComposeRotators_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ClassIsChildOf
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>         TestClass                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>         ParentClass                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::ClassIsChildOf(TSubclassOf<class UObject> TestClass, TSubclassOf<class UObject> ParentClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ClassIsChildOf");

	Params::UKismetMathLibrary_ClassIsChildOf_Params Parms{};

	Parms.TestClass = TestClass;
	Parms.ParentClass = ParentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ClampVectorSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::ClampVectorSize(const struct FVector& A, float Min, float Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ClampVectorSize");

	Params::UKismetMathLibrary_ClampVectorSize_Params Parms{};

	Parms.A = A;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ClampInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::ClampInt64(int64 Value, int64 Min, int64 Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ClampInt64");

	Params::UKismetMathLibrary_ClampInt64_Params Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ClampAxis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Angle                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::ClampAxis(float Angle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ClampAxis");

	Params::UKismetMathLibrary_ClampAxis_Params Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ClampAxes2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MinAxisVal                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxAxisVal                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::ClampAxes2D(const struct FVector2D& A, float MinAxisVal, float MaxAxisVal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ClampAxes2D");

	Params::UKismetMathLibrary_ClampAxes2D_Params Parms{};

	Parms.A = A;
	Parms.MinAxisVal = MinAxisVal;
	Parms.MaxAxisVal = MaxAxisVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.ClampAngle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              AngleDegrees                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MinAngleDegrees                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              MaxAngleDegrees                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "ClampAngle");

	Params::UKismetMathLibrary_ClampAngle_Params Parms{};

	Parms.AngleDegrees = AngleDegrees;
	Parms.MinAngleDegrees = MinAngleDegrees;
	Parms.MaxAngleDegrees = MaxAngleDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Clamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Min                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Max                                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Clamp(int32 Value, int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Clamp");

	Params::UKismetMathLibrary_Clamp_Params Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.CInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                Current                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                Target                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DeltaTime                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InterpSpeed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::CInterpTo(const struct FLinearColor& Current, const struct FLinearColor& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "CInterpTo");

	Params::UKismetMathLibrary_CInterpTo_Params Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.BreakVector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    InVec                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              X                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              W                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector4(struct FVector4& InVec, float* X, float* Y, float* Z, float* W)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakVector4");

	Params::UKismetMathLibrary_BreakVector4_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Z != nullptr)
		*Z = Parms.Z;

	if (W != nullptr)
		*W = Parms.W;

}


// Function Engine.KismetMathLibrary.BreakVector2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              X                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector2D(const struct FVector2D& InVec, float* X, float* Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakVector2D");

	Params::UKismetMathLibrary_BreakVector2D_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

}


// Function Engine.KismetMathLibrary.BreakVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              X                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Y                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Z                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector(const struct FVector& InVec, float* X, float* Y, float* Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakVector");

	Params::UKismetMathLibrary_BreakVector_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Z != nullptr)
		*Z = Parms.Z;

}


// Function Engine.KismetMathLibrary.BreakTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  InTransform                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Scale                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakTransform(struct FTransform& InTransform, struct FVector* Location, struct FRotator* Rotation, struct FVector* Scale)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakTransform");

	Params::UKismetMathLibrary_BreakTransform_Params Parms{};

	Parms.InTransform = InTransform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);

	if (Scale != nullptr)
		*Scale = std::move(Parms.Scale);

}


// Function Engine.KismetMathLibrary.BreakTimespan2
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   InTimespan                                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Days                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Hours                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Minutes                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Seconds                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              FractionNano                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakTimespan2(const struct FTimespan& InTimespan, int32* Days, int32* Hours, int32* Minutes, int32* Seconds, int32* FractionNano)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakTimespan2");

	Params::UKismetMathLibrary_BreakTimespan2_Params Parms{};

	Parms.InTimespan = InTimespan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Days != nullptr)
		*Days = Parms.Days;

	if (Hours != nullptr)
		*Hours = Parms.Hours;

	if (Minutes != nullptr)
		*Minutes = Parms.Minutes;

	if (Seconds != nullptr)
		*Seconds = Parms.Seconds;

	if (FractionNano != nullptr)
		*FractionNano = Parms.FractionNano;

}


// Function Engine.KismetMathLibrary.BreakTimespan
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   InTimespan                                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Days                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Hours                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Minutes                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Seconds                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Milliseconds                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakTimespan(const struct FTimespan& InTimespan, int32* Days, int32* Hours, int32* Minutes, int32* Seconds, int32* Milliseconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakTimespan");

	Params::UKismetMathLibrary_BreakTimespan_Params Parms{};

	Parms.InTimespan = InTimespan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Days != nullptr)
		*Days = Parms.Days;

	if (Hours != nullptr)
		*Hours = Parms.Hours;

	if (Minutes != nullptr)
		*Minutes = Parms.Minutes;

	if (Seconds != nullptr)
		*Seconds = Parms.Seconds;

	if (Milliseconds != nullptr)
		*Milliseconds = Parms.Milliseconds;

}


// Function Engine.KismetMathLibrary.BreakRotIntoAxes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRot                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     X                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Y                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Z                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakRotIntoAxes(struct FRotator& InRot, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakRotIntoAxes");

	Params::UKismetMathLibrary_BreakRotIntoAxes_Params Parms{};

	Parms.InRot = InRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (X != nullptr)
		*X = std::move(Parms.X);

	if (Y != nullptr)
		*Y = std::move(Parms.Y);

	if (Z != nullptr)
		*Z = std::move(Parms.Z);

}


// Function Engine.KismetMathLibrary.BreakRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Roll                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Pitch                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Yaw                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakRotator(const struct FRotator& InRot, float* Roll, float* Pitch, float* Yaw)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakRotator");

	Params::UKismetMathLibrary_BreakRotator_Params Parms{};

	Parms.InRot = InRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Roll != nullptr)
		*Roll = Parms.Roll;

	if (Pitch != nullptr)
		*Pitch = Parms.Pitch;

	if (Yaw != nullptr)
		*Yaw = Parms.Yaw;

}


// Function Engine.KismetMathLibrary.BreakRandomStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream               InRandomStream                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                              InitialSeed                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakRandomStream(struct FRandomStream& InRandomStream, int32* InitialSeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakRandomStream");

	Params::UKismetMathLibrary_BreakRandomStream_Params Parms{};

	Parms.InRandomStream = InRandomStream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (InitialSeed != nullptr)
		*InitialSeed = Parms.InitialSeed;

}


// Function Engine.KismetMathLibrary.BreakQualifiedFrameTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQualifiedFrameTime         InFrameTime                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameNumber                Frame                                                            (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameRate                  FrameRate                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SubFrame                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakQualifiedFrameTime(struct FQualifiedFrameTime& InFrameTime, struct FFrameNumber* Frame, struct FFrameRate* FrameRate, float* SubFrame)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakQualifiedFrameTime");

	Params::UKismetMathLibrary_BreakQualifiedFrameTime_Params Parms{};

	Parms.InFrameTime = InFrameTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Frame != nullptr)
		*Frame = std::move(Parms.Frame);

	if (FrameRate != nullptr)
		*FrameRate = std::move(Parms.FrameRate);

	if (SubFrame != nullptr)
		*SubFrame = Parms.SubFrame;

}


// Function Engine.KismetMathLibrary.BreakFrameRate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFrameRate                  InFrameRate                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Numerator                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Denominator                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakFrameRate(struct FFrameRate& InFrameRate, int32* Numerator, int32* Denominator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakFrameRate");

	Params::UKismetMathLibrary_BreakFrameRate_Params Parms{};

	Parms.InFrameRate = InFrameRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Numerator != nullptr)
		*Numerator = Parms.Numerator;

	if (Denominator != nullptr)
		*Denominator = Parms.Denominator;

}


// Function Engine.KismetMathLibrary.BreakDateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   InDateTime                                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Year                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Month                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Day                                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Hour                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Minute                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Second                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Millisecond                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakDateTime(const struct FDateTime& InDateTime, int32* Year, int32* Month, int32* Day, int32* Hour, int32* Minute, int32* Second, int32* Millisecond)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakDateTime");

	Params::UKismetMathLibrary_BreakDateTime_Params Parms{};

	Parms.InDateTime = InDateTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Year != nullptr)
		*Year = Parms.Year;

	if (Month != nullptr)
		*Month = Parms.Month;

	if (Day != nullptr)
		*Day = Parms.Day;

	if (Hour != nullptr)
		*Hour = Parms.Hour;

	if (Minute != nullptr)
		*Minute = Parms.Minute;

	if (Second != nullptr)
		*Second = Parms.Second;

	if (Millisecond != nullptr)
		*Millisecond = Parms.Millisecond;

}


// Function Engine.KismetMathLibrary.BreakColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              R                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              G                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              A                                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakColor(const struct FLinearColor& InColor, float* R, float* G, float* B, float* A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BreakColor");

	Params::UKismetMathLibrary_BreakColor_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (R != nullptr)
		*R = Parms.R;

	if (G != nullptr)
		*G = Parms.G;

	if (B != nullptr)
		*B = Parms.B;

	if (A != nullptr)
		*A = Parms.A;

}


// Function Engine.KismetMathLibrary.BooleanXOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanXOR(bool A, bool B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BooleanXOR");

	Params::UKismetMathLibrary_BooleanXOR_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.BooleanOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanOR(bool A, bool B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BooleanOR");

	Params::UKismetMathLibrary_BooleanOR_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.BooleanNOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanNOR(bool A, bool B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BooleanNOR");

	Params::UKismetMathLibrary_BooleanNOR_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.BooleanNAND
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanNAND(bool A, bool B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BooleanNAND");

	Params::UKismetMathLibrary_BooleanNAND_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.BooleanAND
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanAND(bool A, bool B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BooleanAND");

	Params::UKismetMathLibrary_BooleanAND_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.BMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::BMin(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BMin");

	Params::UKismetMathLibrary_BMin_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.BMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::BMax(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "BMax");

	Params::UKismetMathLibrary_BMax_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Atan2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Atan2(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Atan2");

	Params::UKismetMathLibrary_Atan2_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Atan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Atan(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Atan");

	Params::UKismetMathLibrary_Atan_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Asin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Asin(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Asin");

	Params::UKismetMathLibrary_Asin_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.And_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::And_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "And_IntInt");

	Params::UKismetMathLibrary_And_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.And_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::And_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "And_Int64Int64");

	Params::UKismetMathLibrary_And_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Add_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_VectorVector");

	Params::UKismetMathLibrary_Add_VectorVector_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Add_VectorInt(const struct FVector& A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_VectorInt");

	Params::UKismetMathLibrary_Add_VectorInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Add_VectorFloat(const struct FVector& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_VectorFloat");

	Params::UKismetMathLibrary_Add_VectorFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                    A                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    B                                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Add_Vector4Vector4(struct FVector4& A, struct FVector4& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_Vector4Vector4");

	Params::UKismetMathLibrary_Add_Vector4Vector4_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Add_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_Vector2DVector2D");

	Params::UKismetMathLibrary_Add_Vector2DVector2D_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Add_Vector2DFloat(const struct FVector2D& A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_Vector2DFloat");

	Params::UKismetMathLibrary_Add_Vector2DFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Add_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_TimespanTimespan");

	Params::UKismetMathLibrary_Add_TimespanTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                       A                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                       ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Add_QuatQuat(struct FQuat& A, struct FQuat& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_QuatQuat");

	Params::UKismetMathLibrary_Add_QuatQuat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Add_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_LinearColorLinearColor");

	Params::UKismetMathLibrary_Add_LinearColorLinearColor_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Add_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_IntInt");

	Params::UKismetMathLibrary_Add_IntInt_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Add_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_Int64Int64");

	Params::UKismetMathLibrary_Add_Int64Int64_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Add_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_FloatFloat");

	Params::UKismetMathLibrary_Add_FloatFloat_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_DateTimeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                   B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Add_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_DateTimeTimespan");

	Params::UKismetMathLibrary_Add_DateTimeTimespan_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Add_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              B                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Add_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Add_ByteByte");

	Params::UKismetMathLibrary_Add_ByteByte_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Acos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Acos(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Acos");

	Params::UKismetMathLibrary_Acos_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Abs_Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Abs_Int64(int64 A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Abs_Int64");

	Params::UKismetMathLibrary_Abs_Int64_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.Abs_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Abs_Int(int32 A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "Abs_Int");

	Params::UKismetMathLibrary_Abs_Int_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetMathLibrary.abs
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              A                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Abs(float A)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetMathLibrary", "abs");

	Params::UKismetMathLibrary_Abs_Params Parms{};

	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.KismetNodeHelperLibrary
// (None)

class UClass* UKismetNodeHelperLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetNodeHelperLibrary");

	return Clss;
}


// KismetNodeHelperLibrary Engine.Default__KismetNodeHelperLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetNodeHelperLibrary* UKismetNodeHelperLibrary::GetDefaultObj()
{
	static class UKismetNodeHelperLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetNodeHelperLibrary*>(UKismetNodeHelperLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetNodeHelperLibrary.MarkBit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetNodeHelperLibrary::MarkBit(int32* Data, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "MarkBit");

	Params::UKismetNodeHelperLibrary_MarkBit_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

}


// Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumBits                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetNodeHelperLibrary::HasUnmarkedBit(int32 Data, int32 NumBits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "HasUnmarkedBit");

	Params::UKismetNodeHelperLibrary_HasUnmarkedBit_Params Parms{};

	Parms.Data = Data;
	Parms.NumBits = NumBits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.HasMarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumBits                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetNodeHelperLibrary::HasMarkedBit(int32 Data, int32 NumBits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "HasMarkedBit");

	Params::UKismetNodeHelperLibrary_HasMarkedBit_Params Parms{};

	Parms.Data = Data;
	Parms.NumBits = NumBits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.GetValidValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                       Enum                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              EnumeratorValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetNodeHelperLibrary::GetValidValue(class UEnum* Enum, uint8 EnumeratorValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "GetValidValue");

	Params::UKismetNodeHelperLibrary_GetValidValue_Params Parms{};

	Parms.Enum = Enum;
	Parms.EnumeratorValue = EnumeratorValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StartIdx                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumBits                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bRandom                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetNodeHelperLibrary::GetUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits, bool bRandom)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "GetUnmarkedBit");

	Params::UKismetNodeHelperLibrary_GetUnmarkedBit_Params Parms{};

	Parms.Data = Data;
	Parms.StartIdx = StartIdx;
	Parms.NumBits = NumBits;
	Parms.bRandom = bRandom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StartIdx                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumBits                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetNodeHelperLibrary::GetRandomUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "GetRandomUnmarkedBit");

	Params::UKismetNodeHelperLibrary_GetRandomUnmarkedBit_Params Parms{};

	Parms.Data = Data;
	Parms.StartIdx = StartIdx;
	Parms.NumBits = NumBits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StartIdx                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumBits                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetNodeHelperLibrary::GetFirstUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "GetFirstUnmarkedBit");

	Params::UKismetNodeHelperLibrary_GetFirstUnmarkedBit_Params Parms{};

	Parms.Data = Data;
	Parms.StartIdx = StartIdx;
	Parms.NumBits = NumBits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorValueFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                       Enum                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              EnumeratorIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetNodeHelperLibrary::GetEnumeratorValueFromIndex(class UEnum* Enum, uint8 EnumeratorIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "GetEnumeratorValueFromIndex");

	Params::UKismetNodeHelperLibrary_GetEnumeratorValueFromIndex_Params Parms{};

	Parms.Enum = Enum;
	Parms.EnumeratorIndex = EnumeratorIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                       Enum                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              EnumeratorValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetNodeHelperLibrary::GetEnumeratorUserFriendlyName(class UEnum* Enum, uint8 EnumeratorValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "GetEnumeratorUserFriendlyName");

	Params::UKismetNodeHelperLibrary_GetEnumeratorUserFriendlyName_Params Parms{};

	Parms.Enum = Enum;
	Parms.EnumeratorValue = EnumeratorValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                       Enum                                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              EnumeratorValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKismetNodeHelperLibrary::GetEnumeratorName(class UEnum* Enum, uint8 EnumeratorValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "GetEnumeratorName");

	Params::UKismetNodeHelperLibrary_GetEnumeratorName_Params Parms{};

	Parms.Enum = Enum;
	Parms.EnumeratorValue = EnumeratorValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetNodeHelperLibrary.ClearBit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetNodeHelperLibrary::ClearBit(int32* Data, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "ClearBit");

	Params::UKismetNodeHelperLibrary_ClearBit_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

}


// Function Engine.KismetNodeHelperLibrary.ClearAllBits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetNodeHelperLibrary::ClearAllBits(int32* Data)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "ClearAllBits");

	Params::UKismetNodeHelperLibrary_ClearAllBits_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

}


// Function Engine.KismetNodeHelperLibrary.BitIsMarked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Data                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetNodeHelperLibrary::BitIsMarked(int32 Data, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetNodeHelperLibrary", "BitIsMarked");

	Params::UKismetNodeHelperLibrary_BitIsMarked_Params Parms{};

	Parms.Data = Data;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.KismetRenderingLibrary
// (None)

class UClass* UKismetRenderingLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetRenderingLibrary");

	return Clss;
}


// KismetRenderingLibrary Engine.Default__KismetRenderingLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetRenderingLibrary* UKismetRenderingLibrary::GetDefaultObj()
{
	static class UKismetRenderingLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetRenderingLibrary*>(UKismetRenderingLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetRenderingLibrary.SetCastInsetShadowForAllAttachments
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         PrimitiveComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCastInsetShadow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLightAttachmentsAsGroup                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::SetCastInsetShadowForAllAttachments(class UObject* WorldContextObject, class UPrimitiveComponent* PrimitiveComponent, bool bCastInsetShadow, bool bLightAttachmentsAsGroup)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "SetCastInsetShadowForAllAttachments");

	Params::UKismetRenderingLibrary_SetCastInsetShadowForAllAttachments_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.bCastInsetShadow = bCastInsetShadow;
	Parms.bLightAttachmentsAsGroup = bLightAttachmentsAsGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*      RenderTarget                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Name                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETextureCompressionSettingsCompressionSettings                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETextureMipGenSettings  MipSettings                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UKismetRenderingLibrary::RenderTargetCreateStaticTexture2DEditorOnly(class UTextureRenderTarget2D* RenderTarget, const class FString& Name, enum class ETextureCompressionSettings CompressionSettings, enum class ETextureMipGenSettings MipSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "RenderTargetCreateStaticTexture2DEditorOnly");

	Params::UKismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly_Params Parms{};

	Parms.RenderTarget = RenderTarget;
	Parms.Name = Name;
	Parms.CompressionSettings = CompressionSettings;
	Parms.MipSettings = MipSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ReleaseRenderTarget2D(class UTextureRenderTarget2D* TextureRenderTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ReleaseRenderTarget2D");

	Params::UKismetRenderingLibrary_ReleaseRenderTarget2D_Params Parms{};

	Parms.TextureRenderTarget = TextureRenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetUV
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              U                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              V                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetRenderingLibrary::ReadRenderTargetUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ReadRenderTargetUV");

	Params::UKismetRenderingLibrary_ReadRenderTargetUV_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.U = U;
	Parms.V = V;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUV
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              U                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              V                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetRenderingLibrary::ReadRenderTargetRawUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ReadRenderTargetRawUV");

	Params::UKismetRenderingLibrary_ReadRenderTargetRawUV_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.U = U;
	Parms.V = V;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixel
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetRenderingLibrary::ReadRenderTargetRawPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 X, int32 Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ReadRenderTargetRawPixel");

	Params::UKismetRenderingLibrary_ReadRenderTargetRawPixel_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetPixel
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              X                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Y                                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetRenderingLibrary::ReadRenderTargetPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 X, int32 Y)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ReadRenderTargetPixel");

	Params::UKismetRenderingLibrary_ReadRenderTargetPixel_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.X = X;
	Parms.Y = Y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.MakeSkinWeightInfo
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Bone0                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Weight0                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Bone1                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Weight1                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Bone2                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Weight2                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Bone3                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Weight3                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkelMeshSkinWeightInfo     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FSkelMeshSkinWeightInfo UKismetRenderingLibrary::MakeSkinWeightInfo(int32 Bone0, uint8 Weight0, int32 Bone1, uint8 Weight1, int32 Bone2, uint8 Weight2, int32 Bone3, uint8 Weight3)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "MakeSkinWeightInfo");

	Params::UKismetRenderingLibrary_MakeSkinWeightInfo_Params Parms{};

	Parms.Bone0 = Bone0;
	Parms.Weight0 = Weight0;
	Parms.Bone1 = Bone1;
	Parms.Weight1 = Weight1;
	Parms.Bone2 = Bone2;
	Parms.Weight2 = Weight2;
	Parms.Bone3 = Bone3;
	Parms.Weight3 = Weight3;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.ImportFileAsTexture2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Filename                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UKismetRenderingLibrary::ImportFileAsTexture2D(class UObject* WorldContextObject, const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ImportFileAsTexture2D");

	Params::UKismetRenderingLibrary_ImportFileAsTexture2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Filename = Filename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.ImportBufferAsTexture2D
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                      Buffer                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UKismetRenderingLibrary::ImportBufferAsTexture2D(class UObject* WorldContextObject, TArray<uint8>& Buffer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ImportBufferAsTexture2D");

	Params::UKismetRenderingLibrary_ImportBufferAsTexture2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Buffer = Buffer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.ExportTexture2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  Texture                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FilePath                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Filename                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ExportTexture2D(class UObject* WorldContextObject, class UTexture2D* Texture, const class FString& FilePath, const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ExportTexture2D");

	Params::UKismetRenderingLibrary_ExportTexture2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Texture = Texture;
	Parms.FilePath = FilePath;
	Parms.Filename = Filename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetRenderingLibrary.ExportRenderTarget
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FilePath                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Filename                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ExportRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const class FString& FilePath, const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ExportRenderTarget");

	Params::UKismetRenderingLibrary_ExportRenderTarget_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.FilePath = FilePath;
	Parms.Filename = Filename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDrawToRenderTargetContext  Context                                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::EndDrawCanvasToRenderTarget(class UObject* WorldContextObject, struct FDrawToRenderTargetContext& Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "EndDrawCanvasToRenderTarget");

	Params::UKismetRenderingLibrary_EndDrawCanvasToRenderTarget_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::DrawMaterialToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "DrawMaterialToRenderTarget");

	Params::UKismetRenderingLibrary_DrawMaterialToRenderTarget_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetRenderingLibrary.CreateRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Width                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Height                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETextureRenderTargetFormatFormat                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* UKismetRenderingLibrary::CreateRenderTarget2D(class UObject* WorldContextObject, int32 Width, int32 Height, enum class ETextureRenderTargetFormat Format)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "CreateRenderTarget2D");

	Params::UKismetRenderingLibrary_CreateRenderTarget2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.Format = Format;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      RenderTarget                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                  Texture                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ConvertRenderTargetToTexture2DEditorOnly(class UObject* WorldContextObject, class UTextureRenderTarget2D* RenderTarget, class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ConvertRenderTargetToTexture2DEditorOnly");

	Params::UKismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RenderTarget = RenderTarget;
	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetRenderingLibrary.ClearRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ClearColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ClearRenderTarget2D(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const struct FLinearColor& ClearColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "ClearRenderTarget2D");

	Params::UKismetRenderingLibrary_ClearRenderTarget2D_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.ClearColor = ClearColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetRenderingLibrary.BreakSkinWeightInfo
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSkelMeshSkinWeightInfo     InWeight                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                              Bone0                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Weight0                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Bone1                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Weight1                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Bone2                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Weight2                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Bone3                                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Weight3                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::BreakSkinWeightInfo(const struct FSkelMeshSkinWeightInfo& InWeight, int32* Bone0, uint8* Weight0, int32* Bone1, uint8* Weight1, int32* Bone2, uint8* Weight2, int32* Bone3, uint8* Weight3)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "BreakSkinWeightInfo");

	Params::UKismetRenderingLibrary_BreakSkinWeightInfo_Params Parms{};

	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Bone0 != nullptr)
		*Bone0 = Parms.Bone0;

	if (Weight0 != nullptr)
		*Weight0 = Parms.Weight0;

	if (Bone1 != nullptr)
		*Bone1 = Parms.Bone1;

	if (Weight1 != nullptr)
		*Weight1 = Parms.Weight1;

	if (Bone2 != nullptr)
		*Bone2 = Parms.Bone2;

	if (Weight2 != nullptr)
		*Weight2 = Parms.Weight2;

	if (Bone3 != nullptr)
		*Bone3 = Parms.Bone3;

	if (Weight3 != nullptr)
		*Weight3 = Parms.Weight3;

}


// Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*      TextureRenderTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCanvas*                     Canvas                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Size                                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDrawToRenderTargetContext  Context                                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::BeginDrawCanvasToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UCanvas** Canvas, struct FVector2D* Size, struct FDrawToRenderTargetContext* Context)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetRenderingLibrary", "BeginDrawCanvasToRenderTarget");

	Params::UKismetRenderingLibrary_BeginDrawCanvasToRenderTarget_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Canvas != nullptr)
		*Canvas = Parms.Canvas;

	if (Size != nullptr)
		*Size = std::move(Parms.Size);

	if (Context != nullptr)
		*Context = std::move(Parms.Context);

}


// Class Engine.KismetStringLibrary
// (None)

class UClass* UKismetStringLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetStringLibrary");

	return Clss;
}


// KismetStringLibrary Engine.Default__KismetStringLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetStringLibrary* UKismetStringLibrary::GetDefaultObj()
{
	static class UKismetStringLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetStringLibrary*>(UKismetStringLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetStringLibrary.TrimTrailing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::TrimTrailing(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "TrimTrailing");

	Params::UKismetStringLibrary_TrimTrailing_Params Parms{};

	Parms.SourceString = SourceString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Trim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Trim(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Trim");

	Params::UKismetStringLibrary_Trim_Params Parms{};

	Parms.SourceString = SourceString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.ToUpper
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::ToUpper(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "ToUpper");

	Params::UKismetStringLibrary_ToUpper_Params Parms{};

	Parms.SourceString = SourceString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.ToLower
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::ToLower(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "ToLower");

	Params::UKismetStringLibrary_ToLower_Params Parms{};

	Parms.SourceString = SourceString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.TimeSecondsToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InSeconds                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::TimeSecondsToString(float InSeconds)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "TimeSecondsToString");

	Params::UKismetStringLibrary_TimeSecondsToString_Params Parms{};

	Parms.InSeconds = InSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.StartsWith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InPrefix                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESearchCase             SearchCase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::StartsWith(const class FString& SourceString, const class FString& InPrefix, enum class ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "StartsWith");

	Params::UKismetStringLibrary_StartsWith_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.InPrefix = InPrefix;
	Parms.SearchCase = SearchCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Split
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InStr                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      LeftS                                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      RightS                                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESearchCase             SearchCase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESearchDir              SearchDir                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::Split(const class FString& SourceString, const class FString& InStr, class FString* LeftS, class FString* RightS, enum class ESearchCase SearchCase, enum class ESearchDir SearchDir)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Split");

	Params::UKismetStringLibrary_Split_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.InStr = InStr;
	Parms.SearchCase = SearchCase;
	Parms.SearchDir = SearchDir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (LeftS != nullptr)
		*LeftS = std::move(Parms.LeftS);

	if (RightS != nullptr)
		*RightS = std::move(Parms.RightS);

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.RightPad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ChCount                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::RightPad(const class FString& SourceString, int32 ChCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "RightPad");

	Params::UKismetStringLibrary_RightPad_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.ChCount = ChCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.RightChop
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Count                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::RightChop(const class FString& SourceString, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "RightChop");

	Params::UKismetStringLibrary_RightChop_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Right
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Count                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Right(const class FString& SourceString, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Right");

	Params::UKismetStringLibrary_Right_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Reverse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Reverse(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Reverse");

	Params::UKismetStringLibrary_Reverse_Params Parms{};

	Parms.SourceString = SourceString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.ReplaceInline
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                      SourceString                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      SearchText                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReplacementText                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESearchCase             SearchCase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::ReplaceInline(class FString& SourceString, const class FString& SearchText, const class FString& ReplacementText, enum class ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "ReplaceInline");

	Params::UKismetStringLibrary_ReplaceInline_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.SearchText = SearchText;
	Parms.ReplacementText = ReplacementText;
	Parms.SearchCase = SearchCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Replace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      From                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      To                                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESearchCase             SearchCase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Replace(const class FString& SourceString, const class FString& From, const class FString& To, enum class ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Replace");

	Params::UKismetStringLibrary_Replace_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.From = From;
	Parms.To = To;
	Parms.SearchCase = SearchCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.ParseIntoArray
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Delimiter                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               CullEmptyStrings                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetStringLibrary::ParseIntoArray(const class FString& SourceString, const class FString& Delimiter, bool CullEmptyStrings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "ParseIntoArray");

	Params::UKismetStringLibrary_ParseIntoArray_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.Delimiter = Delimiter;
	Parms.CullEmptyStrings = CullEmptyStrings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.NotEqual_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      A                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      B                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::NotEqual_StrStr(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "NotEqual_StrStr");

	Params::UKismetStringLibrary_NotEqual_StrStr_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.NotEqual_StriStri
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      A                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      B                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::NotEqual_StriStri(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "NotEqual_StriStri");

	Params::UKismetStringLibrary_NotEqual_StriStri_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Mid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Start                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Count                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Mid(const class FString& SourceString, int32 Start, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Mid");

	Params::UKismetStringLibrary_Mid_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.Start = Start;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.MatchesWildcard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Wildcard                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESearchCase             SearchCase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::MatchesWildcard(const class FString& SourceString, const class FString& Wildcard, enum class ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "MatchesWildcard");

	Params::UKismetStringLibrary_MatchesWildcard_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.Wildcard = Wildcard;
	Parms.SearchCase = SearchCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Len
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      S                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::Len(const class FString& S)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Len");

	Params::UKismetStringLibrary_Len_Params Parms{};

	Parms.S = S;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.LeftPad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ChCount                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::LeftPad(const class FString& SourceString, int32 ChCount)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "LeftPad");

	Params::UKismetStringLibrary_LeftPad_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.ChCount = ChCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.LeftChop
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Count                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::LeftChop(const class FString& SourceString, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "LeftChop");

	Params::UKismetStringLibrary_LeftChop_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Left
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Count                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Left(const class FString& SourceString, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Left");

	Params::UKismetStringLibrary_Left_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.JoinStringArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>              SourceArray                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      Separator                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::JoinStringArray(TArray<class FString>& SourceArray, const class FString& Separator)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "JoinStringArray");

	Params::UKismetStringLibrary_JoinStringArray_Params Parms{};

	Parms.SourceArray = SourceArray;
	Parms.Separator = Separator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.IsNumeric
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::IsNumeric(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "IsNumeric");

	Params::UKismetStringLibrary_IsNumeric_Params Parms{};

	Parms.SourceString = SourceString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.GetSubstring
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StartIndex                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Length                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::GetSubstring(const class FString& SourceString, int32 StartIndex, int32 Length)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "GetSubstring");

	Params::UKismetStringLibrary_GetSubstring_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.StartIndex = StartIndex;
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.GetCharacterAsNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::GetCharacterAsNumber(const class FString& SourceString, int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "GetCharacterAsNumber");

	Params::UKismetStringLibrary_GetCharacterAsNumber_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.GetCharacterArrayFromString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetStringLibrary::GetCharacterArrayFromString(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "GetCharacterArrayFromString");

	Params::UKismetStringLibrary_GetCharacterArrayFromString_Params Parms{};

	Parms.SourceString = SourceString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.FindSubstring
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SearchIn                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Substring                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseCase                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSearchFromEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              StartPosition                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::FindSubstring(const class FString& SearchIn, const class FString& Substring, bool bUseCase, bool bSearchFromEnd, int32 StartPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "FindSubstring");

	Params::UKismetStringLibrary_FindSubstring_Params Parms{};

	Parms.SearchIn = SearchIn;
	Parms.Substring = Substring;
	Parms.bUseCase = bUseCase;
	Parms.bSearchFromEnd = bSearchFromEnd;
	Parms.StartPosition = StartPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.EqualEqual_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      A                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      B                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::EqualEqual_StrStr(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "EqualEqual_StrStr");

	Params::UKismetStringLibrary_EqualEqual_StrStr_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.EqualEqual_StriStri
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      A                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      B                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::EqualEqual_StriStri(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "EqualEqual_StriStri");

	Params::UKismetStringLibrary_EqualEqual_StriStri_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.EndsWith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InSuffix                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ESearchCase             SearchCase                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::EndsWith(const class FString& SourceString, const class FString& InSuffix, enum class ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "EndsWith");

	Params::UKismetStringLibrary_EndsWith_Params Parms{};

	Parms.SourceString = SourceString;
	Parms.InSuffix = InSuffix;
	Parms.SearchCase = SearchCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.CullArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SourceString                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              InArray                                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::CullArray(const class FString& SourceString, TArray<class FString>* InArray)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "CullArray");

	Params::UKismetStringLibrary_CullArray_Params Parms{};

	Parms.SourceString = SourceString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (InArray != nullptr)
		*InArray = std::move(Parms.InArray);

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_VectorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_VectorToString(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_VectorToString");

	Params::UKismetStringLibrary_Conv_VectorToString_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_Vector2dToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_Vector2dToString(const struct FVector2D& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_Vector2dToString");

	Params::UKismetStringLibrary_Conv_Vector2dToString_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_TransformToString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  InTrans                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_TransformToString(struct FTransform& InTrans)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_TransformToString");

	Params::UKismetStringLibrary_Conv_TransformToString_Params Parms{};

	Parms.InTrans = InTrans;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_StringToVector2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   OutConvertedVector2D                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutIsValid                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetStringLibrary::Conv_StringToVector2D(const class FString& InString, struct FVector2D* OutConvertedVector2D, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_StringToVector2D");

	Params::UKismetStringLibrary_Conv_StringToVector2D_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutConvertedVector2D != nullptr)
		*OutConvertedVector2D = std::move(Parms.OutConvertedVector2D);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

}


// Function Engine.KismetStringLibrary.Conv_StringToVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutConvertedVector                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutIsValid                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetStringLibrary::Conv_StringToVector(const class FString& InString, struct FVector* OutConvertedVector, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_StringToVector");

	Params::UKismetStringLibrary_Conv_StringToVector_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutConvertedVector != nullptr)
		*OutConvertedVector = std::move(Parms.OutConvertedVector);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

}


// Function Engine.KismetStringLibrary.Conv_StringToRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    OutConvertedRotator                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               OutIsValid                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetStringLibrary::Conv_StringToRotator(const class FString& InString, struct FRotator* OutConvertedRotator, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_StringToRotator");

	Params::UKismetStringLibrary_Conv_StringToRotator_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutConvertedRotator != nullptr)
		*OutConvertedRotator = std::move(Parms.OutConvertedRotator);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

}


// Function Engine.KismetStringLibrary.Conv_StringToName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKismetStringLibrary::Conv_StringToName(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_StringToName");

	Params::UKismetStringLibrary_Conv_StringToName_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_StringToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::Conv_StringToInt(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_StringToInt");

	Params::UKismetStringLibrary_Conv_StringToInt_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_StringToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetStringLibrary::Conv_StringToFloat(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_StringToFloat");

	Params::UKismetStringLibrary_Conv_StringToFloat_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_StringToColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                OutConvertedColor                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               OutIsValid                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetStringLibrary::Conv_StringToColor(const class FString& InString, struct FLinearColor* OutConvertedColor, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_StringToColor");

	Params::UKismetStringLibrary_Conv_StringToColor_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutConvertedColor != nullptr)
		*OutConvertedColor = std::move(Parms.OutConvertedColor);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;

}


// Function Engine.KismetStringLibrary.Conv_RotatorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_RotatorToString(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_RotatorToString");

	Params::UKismetStringLibrary_Conv_RotatorToString_Params Parms{};

	Parms.InRot = InRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_ObjectToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     InObj                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_ObjectToString(class UObject* InObj)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_ObjectToString");

	Params::UKismetStringLibrary_Conv_ObjectToString_Params Parms{};

	Parms.InObj = InObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_NameToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_NameToString(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_NameToString");

	Params::UKismetStringLibrary_Conv_NameToString_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_IntVectorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                  InIntVec                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_IntVectorToString(const struct FIntVector& InIntVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_IntVectorToString");

	Params::UKismetStringLibrary_Conv_IntVectorToString_Params Parms{};

	Parms.InIntVec = InIntVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_IntToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              InInt                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_IntToString(int32 InInt)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_IntToString");

	Params::UKismetStringLibrary_Conv_IntToString_Params Parms{};

	Parms.InInt = InInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_FloatToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_FloatToString(float InFloat)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_FloatToString");

	Params::UKismetStringLibrary_Conv_FloatToString_Params Parms{};

	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_ColorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_ColorToString(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_ColorToString");

	Params::UKismetStringLibrary_Conv_ColorToString_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_ByteToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              InByte                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_ByteToString(uint8 InByte)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_ByteToString");

	Params::UKismetStringLibrary_Conv_ByteToString_Params Parms{};

	Parms.InByte = InByte;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Conv_BoolToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               InBool                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_BoolToString(bool InBool)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Conv_BoolToString");

	Params::UKismetStringLibrary_Conv_BoolToString_Params Parms{};

	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Contains
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      SearchIn                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Substring                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseCase                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSearchFromEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::Contains(const class FString& SearchIn, const class FString& Substring, bool bUseCase, bool bSearchFromEnd)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Contains");

	Params::UKismetStringLibrary_Contains_Params Parms{};

	Parms.SearchIn = SearchIn;
	Parms.Substring = Substring;
	Parms.bUseCase = bUseCase;
	Parms.bSearchFromEnd = bSearchFromEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.Concat_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      A                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      B                                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Concat_StrStr(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "Concat_StrStr");

	Params::UKismetStringLibrary_Concat_StrStr_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Vector2d
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   InVector2D                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Vector2d(const class FString& AppendTo, const class FString& Prefix, const struct FVector2D& InVector2D, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Vector2d");

	Params::UKismetStringLibrary_BuildString_Vector2d_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InVector2D = InVector2D;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Vector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InVector                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Vector(const class FString& AppendTo, const class FString& Prefix, const struct FVector& InVector, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Vector");

	Params::UKismetStringLibrary_BuildString_Vector_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InVector = InVector;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Rotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    InRot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Rotator(const class FString& AppendTo, const class FString& Prefix, const struct FRotator& InRot, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Rotator");

	Params::UKismetStringLibrary_BuildString_Rotator_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InRot = InRot;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Object
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     InObj                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Object(const class FString& AppendTo, const class FString& Prefix, class UObject* InObj, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Object");

	Params::UKismetStringLibrary_BuildString_Object_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InObj = InObj;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Name
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Name(const class FString& AppendTo, const class FString& Prefix, class FName InName, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Name");

	Params::UKismetStringLibrary_BuildString_Name_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InName = InName;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_IntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                  InIntVector                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_IntVector(const class FString& AppendTo, const class FString& Prefix, const struct FIntVector& InIntVector, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_IntVector");

	Params::UKismetStringLibrary_BuildString_IntVector_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InIntVector = InIntVector;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              InInt                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Int(const class FString& AppendTo, const class FString& Prefix, int32 InInt, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Int");

	Params::UKismetStringLibrary_BuildString_Int_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InInt = InInt;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InFloat                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Float(const class FString& AppendTo, const class FString& Prefix, float InFloat, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Float");

	Params::UKismetStringLibrary_BuildString_Float_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InFloat = InFloat;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Color
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Color(const class FString& AppendTo, const class FString& Prefix, const struct FLinearColor& InColor, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Color");

	Params::UKismetStringLibrary_BuildString_Color_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InColor = InColor;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringLibrary.BuildString_Bool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      AppendTo                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Prefix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               InBool                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Suffix                                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Bool(const class FString& AppendTo, const class FString& Prefix, bool InBool, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringLibrary", "BuildString_Bool");

	Params::UKismetStringLibrary_BuildString_Bool_Params Parms{};

	Parms.AppendTo = AppendTo;
	Parms.Prefix = Prefix;
	Parms.InBool = InBool;
	Parms.Suffix = Suffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.KismetStringTableLibrary
// (None)

class UClass* UKismetStringTableLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetStringTableLibrary");

	return Clss;
}


// KismetStringTableLibrary Engine.Default__KismetStringTableLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetStringTableLibrary* UKismetStringTableLibrary::GetDefaultObj()
{
	static class UKismetStringTableLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetStringTableLibrary*>(UKismetStringTableLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetStringTableLibrary.IsRegisteredTableId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        TableId                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringTableLibrary::IsRegisteredTableId(class FName TableId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringTableLibrary", "IsRegisteredTableId");

	Params::UKismetStringTableLibrary_IsRegisteredTableId_Params Parms{};

	Parms.TableId = TableId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringTableLibrary.IsRegisteredTableEntry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        TableId                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringTableLibrary::IsRegisteredTableEntry(class FName TableId, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringTableLibrary", "IsRegisteredTableEntry");

	Params::UKismetStringTableLibrary_IsRegisteredTableEntry_Params Parms{};

	Parms.TableId = TableId;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringTableLibrary.GetTableNamespace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        TableId                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringTableLibrary::GetTableNamespace(class FName TableId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringTableLibrary", "GetTableNamespace");

	Params::UKismetStringTableLibrary_GetTableNamespace_Params Parms{};

	Parms.TableId = TableId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringTableLibrary.GetTableEntrySourceString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        TableId                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringTableLibrary::GetTableEntrySourceString(class FName TableId, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringTableLibrary", "GetTableEntrySourceString");

	Params::UKismetStringTableLibrary_GetTableEntrySourceString_Params Parms{};

	Parms.TableId = TableId;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringTableLibrary.GetTableEntryMetaData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        TableId                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        MetaDataId                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringTableLibrary::GetTableEntryMetaData(class FName TableId, const class FString& Key, class FName MetaDataId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringTableLibrary", "GetTableEntryMetaData");

	Params::UKismetStringTableLibrary_GetTableEntryMetaData_Params Parms{};

	Parms.TableId = TableId;
	Parms.Key = Key;
	Parms.MetaDataId = MetaDataId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringTableLibrary.GetRegisteredStringTables
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UKismetStringTableLibrary::GetRegisteredStringTables()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringTableLibrary", "GetRegisteredStringTables");

	Params::UKismetStringTableLibrary_GetRegisteredStringTables_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringTableLibrary.GetMetaDataIdsFromStringTableEntry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        TableId                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UKismetStringTableLibrary::GetMetaDataIdsFromStringTableEntry(class FName TableId, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringTableLibrary", "GetMetaDataIdsFromStringTableEntry");

	Params::UKismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry_Params Parms{};

	Parms.TableId = TableId;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetStringTableLibrary.GetKeysFromStringTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        TableId                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetStringTableLibrary::GetKeysFromStringTable(class FName TableId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetStringTableLibrary", "GetKeysFromStringTable");

	Params::UKismetStringTableLibrary_GetKeysFromStringTable_Params Parms{};

	Parms.TableId = TableId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.KismetSystemLibrary
// (None)

class UClass* UKismetSystemLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetSystemLibrary");

	return Clss;
}


// KismetSystemLibrary Engine.Default__KismetSystemLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetSystemLibrary* UKismetSystemLibrary::GetDefaultObj()
{
	static class UKismetSystemLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetSystemLibrary*>(UKismetSystemLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetSystemLibrary.UnregisterForRemoteNotifications
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetSystemLibrary::UnregisterForRemoteNotifications()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "UnregisterForRemoteNotifications");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.UnloadPrimaryAssetList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>     PrimaryAssetIdList                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::UnloadPrimaryAssetList(TArray<struct FPrimaryAssetId>& PrimaryAssetIdList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "UnloadPrimaryAssetList");

	Params::UKismetSystemLibrary_UnloadPrimaryAssetList_Params Parms{};

	Parms.PrimaryAssetIdList = PrimaryAssetIdList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.UnloadPrimaryAsset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId             PrimaryAssetId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::UnloadPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "UnloadPrimaryAsset");

	Params::UKismetSystemLibrary_UnloadPrimaryAsset_Params Parms{};

	Parms.PrimaryAssetId = PrimaryAssetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.TransactObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::TransactObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "TransactObject");

	Params::UKismetSystemLibrary_TransactObject_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.StackTrace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetSystemLibrary::StackTrace()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "StackTrace");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SphereTraceSingleForObjects");

	Params::UKismetSystemLibrary_SphereTraceSingleForObjects_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.SphereTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, class FName ProfileName, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SphereTraceSingleByProfile");

	Params::UKismetSystemLibrary_SphereTraceSingleByProfile_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.SphereTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SphereTraceSingle");

	Params::UKismetSystemLibrary_SphereTraceSingle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SphereTraceMultiForObjects");

	Params::UKismetSystemLibrary_SphereTraceMultiForObjects_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.SphereTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, class FName ProfileName, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SphereTraceMultiByProfile");

	Params::UKismetSystemLibrary_SphereTraceMultiByProfile_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.SphereTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SphereTraceMulti");

	Params::UKismetSystemLibrary_SphereTraceMulti_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.SphereOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SpherePos                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SphereRadius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                      ComponentClassFilter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*> OutComponents                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereOverlapComponents(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<enum class EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SphereOverlapComponents");

	Params::UKismetSystemLibrary_SphereOverlapComponents_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SpherePos = SpherePos;
	Parms.SphereRadius = SphereRadius;
	Parms.ObjectTypes = ObjectTypes;
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = ActorsToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.SphereOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SpherePos                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SphereRadius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                      ActorClassFilter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereOverlapActors(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<enum class EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SphereOverlapActors");

	Params::UKismetSystemLibrary_SphereOverlapActors_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SpherePos = SpherePos;
	Parms.SphereRadius = SphereRadius;
	Parms.ObjectTypes = ObjectTypes;
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = ActorsToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      CategoryName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ShowPlatformSpecificLeaderboardScreen(const class FString& CategoryName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ShowPlatformSpecificLeaderboardScreen");

	Params::UKismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen_Params Parms{};

	Parms.CategoryName = CategoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*           SpecificPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ShowPlatformSpecificAchievementsScreen(class APlayerController* SpecificPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ShowPlatformSpecificAchievementsScreen");

	Params::UKismetSystemLibrary_ShowPlatformSpecificAchievementsScreen_Params Parms{};

	Parms.SpecificPlayer = SpecificPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.ShowInterstitialAd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetSystemLibrary::ShowInterstitialAd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ShowInterstitialAd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.ShowAdBanner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              AdIdIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShowOnBottomOfScreen                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ShowAdBanner(int32 AdIdIndex, bool bShowOnBottomOfScreen)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ShowAdBanner");

	Params::UKismetSystemLibrary_ShowAdBanner_Params Parms{};

	Parms.AdIdIndex = AdIdIndex;
	Parms.bShowOnBottomOfScreen = bShowOnBottomOfScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetWindowTitle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                        Title                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetWindowTitle(class FText& Title)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetWindowTitle");

	Params::UKismetSystemLibrary_SetWindowTitle_Params Parms{};

	Parms.Title = Title;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetVolumeButtonsHandledBySystem(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetVolumeButtonsHandledBySystem");

	Params::UKismetSystemLibrary_SetVolumeButtonsHandledBySystem_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetVectorPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetVectorPropertyByName(class UObject* Object, class FName PropertyName, struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetVectorPropertyByName");

	Params::UKismetSystemLibrary_SetVectorPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetUserActivity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUserActivity               UserActivity                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetUserActivity(struct FUserActivity& UserActivity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetUserActivity");

	Params::UKismetSystemLibrary_SetUserActivity_Params Parms{};

	Parms.UserActivity = UserActivity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetTransformPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetTransformPropertyByName(class UObject* Object, class FName PropertyName, struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetTransformPropertyByName");

	Params::UKismetSystemLibrary_SetTransformPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetTextPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetTextPropertyByName(class UObject* Object, class FName PropertyName, class FText& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetTextPropertyByName");

	Params::UKismetSystemLibrary_SetTextPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetSuppressViewportTransitionMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bState                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetSuppressViewportTransitionMessage(class UObject* WorldContextObject, bool bState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetSuppressViewportTransitionMessage");

	Params::UKismetSystemLibrary_SetSuppressViewportTransitionMessage_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetStructurePropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGenericStruct              Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetStructurePropertyByName(class UObject* Object, class FName PropertyName, struct FGenericStruct& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetStructurePropertyByName");

	Params::UKismetSystemLibrary_SetStructurePropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetStringPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Value                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetStringPropertyByName(class UObject* Object, class FName PropertyName, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetStringPropertyByName");

	Params::UKismetSystemLibrary_SetStringPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetSoftObjectPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>      Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetSoftObjectPropertyByName(class UObject* Object, class FName PropertyName, TSoftObjectPtr<class UObject>& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetSoftObjectPropertyByName");

	Params::UKismetSystemLibrary_SetSoftObjectPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetSoftClassPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UObject>       Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetSoftClassPropertyByName(class UObject* Object, class FName PropertyName, TSoftClassPtr<class UObject>& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetSoftClassPropertyByName");

	Params::UKismetSystemLibrary_SetSoftClassPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetRotatorPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetRotatorPropertyByName(class UObject* Object, class FName PropertyName, struct FRotator& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetRotatorPropertyByName");

	Params::UKismetSystemLibrary_SetRotatorPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetObjectPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetObjectPropertyByName(class UObject* Object, class FName PropertyName, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetObjectPropertyByName");

	Params::UKismetSystemLibrary_SetObjectPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetNamePropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetNamePropertyByName(class UObject* Object, class FName PropertyName, class FName& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetNamePropertyByName");

	Params::UKismetSystemLibrary_SetNamePropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetLinearColorPropertyByName(class UObject* Object, class FName PropertyName, struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetLinearColorPropertyByName");

	Params::UKismetSystemLibrary_SetLinearColorPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetIntPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetIntPropertyByName(class UObject* Object, class FName PropertyName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetIntPropertyByName");

	Params::UKismetSystemLibrary_SetIntPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetInterfacePropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IInterface> Value                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetInterfacePropertyByName(class UObject* Object, class FName PropertyName, TScriptInterface<class IInterface>& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetInterfacePropertyByName");

	Params::UKismetSystemLibrary_SetInterfacePropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetInt64PropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetInt64PropertyByName(class UObject* Object, class FName PropertyName, int64 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetInt64PropertyByName");

	Params::UKismetSystemLibrary_SetInt64PropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetFloatPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetFloatPropertyByName(class UObject* Object, class FName PropertyName, float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetFloatPropertyByName");

	Params::UKismetSystemLibrary_SetFloatPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCollisionProfileName       Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetCollisionProfileNameProperty(class UObject* Object, class FName PropertyName, struct FCollisionProfileName& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetCollisionProfileNameProperty");

	Params::UKismetSystemLibrary_SetCollisionProfileNameProperty_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetClassPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>         Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetClassPropertyByName(class UObject* Object, class FName PropertyName, TSubclassOf<class UObject> Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetClassPropertyByName");

	Params::UKismetSystemLibrary_SetClassPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetBytePropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetBytePropertyByName(class UObject* Object, class FName PropertyName, uint8 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetBytePropertyByName");

	Params::UKismetSystemLibrary_SetBytePropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.SetBoolPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        PropertyName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetBoolPropertyByName(class UObject* Object, class FName PropertyName, bool Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "SetBoolPropertyByName");

	Params::UKismetSystemLibrary_SetBoolPropertyByName_Params Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.RetriggerableDelay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo           LatentInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::RetriggerableDelay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "RetriggerableDelay");

	Params::UKismetSystemLibrary_RetriggerableDelay_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Duration = Duration;
	Parms.LatentInfo = LatentInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              ControllerId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ResetGamepadAssignmentToController(int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ResetGamepadAssignmentToController");

	Params::UKismetSystemLibrary_ResetGamepadAssignmentToController_Params Parms{};

	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.ResetGamepadAssignments
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetSystemLibrary::ResetGamepadAssignments()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ResetGamepadAssignments");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetSystemLibrary::RegisterForRemoteNotifications()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "RegisterForRemoteNotifications");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.QuitGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*           SpecificPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EQuitPreference         QuitPreference                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIgnorePlatformRestrictions                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::QuitGame(class UObject* WorldContextObject, class APlayerController* SpecificPlayer, enum class EQuitPreference QuitPreference, bool bIgnorePlatformRestrictions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "QuitGame");

	Params::UKismetSystemLibrary_QuitGame_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SpecificPlayer = SpecificPlayer;
	Parms.QuitPreference = QuitPreference;
	Parms.bIgnorePlatformRestrictions = bIgnorePlatformRestrictions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.PrintWarning
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::PrintWarning(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "PrintWarning");

	Params::UKismetSystemLibrary_PrintWarning_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.PrintText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        InText                                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                               bPrintToScreen                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPrintToLog                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TextColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::PrintText(class UObject* WorldContextObject, class FText InText, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "PrintText");

	Params::UKismetSystemLibrary_PrintText_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InText = InText;
	Parms.bPrintToScreen = bPrintToScreen;
	Parms.bPrintToLog = bPrintToLog;
	Parms.TextColor = TextColor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.PrintString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPrintToScreen                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bPrintToLog                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TextColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::PrintString(class UObject* WorldContextObject, const class FString& InString, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "PrintString");

	Params::UKismetSystemLibrary_PrintString_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InString = InString;
	Parms.bPrintToScreen = bPrintToScreen;
	Parms.bPrintToLog = bPrintToLog;
	Parms.TextColor = TextColor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature
// (Public, Delegate)
// Parameters:
// class UObject*                     Loaded                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::OnAssetLoaded__DelegateSignature(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "OnAssetLoaded__DelegateSignature");

	Params::UKismetSystemLibrary_OnAssetLoaded__DelegateSignature_Params Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);

}


// DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature
// (Public, Delegate)
// Parameters:
// TSubclassOf<class UObject>         Loaded                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::OnAssetClassLoaded__DelegateSignature(TSubclassOf<class UObject> Loaded)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "OnAssetClassLoaded__DelegateSignature");

	Params::UKismetSystemLibrary_OnAssetClassLoaded__DelegateSignature_Params Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);

}


// Function Engine.KismetSystemLibrary.NotEqual_SoftObjectReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      A                                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>      B                                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::NotEqual_SoftObjectReference(TSoftObjectPtr<class UObject>& A, TSoftObjectPtr<class UObject>& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "NotEqual_SoftObjectReference");

	Params::UKismetSystemLibrary_NotEqual_SoftObjectReference_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.NotEqual_SoftClassReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UObject>       A                                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UObject>       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::NotEqual_SoftClassReference(TSoftClassPtr<class UObject>& A, TSoftClassPtr<class UObject>& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "NotEqual_SoftClassReference");

	Params::UKismetSystemLibrary_NotEqual_SoftClassReference_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType           A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetType           B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::NotEqual_PrimaryAssetType(const struct FPrimaryAssetType& A, const struct FPrimaryAssetType& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "NotEqual_PrimaryAssetType");

	Params::UKismetSystemLibrary_NotEqual_PrimaryAssetType_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId             A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId             B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::NotEqual_PrimaryAssetId(const struct FPrimaryAssetId& A, const struct FPrimaryAssetId& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "NotEqual_PrimaryAssetId");

	Params::UKismetSystemLibrary_NotEqual_PrimaryAssetId_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.NormalizeFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InFilename                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::NormalizeFilename(const class FString& InFilename)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "NormalizeFilename");

	Params::UKismetSystemLibrary_NormalizeFilename_Params Parms{};

	Parms.InFilename = InFilename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MoveComponentTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*             Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TargetRelativeLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    TargetRelativeRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bEaseOut                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEaseIn                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OverTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForceShortestRotationPath                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EMoveComponentAction    MoveAction                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo           LatentInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::MoveComponentTo(class USceneComponent* Component, const struct FVector& TargetRelativeLocation, const struct FRotator& TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, enum class EMoveComponentAction MoveAction, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MoveComponentTo");

	Params::UKismetSystemLibrary_MoveComponentTo_Params Parms{};

	Parms.Component = Component;
	Parms.TargetRelativeLocation = TargetRelativeLocation;
	Parms.TargetRelativeRotation = TargetRelativeRotation;
	Parms.bEaseOut = bEaseOut;
	Parms.bEaseIn = bEaseIn;
	Parms.OverTime = OverTime;
	Parms.bForceShortestRotationPath = bForceShortestRotationPath;
	Parms.MoveAction = MoveAction;
	Parms.LatentInfo = LatentInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.MakeSoftObjectPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      PathString                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftObjectPath             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UKismetSystemLibrary::MakeSoftObjectPath(const class FString& PathString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeSoftObjectPath");

	Params::UKismetSystemLibrary_MakeSoftObjectPath_Params Parms{};

	Parms.PathString = PathString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MakeSoftClassPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      PathString                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftClassPath              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

struct FSoftClassPath UKismetSystemLibrary::MakeSoftClassPath(const class FString& PathString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeSoftClassPath");

	Params::UKismetSystemLibrary_MakeSoftClassPath_Params Parms{};

	Parms.PathString = PathString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MakeLiteralText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        Value                                                            (Parm, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetSystemLibrary::MakeLiteralText(class FText Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeLiteralText");

	Params::UKismetSystemLibrary_MakeLiteralText_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MakeLiteralString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Value                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::MakeLiteralString(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeLiteralString");

	Params::UKismetSystemLibrary_MakeLiteralString_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MakeLiteralName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKismetSystemLibrary::MakeLiteralName(class FName Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeLiteralName");

	Params::UKismetSystemLibrary_MakeLiteralName_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MakeLiteralInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::MakeLiteralInt(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeLiteralInt");

	Params::UKismetSystemLibrary_MakeLiteralInt_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MakeLiteralFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::MakeLiteralFloat(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeLiteralFloat");

	Params::UKismetSystemLibrary_MakeLiteralFloat_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MakeLiteralByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetSystemLibrary::MakeLiteralByte(uint8 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeLiteralByte");

	Params::UKismetSystemLibrary_MakeLiteralByte_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.MakeLiteralBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::MakeLiteralBool(bool Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "MakeLiteralBool");

	Params::UKismetSystemLibrary_MakeLiteralBool_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.LoadInterstitialAd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              AdIdIndex                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LoadInterstitialAd(int32 AdIdIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LoadInterstitialAd");

	Params::UKismetSystemLibrary_LoadInterstitialAd_Params Parms{};

	Parms.AdIdIndex = AdIdIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.LoadAssetClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UObject>       AssetClass                                                       (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// UDelegateProperty_                 OnLoaded                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FLatentActionInfo           LatentInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LoadAssetClass(class UObject* WorldContextObject, TSoftClassPtr<class UObject> AssetClass, UDelegateProperty_ OnLoaded, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LoadAssetClass");

	Params::UKismetSystemLibrary_LoadAssetClass_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AssetClass = AssetClass;
	Parms.OnLoaded = OnLoaded;
	Parms.LatentInfo = LatentInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.LoadAsset_Blocking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObject>      Asset                                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::LoadAsset_Blocking(TSoftObjectPtr<class UObject> Asset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LoadAsset_Blocking");

	Params::UKismetSystemLibrary_LoadAsset_Blocking_Params Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.LoadAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>      Asset                                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// UDelegateProperty_                 OnLoaded                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FLatentActionInfo           LatentInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LoadAsset(class UObject* WorldContextObject, TSoftObjectPtr<class UObject> Asset, UDelegateProperty_ OnLoaded, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LoadAsset");

	Params::UKismetSystemLibrary_LoadAsset_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Asset = Asset;
	Parms.OnLoaded = OnLoaded;
	Parms.LatentInfo = LatentInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.LineTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LineTraceSingleForObjects");

	Params::UKismetSystemLibrary_LineTraceSingleForObjects_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.LineTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, class FName ProfileName, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LineTraceSingleByProfile");

	Params::UKismetSystemLibrary_LineTraceSingleByProfile_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.LineTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LineTraceSingle");

	Params::UKismetSystemLibrary_LineTraceSingle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.LineTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LineTraceMultiForObjects");

	Params::UKismetSystemLibrary_LineTraceMultiForObjects_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.LineTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, class FName ProfileName, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LineTraceMultiByProfile");

	Params::UKismetSystemLibrary_LineTraceMultiByProfile_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.LineTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LineTraceMulti");

	Params::UKismetSystemLibrary_LineTraceMulti_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.LaunchURL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      URL                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LaunchURL(const class FString& URL)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "LaunchURL");

	Params::UKismetSystemLibrary_LaunchURL_Params Parms{};

	Parms.URL = URL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_UnPauseTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_UnPauseTimerHandle");

	Params::UKismetSystemLibrary_K2_UnPauseTimerHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_UnPauseTimerDelegate(UDelegateProperty_ Delegate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_UnPauseTimerDelegate");

	Params::UKismetSystemLibrary_K2_UnPauseTimerDelegate_Params Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_UnPauseTimer(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_UnPauseTimer");

	Params::UKismetSystemLibrary_K2_UnPauseTimer_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_TimerExistsHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_TimerExistsHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_TimerExistsHandle");

	Params::UKismetSystemLibrary_K2_TimerExistsHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_TimerExistsDelegate(UDelegateProperty_ Delegate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_TimerExistsDelegate");

	Params::UKismetSystemLibrary_K2_TimerExistsDelegate_Params Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_TimerExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_TimerExists(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_TimerExists");

	Params::UKismetSystemLibrary_K2_TimerExists_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_SetTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLooping                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InitialStartDelay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InitialStartDelayVariance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle UKismetSystemLibrary::K2_SetTimerDelegate(UDelegateProperty_ Delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_SetTimerDelegate");

	Params::UKismetSystemLibrary_K2_SetTimerDelegate_Params Parms{};

	Parms.Delegate = Delegate;
	Parms.Time = Time;
	Parms.bLooping = bLooping;
	Parms.InitialStartDelay = InitialStartDelay;
	Parms.InitialStartDelayVariance = InitialStartDelayVariance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_SetTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Time                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bLooping                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InitialStartDelay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InitialStartDelayVariance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle UKismetSystemLibrary::K2_SetTimer(class UObject* Object, const class FString& FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_SetTimer");

	Params::UKismetSystemLibrary_K2_SetTimer_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;
	Parms.Time = Time;
	Parms.bLooping = bLooping;
	Parms.InitialStartDelay = InitialStartDelay;
	Parms.InitialStartDelayVariance = InitialStartDelayVariance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_PauseTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_PauseTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_PauseTimerHandle");

	Params::UKismetSystemLibrary_K2_PauseTimerHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_PauseTimerDelegate(UDelegateProperty_ Delegate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_PauseTimerDelegate");

	Params::UKismetSystemLibrary_K2_PauseTimerDelegate_Params Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_PauseTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_PauseTimer(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_PauseTimer");

	Params::UKismetSystemLibrary_K2_PauseTimer_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsValidTimerHandle(const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_IsValidTimerHandle");

	Params::UKismetSystemLibrary_K2_IsValidTimerHandle_Params Parms{};

	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerPausedHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_IsTimerPausedHandle");

	Params::UKismetSystemLibrary_K2_IsTimerPausedHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerPausedDelegate(UDelegateProperty_ Delegate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_IsTimerPausedDelegate");

	Params::UKismetSystemLibrary_K2_IsTimerPausedDelegate_Params Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_IsTimerPaused
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerPaused(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_IsTimerPaused");

	Params::UKismetSystemLibrary_K2_IsTimerPaused_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerActiveHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_IsTimerActiveHandle");

	Params::UKismetSystemLibrary_K2_IsTimerActiveHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerActiveDelegate(UDelegateProperty_ Delegate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_IsTimerActiveDelegate");

	Params::UKismetSystemLibrary_K2_IsTimerActiveDelegate_Params Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_IsTimerActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerActive(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_IsTimerActive");

	Params::UKismetSystemLibrary_K2_IsTimerActive_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTimerHandle                Handle                                                           (Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                ReturnValue                                                      (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle UKismetSystemLibrary::K2_InvalidateTimerHandle(struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_InvalidateTimerHandle");

	Params::UKismetSystemLibrary_K2_InvalidateTimerHandle_Params Parms{};

	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerRemainingTimeHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_GetTimerRemainingTimeHandle");

	Params::UKismetSystemLibrary_K2_GetTimerRemainingTimeHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerRemainingTimeDelegate(UDelegateProperty_ Delegate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_GetTimerRemainingTimeDelegate");

	Params::UKismetSystemLibrary_K2_GetTimerRemainingTimeDelegate_Params Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerRemainingTime(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_GetTimerRemainingTime");

	Params::UKismetSystemLibrary_K2_GetTimerRemainingTime_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerElapsedTimeHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_GetTimerElapsedTimeHandle");

	Params::UKismetSystemLibrary_K2_GetTimerElapsedTimeHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerElapsedTimeDelegate(UDelegateProperty_ Delegate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_GetTimerElapsedTimeDelegate");

	Params::UKismetSystemLibrary_K2_GetTimerElapsedTimeDelegate_Params Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerElapsedTime(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_GetTimerElapsedTime");

	Params::UKismetSystemLibrary_K2_GetTimerElapsedTime_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.K2_ClearTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_ClearTimerHandle(class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_ClearTimerHandle");

	Params::UKismetSystemLibrary_K2_ClearTimerHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// UDelegateProperty_                 Delegate                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_ClearTimerDelegate(UDelegateProperty_ Delegate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_ClearTimerDelegate");

	Params::UKismetSystemLibrary_K2_ClearTimerDelegate_Params Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_ClearTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      FunctionName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_ClearTimer(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_ClearTimer");

	Params::UKismetSystemLibrary_K2_ClearTimer_Params Parms{};

	Parms.Object = Object;
	Parms.FunctionName = FunctionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.K2_ClearAndInvalidateTimerHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                Handle                                                           (Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_ClearAndInvalidateTimerHandle(class UObject* WorldContextObject, struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "K2_ClearAndInvalidateTimerHandle");

	Params::UKismetSystemLibrary_K2_ClearAndInvalidateTimerHandle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = Handle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.IsValidSoftObjectReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      SoftObjectReference                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidSoftObjectReference(TSoftObjectPtr<class UObject>& SoftObjectReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsValidSoftObjectReference");

	Params::UKismetSystemLibrary_IsValidSoftObjectReference_Params Parms{};

	Parms.SoftObjectReference = SoftObjectReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsValidSoftClassReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UObject>       SoftClassReference                                               (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidSoftClassReference(TSoftClassPtr<class UObject>& SoftClassReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsValidSoftClassReference");

	Params::UKismetSystemLibrary_IsValidSoftClassReference_Params Parms{};

	Parms.SoftClassReference = SoftClassReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsValidPrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType           PrimaryAssetType                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidPrimaryAssetType(const struct FPrimaryAssetType& PrimaryAssetType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsValidPrimaryAssetType");

	Params::UKismetSystemLibrary_IsValidPrimaryAssetType_Params Parms{};

	Parms.PrimaryAssetType = PrimaryAssetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsValidPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId             PrimaryAssetId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsValidPrimaryAssetId");

	Params::UKismetSystemLibrary_IsValidPrimaryAssetId_Params Parms{};

	Parms.PrimaryAssetId = PrimaryAssetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsValidClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                      Class                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidClass(class UClass* Class)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsValidClass");

	Params::UKismetSystemLibrary_IsValidClass_Params Parms{};

	Parms.Class = Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValid(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsValid");

	Params::UKismetSystemLibrary_IsValid_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsUnattended
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsUnattended()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsUnattended");

	Params::UKismetSystemLibrary_IsUnattended_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsStandalone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsStandalone(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsStandalone");

	Params::UKismetSystemLibrary_IsStandalone_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsServer(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsServer");

	Params::UKismetSystemLibrary_IsServer_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsScreensaverEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsScreensaverEnabled()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsScreensaverEnabled");

	Params::UKismetSystemLibrary_IsScreensaverEnabled_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsPackagedForDistribution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsPackagedForDistribution()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsPackagedForDistribution");

	Params::UKismetSystemLibrary_IsPackagedForDistribution_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsLoggedIn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*           SpecificPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsLoggedIn(class APlayerController* SpecificPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsLoggedIn");

	Params::UKismetSystemLibrary_IsLoggedIn_Params Parms{};

	Parms.SpecificPlayer = SpecificPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsInterstitialAdRequested
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsInterstitialAdRequested()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsInterstitialAdRequested");

	Params::UKismetSystemLibrary_IsInterstitialAdRequested_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsInterstitialAdAvailable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsInterstitialAdAvailable()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsInterstitialAdAvailable");

	Params::UKismetSystemLibrary_IsInterstitialAdAvailable_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsDedicatedServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsDedicatedServer(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsDedicatedServer");

	Params::UKismetSystemLibrary_IsDedicatedServer_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ControllerId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsControllerAssignedToGamepad(int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "IsControllerAssignedToGamepad");

	Params::UKismetSystemLibrary_IsControllerAssignedToGamepad_Params Parms{};

	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.HideAdBanner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetSystemLibrary::HideAdBanner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "HideAdBanner");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetVolumeButtonsHandledBySystem()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetVolumeButtonsHandledBySystem");

	Params::UKismetSystemLibrary_GetVolumeButtonsHandledBySystem_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetUniqueDeviceId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetUniqueDeviceId()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetUniqueDeviceId");

	Params::UKismetSystemLibrary_GetUniqueDeviceId_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FIntPoint>           Resolutions                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetSupportedFullscreenResolutions(TArray<struct FIntPoint>* Resolutions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetSupportedFullscreenResolutions");

	Params::UKismetSystemLibrary_GetSupportedFullscreenResolutions_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Resolutions != nullptr)
		*Resolutions = std::move(Parms.Resolutions);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetSoftObjectReferenceFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId             PrimaryAssetId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>      ReturnValue                                                      (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UKismetSystemLibrary::GetSoftObjectReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetSoftObjectReferenceFromPrimaryAssetId");

	Params::UKismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId_Params Parms{};

	Parms.PrimaryAssetId = PrimaryAssetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetSoftClassReferenceFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId             PrimaryAssetId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UObject>       ReturnValue                                                      (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UObject> UKismetSystemLibrary::GetSoftClassReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetSoftClassReferenceFromPrimaryAssetId");

	Params::UKismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId_Params Parms{};

	Parms.PrimaryAssetId = PrimaryAssetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetRenderingMaterialQualityLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetRenderingMaterialQualityLevel");

	Params::UKismetSystemLibrary_GetRenderingMaterialQualityLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetRenderingDetailMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetRenderingDetailMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetRenderingDetailMode");

	Params::UKismetSystemLibrary_GetRenderingDetailMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetProjectSavedDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetProjectSavedDirectory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetProjectSavedDirectory");

	Params::UKismetSystemLibrary_GetProjectSavedDirectory_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetProjectDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetProjectDirectory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetProjectDirectory");

	Params::UKismetSystemLibrary_GetProjectDirectory_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetProjectContentDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetProjectContentDirectory()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetProjectContentDirectory");

	Params::UKismetSystemLibrary_GetProjectContentDirectory_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetsWithBundleState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                RequiredBundles                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                ExcludedBundles                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetType>   ValidTypes                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bForceCurrentState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>     OutPrimaryAssetIdList                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetPrimaryAssetsWithBundleState(TArray<class FName>& RequiredBundles, TArray<class FName>& ExcludedBundles, TArray<struct FPrimaryAssetType>& ValidTypes, bool bForceCurrentState, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPrimaryAssetsWithBundleState");

	Params::UKismetSystemLibrary_GetPrimaryAssetsWithBundleState_Params Parms{};

	Parms.RequiredBundles = RequiredBundles;
	Parms.ExcludedBundles = ExcludedBundles;
	Parms.ValidTypes = ValidTypes;
	Parms.bForceCurrentState = bForceCurrentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPrimaryAssetIdList != nullptr)
		*OutPrimaryAssetIdList = std::move(Parms.OutPrimaryAssetIdList);

}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdList
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetType           PrimaryAssetType                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>     OutPrimaryAssetIdList                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetPrimaryAssetIdList(const struct FPrimaryAssetType& PrimaryAssetType, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPrimaryAssetIdList");

	Params::UKismetSystemLibrary_GetPrimaryAssetIdList_Params Parms{};

	Parms.PrimaryAssetType = PrimaryAssetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutPrimaryAssetIdList != nullptr)
		*OutPrimaryAssetIdList = std::move(Parms.OutPrimaryAssetIdList);

}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftObjectReference
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      SoftObjectReference                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromSoftObjectReference(TSoftObjectPtr<class UObject> SoftObjectReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPrimaryAssetIdFromSoftObjectReference");

	Params::UKismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference_Params Parms{};

	Parms.SoftObjectReference = SoftObjectReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftClassReference
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UObject>       SoftClassReference                                               (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromSoftClassReference(TSoftClassPtr<class UObject> SoftClassReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPrimaryAssetIdFromSoftClassReference");

	Params::UKismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference_Params Parms{};

	Parms.SoftClassReference = SoftClassReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromObject
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPrimaryAssetIdFromObject");

	Params::UKismetSystemLibrary_GetPrimaryAssetIdFromObject_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromClass
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>         Class                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromClass(TSubclassOf<class UObject> Class)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPrimaryAssetIdFromClass");

	Params::UKismetSystemLibrary_GetPrimaryAssetIdFromClass_Params Parms{};

	Parms.Class = Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetPreferredLanguages
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetSystemLibrary::GetPreferredLanguages()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPreferredLanguages");

	Params::UKismetSystemLibrary_GetPreferredLanguages_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetPlatformUserName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetPlatformUserName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPlatformUserName");

	Params::UKismetSystemLibrary_GetPlatformUserName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetPathName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetPathName(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetPathName");

	Params::UKismetSystemLibrary_GetPathName_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetOuterObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::GetOuterObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetOuterObject");

	Params::UKismetSystemLibrary_GetOuterObject_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetObjectName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetObjectName(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetObjectName");

	Params::UKismetSystemLibrary_GetObjectName_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetObjectFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId             PrimaryAssetId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::GetObjectFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetObjectFromPrimaryAssetId");

	Params::UKismetSystemLibrary_GetObjectFromPrimaryAssetId_Params Parms{};

	Parms.PrimaryAssetId = PrimaryAssetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetMinYResolutionForUI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetMinYResolutionForUI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetMinYResolutionForUI");

	Params::UKismetSystemLibrary_GetMinYResolutionForUI_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetMinYResolutionFor3DView
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetMinYResolutionFor3DView()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetMinYResolutionFor3DView");

	Params::UKismetSystemLibrary_GetMinYResolutionFor3DView_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetLocalCurrencySymbol()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetLocalCurrencySymbol");

	Params::UKismetSystemLibrary_GetLocalCurrencySymbol_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetLocalCurrencyCode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetLocalCurrencyCode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetLocalCurrencyCode");

	Params::UKismetSystemLibrary_GetLocalCurrencyCode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetGameTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::GetGameTimeInSeconds(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetGameTimeInSeconds");

	Params::UKismetSystemLibrary_GetGameTimeInSeconds_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetGamepadControllerName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ControllerId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetGamepadControllerName(int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetGamepadControllerName");

	Params::UKismetSystemLibrary_GetGamepadControllerName_Params Parms{};

	Parms.ControllerId = ControllerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetGameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetGameName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetGameName");

	Params::UKismetSystemLibrary_GetGameName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetGameBundleId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetGameBundleId()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetGameBundleId");

	Params::UKismetSystemLibrary_GetGameBundleId_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetEngineVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetEngineVersion()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetEngineVersion");

	Params::UKismetSystemLibrary_GetEngineVersion_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetDisplayName(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetDisplayName");

	Params::UKismetSystemLibrary_GetDisplayName_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetDeviceId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetDeviceId()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetDeviceId");

	Params::UKismetSystemLibrary_GetDeviceId_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetDefaultLocale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetDefaultLocale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetDefaultLocale");

	Params::UKismetSystemLibrary_GetDefaultLocale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetDefaultLanguage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetDefaultLanguage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetDefaultLanguage");

	Params::UKismetSystemLibrary_GetDefaultLanguage_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetCurrentBundleState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId             PrimaryAssetId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bForceCurrentState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                OutBundles                                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetCurrentBundleState(const struct FPrimaryAssetId& PrimaryAssetId, bool bForceCurrentState, TArray<class FName>* OutBundles)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetCurrentBundleState");

	Params::UKismetSystemLibrary_GetCurrentBundleState_Params Parms{};

	Parms.PrimaryAssetId = PrimaryAssetId;
	Parms.bForceCurrentState = bForceCurrentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutBundles != nullptr)
		*OutBundles = std::move(Parms.OutBundles);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetConvenientWindowedResolutions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FIntPoint>           Resolutions                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetConvenientWindowedResolutions(TArray<struct FIntPoint>* Resolutions)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetConvenientWindowedResolutions");

	Params::UKismetSystemLibrary_GetConvenientWindowedResolutions_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Resolutions != nullptr)
		*Resolutions = std::move(Parms.Resolutions);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetConsoleVariableIntValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      VariableName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetConsoleVariableIntValue(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetConsoleVariableIntValue");

	Params::UKismetSystemLibrary_GetConsoleVariableIntValue_Params Parms{};

	Parms.VariableName = VariableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetConsoleVariableFloatValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      VariableName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::GetConsoleVariableFloatValue(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetConsoleVariableFloatValue");

	Params::UKismetSystemLibrary_GetConsoleVariableFloatValue_Params Parms{};

	Parms.VariableName = VariableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetConsoleVariableBoolValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      VariableName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetConsoleVariableBoolValue(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetConsoleVariableBoolValue");

	Params::UKismetSystemLibrary_GetConsoleVariableBoolValue_Params Parms{};

	Parms.VariableName = VariableName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetComponentBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USceneComponent*             Component                                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxExtent                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              SphereRadius                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetComponentBounds(class USceneComponent* Component, struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetComponentBounds");

	Params::UKismetSystemLibrary_GetComponentBounds_Params Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);

	if (SphereRadius != nullptr)
		*SphereRadius = Parms.SphereRadius;

}


// Function Engine.KismetSystemLibrary.GetCommandLine
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetCommandLine()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetCommandLine");

	Params::UKismetSystemLibrary_GetCommandLine_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetClassFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId             PrimaryAssetId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UObject> UKismetSystemLibrary::GetClassFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetClassFromPrimaryAssetId");

	Params::UKismetSystemLibrary_GetClassFromPrimaryAssetId_Params Parms{};

	Parms.PrimaryAssetId = PrimaryAssetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetClassDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                      Class                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetClassDisplayName(class UClass* Class)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetClassDisplayName");

	Params::UKismetSystemLibrary_GetClassDisplayName_Params Parms{};

	Parms.Class = Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetAdIDCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetAdIDCount()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetAdIDCount");

	Params::UKismetSystemLibrary_GetAdIDCount_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.GetActorListFromComponentList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*> ComponentList                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UClass*                      ActorClassFilter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActorList                                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetActorListFromComponentList(TArray<class UPrimitiveComponent*>& ComponentList, class UClass* ActorClassFilter, TArray<class AActor*>* OutActorList)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetActorListFromComponentList");

	Params::UKismetSystemLibrary_GetActorListFromComponentList_Params Parms{};

	Parms.ComponentList = ComponentList;
	Parms.ActorClassFilter = ActorClassFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActorList != nullptr)
		*OutActorList = std::move(Parms.OutActorList);

}


// Function Engine.KismetSystemLibrary.GetActorBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                      Actor                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxExtent                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetActorBounds(class AActor* Actor, struct FVector* Origin, struct FVector* BoxExtent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "GetActorBounds");

	Params::UKismetSystemLibrary_GetActorBounds_Params Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);

}


// Function Engine.KismetSystemLibrary.ForceCloseAdBanner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetSystemLibrary::ForceCloseAdBanner()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ForceCloseAdBanner");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.FlushPersistentDebugLines
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::FlushPersistentDebugLines(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "FlushPersistentDebugLines");

	Params::UKismetSystemLibrary_FlushPersistentDebugLines_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.FlushDebugStrings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::FlushDebugStrings(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "FlushDebugStrings");

	Params::UKismetSystemLibrary_FlushDebugStrings_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.ExecuteConsoleCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Command                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*           SpecificPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ExecuteConsoleCommand(class UObject* WorldContextObject, const class FString& Command, class APlayerController* SpecificPlayer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ExecuteConsoleCommand");

	Params::UKismetSystemLibrary_ExecuteConsoleCommand_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Command = Command;
	Parms.SpecificPlayer = SpecificPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.EqualEqual_SoftObjectReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      A                                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>      B                                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::EqualEqual_SoftObjectReference(TSoftObjectPtr<class UObject>& A, TSoftObjectPtr<class UObject>& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "EqualEqual_SoftObjectReference");

	Params::UKismetSystemLibrary_EqualEqual_SoftObjectReference_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.EqualEqual_SoftClassReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UObject>       A                                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UObject>       B                                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::EqualEqual_SoftClassReference(TSoftClassPtr<class UObject>& A, TSoftClassPtr<class UObject>& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "EqualEqual_SoftClassReference");

	Params::UKismetSystemLibrary_EqualEqual_SoftClassReference_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType           A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetType           B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::EqualEqual_PrimaryAssetType(const struct FPrimaryAssetType& A, const struct FPrimaryAssetType& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "EqualEqual_PrimaryAssetType");

	Params::UKismetSystemLibrary_EqualEqual_PrimaryAssetType_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId             A                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId             B                                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::EqualEqual_PrimaryAssetId(const struct FPrimaryAssetId& A, const struct FPrimaryAssetId& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "EqualEqual_PrimaryAssetId");

	Params::UKismetSystemLibrary_EqualEqual_PrimaryAssetId_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.EndTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::EndTransaction()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "EndTransaction");

	Params::UKismetSystemLibrary_EndTransaction_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.DrawDebugString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     TextLocation                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Text                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                      TestBaseActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TextColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugString(class UObject* WorldContextObject, const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugString");

	Params::UKismetSystemLibrary_DrawDebugString_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextLocation = TextLocation;
	Parms.Text = Text;
	Parms.TestBaseActor = TestBaseActor;
	Parms.TextColor = TextColor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugSphere
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Center                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Segments                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugSphere(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugSphere");

	Params::UKismetSystemLibrary_DrawDebugSphere_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = Center;
	Parms.Radius = Radius;
	Parms.Segments = Segments;
	Parms.LineColor = LineColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Position                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Size                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                PointColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugPoint(class UObject* WorldContextObject, const struct FVector& Position, float Size, const struct FLinearColor& PointColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugPoint");

	Params::UKismetSystemLibrary_DrawDebugPoint_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = Position;
	Parms.Size = Size;
	Parms.PointColor = PointColor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                      PlaneCoordinates                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Size                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                PlaneColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugPlane(class UObject* WorldContextObject, struct FPlane& PlaneCoordinates, const struct FVector& Location, float Size, const struct FLinearColor& PlaneColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugPlane");

	Params::UKismetSystemLibrary_DrawDebugPlane_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlaneCoordinates = PlaneCoordinates;
	Parms.Location = Location;
	Parms.Size = Size;
	Parms.PlaneColor = PlaneColor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineStart                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineEnd                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugLine(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugLine");

	Params::UKismetSystemLibrary_DrawDebugLine_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LineStart = LineStart;
	Parms.LineEnd = LineEnd;
	Parms.LineColor = LineColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugFrustum
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  FrustumTransform                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FLinearColor                FrustumColor                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugFrustum(class UObject* WorldContextObject, struct FTransform& FrustumTransform, const struct FLinearColor& FrustumColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugFrustum");

	Params::UKismetSystemLibrary_DrawDebugFrustum_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FrustumTransform = FrustumTransform;
	Parms.FrustumColor = FrustumColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDebugFloatHistory          FloatHistory                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform                  DrawTransform                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                   DrawSize                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                DrawColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugFloatHistoryTransform(class UObject* WorldContextObject, struct FDebugFloatHistory& FloatHistory, struct FTransform& DrawTransform, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugFloatHistoryTransform");

	Params::UKismetSystemLibrary_DrawDebugFloatHistoryTransform_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FloatHistory = FloatHistory;
	Parms.DrawTransform = DrawTransform;
	Parms.DrawSize = DrawSize;
	Parms.DrawColor = DrawColor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDebugFloatHistory          FloatHistory                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                     DrawLocation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   DrawSize                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                DrawColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugFloatHistoryLocation(class UObject* WorldContextObject, struct FDebugFloatHistory& FloatHistory, const struct FVector& DrawLocation, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugFloatHistoryLocation");

	Params::UKismetSystemLibrary_DrawDebugFloatHistoryLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FloatHistory = FloatHistory;
	Parms.DrawLocation = DrawLocation;
	Parms.DrawSize = DrawSize;
	Parms.DrawColor = DrawColor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugCylinder
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              Segments                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCylinder(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugCylinder");

	Params::UKismetSystemLibrary_DrawDebugCylinder_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.Segments = Segments;
	Parms.LineColor = LineColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     AxisLoc                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    AxisRot                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCoordinateSystem(class UObject* WorldContextObject, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugCoordinateSystem");

	Params::UKismetSystemLibrary_DrawDebugCoordinateSystem_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AxisLoc = AxisLoc;
	Parms.AxisRot = AxisRot;
	Parms.Scale = Scale;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Direction                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Length                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AngleWidth                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AngleHeight                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumSides                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugConeInDegrees(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugConeInDegrees");

	Params::UKismetSystemLibrary_DrawDebugConeInDegrees_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = Origin;
	Parms.Direction = Direction;
	Parms.Length = Length;
	Parms.AngleWidth = AngleWidth;
	Parms.AngleHeight = AngleHeight;
	Parms.NumSides = NumSides;
	Parms.LineColor = LineColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugCone
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Origin                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Direction                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Length                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AngleWidth                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AngleHeight                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumSides                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCone(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugCone");

	Params::UKismetSystemLibrary_DrawDebugCone_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = Origin;
	Parms.Direction = Direction;
	Parms.Length = Length;
	Parms.AngleWidth = AngleWidth;
	Parms.AngleHeight = AngleHeight;
	Parms.NumSides = NumSides;
	Parms.LineColor = LineColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugCircle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Center                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              NumSegments                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     YAxis                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ZAxis                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bDrawAxis                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCircle(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 NumSegments, const struct FLinearColor& LineColor, float Duration, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugCircle");

	Params::UKismetSystemLibrary_DrawDebugCircle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = Center;
	Parms.Radius = Radius;
	Parms.NumSegments = NumSegments;
	Parms.LineColor = LineColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;
	Parms.YAxis = YAxis;
	Parms.ZAxis = ZAxis;
	Parms.bDrawAxis = bDrawAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugCapsule
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Center                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCapsule(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugCapsule");

	Params::UKismetSystemLibrary_DrawDebugCapsule_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = Center;
	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;
	Parms.Rotation = Rotation;
	Parms.LineColor = LineColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugCamera
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ACameraActor*                CameraActor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                CameraColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCamera(class ACameraActor* CameraActor, const struct FLinearColor& CameraColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugCamera");

	Params::UKismetSystemLibrary_DrawDebugCamera_Params Parms{};

	Parms.CameraActor = CameraActor;
	Parms.CameraColor = CameraColor;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Center                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Extent                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugBox(class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugBox");

	Params::UKismetSystemLibrary_DrawDebugBox_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = Center;
	Parms.Extent = Extent;
	Parms.LineColor = LineColor;
	Parms.Rotation = Rotation;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DrawDebugArrow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineStart                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     LineEnd                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ArrowSize                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                LineColor                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugArrow(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DrawDebugArrow");

	Params::UKismetSystemLibrary_DrawDebugArrow_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LineStart = LineStart;
	Parms.LineEnd = LineEnd;
	Parms.ArrowSize = ArrowSize;
	Parms.LineColor = LineColor;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.DoesImplementInterface
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     TestObject                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>      Interface                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::DoesImplementInterface(class UObject* TestObject, TSubclassOf<class IInterface> Interface)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "DoesImplementInterface");

	Params::UKismetSystemLibrary_DoesImplementInterface_Params Parms{};

	Parms.TestObject = TestObject;
	Parms.Interface = Interface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Delay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Duration                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo           LatentInfo                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::Delay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Delay");

	Params::UKismetSystemLibrary_Delay_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Duration = Duration;
	Parms.LatentInfo = LatentInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     ObjectToModify                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::CreateCopyForUndoBuffer(class UObject* ObjectToModify)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CreateCopyForUndoBuffer");

	Params::UKismetSystemLibrary_CreateCopyForUndoBuffer_Params Parms{};

	Parms.ObjectToModify = ObjectToModify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.ConvertToRelativePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Filename                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::ConvertToRelativePath(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ConvertToRelativePath");

	Params::UKismetSystemLibrary_ConvertToRelativePath_Params Parms{};

	Parms.Filename = Filename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.ConvertToAbsolutePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Filename                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::ConvertToAbsolutePath(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ConvertToAbsolutePath");

	Params::UKismetSystemLibrary_ConvertToAbsolutePath_Params Parms{};

	Parms.Filename = Filename;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_SoftObjPathToSoftObjRef
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath             SoftObjectPath                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>      ReturnValue                                                      (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UKismetSystemLibrary::Conv_SoftObjPathToSoftObjRef(struct FSoftObjectPath& SoftObjectPath)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_SoftObjPathToSoftObjRef");

	Params::UKismetSystemLibrary_Conv_SoftObjPathToSoftObjRef_Params Parms{};

	Parms.SoftObjectPath = SoftObjectPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      SoftObjectReference                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::Conv_SoftObjectReferenceToString(TSoftObjectPtr<class UObject>& SoftObjectReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_SoftObjectReferenceToString");

	Params::UKismetSystemLibrary_Conv_SoftObjectReferenceToString_Params Parms{};

	Parms.SoftObjectReference = SoftObjectReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>      SoftObject                                                       (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::Conv_SoftObjectReferenceToObject(TSoftObjectPtr<class UObject>& SoftObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_SoftObjectReferenceToObject");

	Params::UKismetSystemLibrary_Conv_SoftObjectReferenceToObject_Params Parms{};

	Parms.SoftObject = SoftObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UObject>       SoftClassReference                                               (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::Conv_SoftClassReferenceToString(TSoftClassPtr<class UObject>& SoftClassReference)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_SoftClassReferenceToString");

	Params::UKismetSystemLibrary_Conv_SoftClassReferenceToString_Params Parms{};

	Parms.SoftClassReference = SoftClassReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UObject>       SoftClass                                                        (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UObject> UKismetSystemLibrary::Conv_SoftClassReferenceToClass(TSoftClassPtr<class UObject>& SoftClass)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_SoftClassReferenceToClass");

	Params::UKismetSystemLibrary_Conv_SoftClassReferenceToClass_Params Parms{};

	Parms.SoftClass = SoftClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_PrimaryAssetTypeToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType           PrimaryAssetType                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::Conv_PrimaryAssetTypeToString(const struct FPrimaryAssetType& PrimaryAssetType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_PrimaryAssetTypeToString");

	Params::UKismetSystemLibrary_Conv_PrimaryAssetTypeToString_Params Parms{};

	Parms.PrimaryAssetType = PrimaryAssetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_PrimaryAssetIdToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId             PrimaryAssetId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::Conv_PrimaryAssetIdToString(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_PrimaryAssetIdToString");

	Params::UKismetSystemLibrary_Conv_PrimaryAssetIdToString_Params Parms{};

	Parms.PrimaryAssetId = PrimaryAssetId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_ObjectToSoftObjectReference
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     Object                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>      ReturnValue                                                      (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UKismetSystemLibrary::Conv_ObjectToSoftObjectReference(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_ObjectToSoftObjectReference");

	Params::UKismetSystemLibrary_Conv_ObjectToSoftObjectReference_Params Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_InterfaceToObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class IInterface> Interface                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class UObject*                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::Conv_InterfaceToObject(TScriptInterface<class IInterface>& Interface)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_InterfaceToObject");

	Params::UKismetSystemLibrary_Conv_InterfaceToObject_Params Parms{};

	Parms.Interface = Interface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.Conv_ClassToSoftClassReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>         Class                                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UObject>       ReturnValue                                                      (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UObject> UKismetSystemLibrary::Conv_ClassToSoftClassReference(TSubclassOf<class UObject>& Class)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "Conv_ClassToSoftClassReference");

	Params::UKismetSystemLibrary_Conv_ClassToSoftClassReference_Params Parms{};

	Parms.Class = Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.ControlScreensaver
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               bAllowScreenSaver                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ControlScreensaver(bool bAllowScreenSaver)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ControlScreensaver");

	Params::UKismetSystemLibrary_ControlScreensaver_Params Parms{};

	Parms.bAllowScreenSaver = bAllowScreenSaver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.ComponentOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ComponentTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                      ComponentClassFilter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*> OutComponents                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::ComponentOverlapComponents(class UPrimitiveComponent* Component, struct FTransform& ComponentTransform, TArray<enum class EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ComponentOverlapComponents");

	Params::UKismetSystemLibrary_ComponentOverlapComponents_Params Parms{};

	Parms.Component = Component;
	Parms.ComponentTransform = ComponentTransform;
	Parms.ObjectTypes = ObjectTypes;
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = ActorsToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.ComponentOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ComponentTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                      ActorClassFilter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::ComponentOverlapActors(class UPrimitiveComponent* Component, struct FTransform& ComponentTransform, TArray<enum class EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "ComponentOverlapActors");

	Params::UKismetSystemLibrary_ComponentOverlapActors_Params Parms{};

	Parms.Component = Component;
	Parms.ComponentTransform = ComponentTransform;
	Parms.ObjectTypes = ObjectTypes;
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = ActorsToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CollectGarbage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UKismetSystemLibrary::CollectGarbage()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CollectGarbage");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CapsuleTraceSingleForObjects");

	Params::UKismetSystemLibrary_CapsuleTraceSingleForObjects_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, class FName ProfileName, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CapsuleTraceSingleByProfile");

	Params::UKismetSystemLibrary_CapsuleTraceSingleByProfile_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CapsuleTraceSingle");

	Params::UKismetSystemLibrary_CapsuleTraceSingle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CapsuleTraceMultiForObjects");

	Params::UKismetSystemLibrary_CapsuleTraceMultiForObjects_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CapsuleTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, class FName ProfileName, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CapsuleTraceMultiByProfile");

	Params::UKismetSystemLibrary_CapsuleTraceMultiByProfile_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CapsuleTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CapsuleTraceMulti");

	Params::UKismetSystemLibrary_CapsuleTraceMulti_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CapsuleOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     CapsulePos                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                      ComponentClassFilter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*> OutComponents                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleOverlapComponents(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<enum class EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CapsuleOverlapComponents");

	Params::UKismetSystemLibrary_CapsuleOverlapComponents_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsulePos = CapsulePos;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = ObjectTypes;
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = ActorsToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CapsuleOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     CapsulePos                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              HalfHeight                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                      ActorClassFilter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleOverlapActors(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<enum class EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CapsuleOverlapActors");

	Params::UKismetSystemLibrary_CapsuleOverlapActors_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsulePos = CapsulePos;
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = ObjectTypes;
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = ActorsToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CanLaunchURL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      URL                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CanLaunchURL(const class FString& URL)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CanLaunchURL");

	Params::UKismetSystemLibrary_CanLaunchURL_Params Parms{};

	Parms.URL = URL;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.CancelTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                              Index                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::CancelTransaction(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "CancelTransaction");

	Params::UKismetSystemLibrary_CancelTransaction_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.KismetSystemLibrary.BreakSoftObjectPath
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath             InSoftObjectPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      PathString                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::BreakSoftObjectPath(const struct FSoftObjectPath& InSoftObjectPath, class FString* PathString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BreakSoftObjectPath");

	Params::UKismetSystemLibrary_BreakSoftObjectPath_Params Parms{};

	Parms.InSoftObjectPath = InSoftObjectPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (PathString != nullptr)
		*PathString = std::move(Parms.PathString);

}


// Function Engine.KismetSystemLibrary.BreakSoftClassPath
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftClassPath              InSoftClassPath                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                      PathString                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::BreakSoftClassPath(const struct FSoftClassPath& InSoftClassPath, class FString* PathString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BreakSoftClassPath");

	Params::UKismetSystemLibrary_BreakSoftClassPath_Params Parms{};

	Parms.InSoftClassPath = InSoftClassPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (PathString != nullptr)
		*PathString = std::move(Parms.PathString);

}


// Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HalfSize                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Orientation                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BoxTraceSingleForObjects");

	Params::UKismetSystemLibrary_BoxTraceSingleForObjects_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.HalfSize = HalfSize;
	Parms.Orientation = Orientation;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.BoxTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HalfSize                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Orientation                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, class FName ProfileName, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BoxTraceSingleByProfile");

	Params::UKismetSystemLibrary_BoxTraceSingleByProfile_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.HalfSize = HalfSize;
	Parms.Orientation = Orientation;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.BoxTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HalfSize                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Orientation                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                  OutHit                                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BoxTraceSingle");

	Params::UKismetSystemLibrary_BoxTraceSingle_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.HalfSize = HalfSize;
	Parms.Orientation = Orientation;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HalfSize                                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Orientation                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<enum class EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BoxTraceMultiForObjects");

	Params::UKismetSystemLibrary_BoxTraceMultiForObjects_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.HalfSize = HalfSize;
	Parms.Orientation = Orientation;
	Parms.ObjectTypes = ObjectTypes;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.BoxTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HalfSize                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Orientation                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, class FName ProfileName, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BoxTraceMultiByProfile");

	Params::UKismetSystemLibrary_BoxTraceMultiByProfile_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.HalfSize = HalfSize;
	Parms.Orientation = Orientation;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.BoxTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Start                                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     End                                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     HalfSize                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Orientation                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// enum class ETraceTypeQuery         TraceChannel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bTraceComplex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class EDrawDebugTrace         DrawDebugType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>          OutHits                                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               bIgnoreSelf                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceColor                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                TraceHitColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              DrawTime                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, enum class ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*>& ActorsToIgnore, enum class EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BoxTraceMulti");

	Params::UKismetSystemLibrary_BoxTraceMulti_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = Start;
	Parms.End = End;
	Parms.HalfSize = HalfSize;
	Parms.Orientation = Orientation;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = ActorsToIgnore;
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = TraceColor;
	Parms.TraceHitColor = TraceHitColor;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.BoxOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxPos                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Extent                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                      ComponentClassFilter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*> OutComponents                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxOverlapComponents(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, TArray<enum class EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BoxOverlapComponents");

	Params::UKismetSystemLibrary_BoxOverlapComponents_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = BoxPos;
	Parms.Extent = Extent;
	Parms.ObjectTypes = ObjectTypes;
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = ActorsToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.BoxOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxPos                                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     BoxExtent                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<enum class EObjectTypeQuery>ObjectTypes                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                      ActorClassFilter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>              ActorsToIgnore                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>              OutActors                                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxOverlapActors(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, TArray<enum class EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BoxOverlapActors");

	Params::UKismetSystemLibrary_BoxOverlapActors_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = BoxPos;
	Parms.BoxExtent = BoxExtent;
	Parms.ObjectTypes = ObjectTypes;
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = ActorsToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.BeginTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                      Context                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        Description                                                      (Parm, NativeAccessSpecifierPublic)
// class UObject*                     PrimaryObject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::BeginTransaction(const class FString& Context, class FText Description, class UObject* PrimaryObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "BeginTransaction");

	Params::UKismetSystemLibrary_BeginTransaction_Params Parms{};

	Parms.Context = Context;
	Parms.Description = Description;
	Parms.PrimaryObject = PrimaryObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetSystemLibrary.AddFloatHistorySample
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDebugFloatHistory          FloatHistory                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDebugFloatHistory          ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDebugFloatHistory UKismetSystemLibrary::AddFloatHistorySample(float Value, struct FDebugFloatHistory& FloatHistory)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetSystemLibrary", "AddFloatHistorySample");

	Params::UKismetSystemLibrary_AddFloatHistorySample_Params Parms{};

	Parms.Value = Value;
	Parms.FloatHistory = FloatHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.KismetTextLibrary
// (None)

class UClass* UKismetTextLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("KismetTextLibrary");

	return Clss;
}


// KismetTextLibrary Engine.Default__KismetTextLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UKismetTextLibrary* UKismetTextLibrary::GetDefaultObj()
{
	static class UKismetTextLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UKismetTextLibrary*>(UKismetTextLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.KismetTextLibrary.TextTrimTrailing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextTrimTrailing(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextTrimTrailing");

	Params::UKismetTextLibrary_TextTrimTrailing_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextTrimPrecedingAndTrailing(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextTrimPrecedingAndTrailing");

	Params::UKismetTextLibrary_TextTrimPrecedingAndTrailing_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextTrimPreceding
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextTrimPreceding(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextTrimPreceding");

	Params::UKismetTextLibrary_TextTrimPreceding_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextToUpper
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextToUpper(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextToUpper");

	Params::UKismetTextLibrary_TextToUpper_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextToLower
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextToLower(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextToLower");

	Params::UKismetTextLibrary_TextToLower_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextIsTransient
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::TextIsTransient(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextIsTransient");

	Params::UKismetTextLibrary_TextIsTransient_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextIsFromStringTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        Text                                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::TextIsFromStringTable(class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextIsFromStringTable");

	Params::UKismetTextLibrary_TextIsFromStringTable_Params Parms{};

	Parms.Text = Text;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextIsEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::TextIsEmpty(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextIsEmpty");

	Params::UKismetTextLibrary_TextIsEmpty_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextIsCultureInvariant
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::TextIsCultureInvariant(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextIsCultureInvariant");

	Params::UKismetTextLibrary_TextIsCultureInvariant_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.TextFromStringTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        TableId                                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextFromStringTable(class FName TableId, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "TextFromStringTable");

	Params::UKismetTextLibrary_TextFromStringTable_Params Parms{};

	Parms.TableId = TableId;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.StringTableIdAndKeyFromText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        Text                                                             (Parm, NativeAccessSpecifierPublic)
// class FName                        OutTableId                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      OutKey                                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::StringTableIdAndKeyFromText(class FText Text, class FName* OutTableId, class FString* OutKey)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "StringTableIdAndKeyFromText");

	Params::UKismetTextLibrary_StringTableIdAndKeyFromText_Params Parms{};

	Parms.Text = Text;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTableId != nullptr)
		*OutTableId = Parms.OutTableId;

	if (OutKey != nullptr)
		*OutKey = std::move(Parms.OutKey);

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.PolyglotDataToText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPolyglotTextData           PolyglotData                                                     (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::PolyglotDataToText(struct FPolyglotTextData& PolyglotData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "PolyglotDataToText");

	Params::UKismetTextLibrary_PolyglotDataToText_Params Parms{};

	Parms.PolyglotData = PolyglotData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.NotEqual_TextText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        A                                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        B                                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::NotEqual_TextText(class FText& A, class FText& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "NotEqual_TextText");

	Params::UKismetTextLibrary_NotEqual_TextText_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        A                                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        B                                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::NotEqual_IgnoreCase_TextText(class FText& A, class FText& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "NotEqual_IgnoreCase_TextText");

	Params::UKismetTextLibrary_NotEqual_IgnoreCase_TextText_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.IsPolyglotDataValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPolyglotTextData           PolyglotData                                                     (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               IsValid                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ErrorMessage                                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UKismetTextLibrary::IsPolyglotDataValid(struct FPolyglotTextData& PolyglotData, bool* IsValid, class FText* ErrorMessage)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "IsPolyglotDataValid");

	Params::UKismetTextLibrary_IsPolyglotDataValid_Params Parms{};

	Parms.PolyglotData = PolyglotData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	if (ErrorMessage != nullptr)
		*ErrorMessage = Parms.ErrorMessage;

}


// Function Engine.KismetTextLibrary.GetEmptyText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::GetEmptyText()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "GetEmptyText");

	Params::UKismetTextLibrary_GetEmptyText_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Format
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InPattern                                                        (Parm, NativeAccessSpecifierPublic)
// TArray<struct FFormatArgumentData> InArgs                                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Format(class FText InPattern, const TArray<struct FFormatArgumentData>& InArgs)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Format");

	Params::UKismetTextLibrary_Format_Params Parms{};

	Parms.InPattern = InPattern;
	Parms.InArgs = InArgs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.FindTextInLocalizationTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      Namespace                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Key                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        OutText                                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::FindTextInLocalizationTable(const class FString& Namespace, const class FString& Key, class FText* OutText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "FindTextInLocalizationTable");

	Params::UKismetTextLibrary_FindTextInLocalizationTable_Params Parms{};

	Parms.Namespace = Namespace;
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutText != nullptr)
		*OutText = Parms.OutText;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.EqualEqual_TextText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        A                                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        B                                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::EqualEqual_TextText(class FText& A, class FText& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "EqualEqual_TextText");

	Params::UKismetTextLibrary_EqualEqual_TextText_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        A                                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                        B                                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::EqualEqual_IgnoreCase_TextText(class FText& A, class FText& B)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "EqualEqual_IgnoreCase_TextText");

	Params::UKismetTextLibrary_EqualEqual_IgnoreCase_TextText_Params Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_VectorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                     InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_VectorToText(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_VectorToText");

	Params::UKismetTextLibrary_Conv_VectorToText_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_Vector2dToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                   InVec                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_Vector2dToText(const struct FVector2D& InVec)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_Vector2dToText");

	Params::UKismetTextLibrary_Conv_Vector2dToText_Params Parms{};

	Parms.InVec = InVec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_TransformToText
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                  InTrans                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_TransformToText(struct FTransform& InTrans)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_TransformToText");

	Params::UKismetTextLibrary_Conv_TransformToText_Params Parms{};

	Parms.InTrans = InTrans;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_TextToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                        InText                                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetTextLibrary::Conv_TextToString(class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_TextToString");

	Params::UKismetTextLibrary_Conv_TextToString_Params Parms{};

	Parms.InText = InText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_StringToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                      InString                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_StringToText(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_StringToText");

	Params::UKismetTextLibrary_Conv_StringToText_Params Parms{};

	Parms.InString = InString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_RotatorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                    InRot                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_RotatorToText(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_RotatorToText");

	Params::UKismetTextLibrary_Conv_RotatorToText_Params Parms{};

	Parms.InRot = InRot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_ObjectToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     InObj                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_ObjectToText(class UObject* InObj)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_ObjectToText");

	Params::UKismetTextLibrary_Conv_ObjectToText_Params Parms{};

	Parms.InObj = InObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_NameToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_NameToText(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_NameToText");

	Params::UKismetTextLibrary_Conv_NameToText_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_IntToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAlwaysSign                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseGrouping                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_IntToText(int32 Value, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_IntToText");

	Params::UKismetTextLibrary_Conv_IntToText_Params Parms{};

	Parms.Value = Value;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_FloatToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERoundingMode           RoundingMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAlwaysSign                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseGrouping                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumFractionalDigits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumFractionalDigits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_FloatToText(float Value, enum class ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_FloatToText");

	Params::UKismetTextLibrary_Conv_FloatToText_Params Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_ColorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                InColor                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_ColorToText(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_ColorToText");

	Params::UKismetTextLibrary_Conv_ColorToText_Params Parms{};

	Parms.InColor = InColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_ByteToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_ByteToText(uint8 Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_ByteToText");

	Params::UKismetTextLibrary_Conv_ByteToText_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.Conv_BoolToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                               InBool                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_BoolToText(bool InBool)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "Conv_BoolToText");

	Params::UKismetTextLibrary_Conv_BoolToText_Params Parms{};

	Parms.InBool = InBool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsTimeZoneTime_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   InDateTime                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InTimeZone                                                       (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTimeZoneTime_DateTime(struct FDateTime& InDateTime, const class FString& InTimeZone)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsTimeZoneTime_DateTime");

	Params::UKismetTextLibrary_AsTimeZoneTime_DateTime_Params Parms{};

	Parms.InDateTime = InDateTime;
	Parms.InTimeZone = InTimeZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsTimeZoneDateTime_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   InDateTime                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InTimeZone                                                       (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTimeZoneDateTime_DateTime(struct FDateTime& InDateTime, const class FString& InTimeZone)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsTimeZoneDateTime_DateTime");

	Params::UKismetTextLibrary_AsTimeZoneDateTime_DateTime_Params Parms{};

	Parms.InDateTime = InDateTime;
	Parms.InTimeZone = InTimeZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsTimeZoneDate_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   InDateTime                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      InTimeZone                                                       (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTimeZoneDate_DateTime(struct FDateTime& InDateTime, const class FString& InTimeZone)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsTimeZoneDate_DateTime");

	Params::UKismetTextLibrary_AsTimeZoneDate_DateTime_Params Parms{};

	Parms.InDateTime = InDateTime;
	Parms.InTimeZone = InTimeZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsTimespan_Timespan
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                   InTimespan                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTimespan_Timespan(struct FTimespan& InTimespan)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsTimespan_Timespan");

	Params::UKismetTextLibrary_AsTimespan_Timespan_Params Parms{};

	Parms.InTimespan = InTimespan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsTime_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   In                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTime_DateTime(struct FDateTime& In)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsTime_DateTime");

	Params::UKismetTextLibrary_AsTime_DateTime_Params Parms{};

	Parms.In = In;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsPercent_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERoundingMode           RoundingMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAlwaysSign                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseGrouping                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumFractionalDigits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumFractionalDigits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsPercent_Float(float Value, enum class ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsPercent_Float");

	Params::UKismetTextLibrary_AsPercent_Float_Params Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsDateTime_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   In                                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsDateTime_DateTime(struct FDateTime& In)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsDateTime_DateTime");

	Params::UKismetTextLibrary_AsDateTime_DateTime_Params Parms{};

	Parms.In = In;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsDate_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                   InDateTime                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsDate_DateTime(struct FDateTime& InDateTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsDate_DateTime");

	Params::UKismetTextLibrary_AsDate_DateTime_Params Parms{};

	Parms.InDateTime = InDateTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsCurrencyBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              BaseValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      CurrencyCode                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsCurrencyBase(int32 BaseValue, const class FString& CurrencyCode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsCurrencyBase");

	Params::UKismetTextLibrary_AsCurrencyBase_Params Parms{};

	Parms.BaseValue = BaseValue;
	Parms.CurrencyCode = CurrencyCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsCurrency_Integer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERoundingMode           RoundingMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAlwaysSign                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseGrouping                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumFractionalDigits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumFractionalDigits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      CurrencyCode                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsCurrency_Integer(int32 Value, enum class ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, const class FString& CurrencyCode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsCurrency_Integer");

	Params::UKismetTextLibrary_AsCurrency_Integer_Params Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;
	Parms.CurrencyCode = CurrencyCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.KismetTextLibrary.AsCurrency_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ERoundingMode           RoundingMode                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAlwaysSign                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUseGrouping                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumIntegralDigits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MinimumFractionalDigits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              MaximumFractionalDigits                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      CurrencyCode                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                        ReturnValue                                                      (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsCurrency_Float(float Value, enum class ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, const class FString& CurrencyCode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("KismetTextLibrary", "AsCurrency_Float");

	Params::UKismetTextLibrary_AsCurrency_Float_Params Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;
	Parms.CurrencyCode = CurrencyCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.Layer
// (None)

class UClass* ULayer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Layer");

	return Clss;
}


// Layer Engine.Default__Layer
// (Public, ClassDefaultObject, ArchetypeObject)

class ULayer* ULayer::GetDefaultObj()
{
	static class ULayer* Default = nullptr;

	if (!Default)
		Default = static_cast<ULayer*>(ULayer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Level
// (Level)

class UClass* ULevel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Level");

	return Clss;
}


// Level Engine.Default__Level
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevel* ULevel::GetDefaultObj()
{
	static class ULevel* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevel*>(ULevel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LevelActorContainer
// (None)

class UClass* ULevelActorContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelActorContainer");

	return Clss;
}


// LevelActorContainer Engine.Default__LevelActorContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelActorContainer* ULevelActorContainer::GetDefaultObj()
{
	static class ULevelActorContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelActorContainer*>(ULevelActorContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LevelBounds
// (Actor)

class UClass* ALevelBounds::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelBounds");

	return Clss;
}


// LevelBounds Engine.Default__LevelBounds
// (Public, ClassDefaultObject, ArchetypeObject)

class ALevelBounds* ALevelBounds::GetDefaultObj()
{
	static class ALevelBounds* Default = nullptr;

	if (!Default)
		Default = static_cast<ALevelBounds*>(ALevelBounds::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LevelScriptBlueprint
// (Blueprint)

class UClass* ULevelScriptBlueprint::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelScriptBlueprint");

	return Clss;
}


// LevelScriptBlueprint Engine.Default__LevelScriptBlueprint
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelScriptBlueprint* ULevelScriptBlueprint::GetDefaultObj()
{
	static class ULevelScriptBlueprint* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelScriptBlueprint*>(ULevelScriptBlueprint::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LevelStreaming
// (None)

class UClass* ULevelStreaming::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelStreaming");

	return Clss;
}


// LevelStreaming Engine.Default__LevelStreaming
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelStreaming* ULevelStreaming::GetDefaultObj()
{
	static class ULevelStreaming* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelStreaming*>(ULevelStreaming::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.LevelStreaming.ShouldBeLoaded
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::ShouldBeLoaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "ShouldBeLoaded");

	Params::ULevelStreaming_ShouldBeLoaded_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.LevelStreaming.SetShouldBeVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInShouldBeVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetShouldBeVisible(bool bInShouldBeVisible)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "SetShouldBeVisible");

	Params::ULevelStreaming_SetShouldBeVisible_Params Parms{};

	Parms.bInShouldBeVisible = bInShouldBeVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LevelStreaming.SetShouldBeLoaded
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bInShouldBeLoaded                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetShouldBeLoaded(bool bInShouldBeLoaded)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "SetShouldBeLoaded");

	Params::ULevelStreaming_SetShouldBeLoaded_Params Parms{};

	Parms.bInShouldBeLoaded = bInShouldBeLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LevelStreaming.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              NewPriority                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetPriority(int32 NewPriority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "SetPriority");

	Params::ULevelStreaming_SetPriority_Params Parms{};

	Parms.NewPriority = NewPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LevelStreaming.SetLevelLODIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              LODIndex                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetLevelLODIndex(int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "SetLevelLODIndex");

	Params::ULevelStreaming_SetLevelLODIndex_Params Parms{};

	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LevelStreaming.IsStreamingStatePending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::IsStreamingStatePending()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "IsStreamingStatePending");

	Params::ULevelStreaming_IsStreamingStatePending_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.LevelStreaming.IsLevelVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::IsLevelVisible()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "IsLevelVisible");

	Params::ULevelStreaming_IsLevelVisible_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.LevelStreaming.IsLevelLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::IsLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "IsLevelLoaded");

	Params::ULevelStreaming_IsLevelLoaded_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.LevelStreaming.GetWorldAssetPackageFName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULevelStreaming::GetWorldAssetPackageFName()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "GetWorldAssetPackageFName");

	Params::ULevelStreaming_GetWorldAssetPackageFName_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.LevelStreaming.GetLoadedLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULevel*                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* ULevelStreaming::GetLoadedLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "GetLoadedLevel");

	Params::ULevelStreaming_GetLoadedLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.LevelStreaming.GetLevelScriptActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALevelScriptActor*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALevelScriptActor* ULevelStreaming::GetLevelScriptActor()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "GetLevelScriptActor");

	Params::ULevelStreaming_GetLevelScriptActor_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.LevelStreaming.CreateInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      UniqueInstanceName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreaming*             ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreaming* ULevelStreaming::CreateInstance(const class FString& UniqueInstanceName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreaming", "CreateInstance");

	Params::ULevelStreaming_CreateInstance_Params Parms{};

	Parms.UniqueInstanceName = UniqueInstanceName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.LevelStreamingAlwaysLoaded
// (None)

class UClass* ULevelStreamingAlwaysLoaded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelStreamingAlwaysLoaded");

	return Clss;
}


// LevelStreamingAlwaysLoaded Engine.Default__LevelStreamingAlwaysLoaded
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelStreamingAlwaysLoaded* ULevelStreamingAlwaysLoaded::GetDefaultObj()
{
	static class ULevelStreamingAlwaysLoaded* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelStreamingAlwaysLoaded*>(ULevelStreamingAlwaysLoaded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LevelStreamingDynamic
// (None)

class UClass* ULevelStreamingDynamic::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelStreamingDynamic");

	return Clss;
}


// LevelStreamingDynamic Engine.Default__LevelStreamingDynamic
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelStreamingDynamic* ULevelStreamingDynamic::GetDefaultObj()
{
	static class ULevelStreamingDynamic* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelStreamingDynamic*>(ULevelStreamingDynamic::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.LevelStreamingDynamic.LoadLevelInstanceBySoftObjectPtr
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>       Level                                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bOutSuccess                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreamingDynamic*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreamingDynamic* ULevelStreamingDynamic::LoadLevelInstanceBySoftObjectPtr(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> Level, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingDynamic", "LoadLevelInstanceBySoftObjectPtr");

	Params::ULevelStreamingDynamic_LoadLevelInstanceBySoftObjectPtr_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Level = Level;
	Parms.Location = Location;
	Parms.Rotation = Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	return Parms.ReturnValue;

}


// Function Engine.LevelStreamingDynamic.LoadLevelInstance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      LevelName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bOutSuccess                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreamingDynamic*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreamingDynamic* ULevelStreamingDynamic::LoadLevelInstance(class UObject* WorldContextObject, const class FString& LevelName, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LevelStreamingDynamic", "LoadLevelInstance");

	Params::ULevelStreamingDynamic_LoadLevelInstance_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;
	Parms.Location = Location;
	Parms.Rotation = Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	return Parms.ReturnValue;

}


// Class Engine.LevelStreamingPersistent
// (None)

class UClass* ULevelStreamingPersistent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelStreamingPersistent");

	return Clss;
}


// LevelStreamingPersistent Engine.Default__LevelStreamingPersistent
// (Public, ClassDefaultObject, ArchetypeObject)

class ULevelStreamingPersistent* ULevelStreamingPersistent::GetDefaultObj()
{
	static class ULevelStreamingPersistent* Default = nullptr;

	if (!Default)
		Default = static_cast<ULevelStreamingPersistent*>(ULevelStreamingPersistent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LevelStreamingVolume
// (Actor)

class UClass* ALevelStreamingVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LevelStreamingVolume");

	return Clss;
}


// LevelStreamingVolume Engine.Default__LevelStreamingVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ALevelStreamingVolume* ALevelStreamingVolume::GetDefaultObj()
{
	static class ALevelStreamingVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ALevelStreamingVolume*>(ALevelStreamingVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightmappedSurfaceCollection
// (None)

class UClass* ULightmappedSurfaceCollection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightmappedSurfaceCollection");

	return Clss;
}


// LightmappedSurfaceCollection Engine.Default__LightmappedSurfaceCollection
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightmappedSurfaceCollection* ULightmappedSurfaceCollection::GetDefaultObj()
{
	static class ULightmappedSurfaceCollection* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightmappedSurfaceCollection*>(ULightmappedSurfaceCollection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightMapTexture2D
// (None)

class UClass* ULightMapTexture2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightMapTexture2D");

	return Clss;
}


// LightMapTexture2D Engine.Default__LightMapTexture2D
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightMapTexture2D* ULightMapTexture2D::GetDefaultObj()
{
	static class ULightMapTexture2D* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightMapTexture2D*>(ULightMapTexture2D::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightmassCharacterIndirectDetailVolume
// (Actor)

class UClass* ALightmassCharacterIndirectDetailVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightmassCharacterIndirectDetailVolume");

	return Clss;
}


// LightmassCharacterIndirectDetailVolume Engine.Default__LightmassCharacterIndirectDetailVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ALightmassCharacterIndirectDetailVolume* ALightmassCharacterIndirectDetailVolume::GetDefaultObj()
{
	static class ALightmassCharacterIndirectDetailVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ALightmassCharacterIndirectDetailVolume*>(ALightmassCharacterIndirectDetailVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightmassImportanceVolume
// (Actor)

class UClass* ALightmassImportanceVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightmassImportanceVolume");

	return Clss;
}


// LightmassImportanceVolume Engine.Default__LightmassImportanceVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ALightmassImportanceVolume* ALightmassImportanceVolume::GetDefaultObj()
{
	static class ALightmassImportanceVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ALightmassImportanceVolume*>(ALightmassImportanceVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightmassPortal
// (Actor)

class UClass* ALightmassPortal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightmassPortal");

	return Clss;
}


// LightmassPortal Engine.Default__LightmassPortal
// (Public, ClassDefaultObject, ArchetypeObject)

class ALightmassPortal* ALightmassPortal::GetDefaultObj()
{
	static class ALightmassPortal* Default = nullptr;

	if (!Default)
		Default = static_cast<ALightmassPortal*>(ALightmassPortal::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightmassPortalComponent
// (SceneComponent)

class UClass* ULightmassPortalComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightmassPortalComponent");

	return Clss;
}


// LightmassPortalComponent Engine.Default__LightmassPortalComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightmassPortalComponent* ULightmassPortalComponent::GetDefaultObj()
{
	static class ULightmassPortalComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightmassPortalComponent*>(ULightmassPortalComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightmassPrimitiveSettingsObject
// (None)

class UClass* ULightmassPrimitiveSettingsObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightmassPrimitiveSettingsObject");

	return Clss;
}


// LightmassPrimitiveSettingsObject Engine.Default__LightmassPrimitiveSettingsObject
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightmassPrimitiveSettingsObject* ULightmassPrimitiveSettingsObject::GetDefaultObj()
{
	static class ULightmassPrimitiveSettingsObject* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightmassPrimitiveSettingsObject*>(ULightmassPrimitiveSettingsObject::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LineBatchComponent
// (SceneComponent, PrimitiveComponent)

class UClass* ULineBatchComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LineBatchComponent");

	return Clss;
}


// LineBatchComponent Engine.Default__LineBatchComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class ULineBatchComponent* ULineBatchComponent::GetDefaultObj()
{
	static class ULineBatchComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<ULineBatchComponent*>(ULineBatchComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LocalLightComponent
// (SceneComponent)

class UClass* ULocalLightComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LocalLightComponent");

	return Clss;
}


// LocalLightComponent Engine.Default__LocalLightComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class ULocalLightComponent* ULocalLightComponent::GetDefaultObj()
{
	static class ULocalLightComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<ULocalLightComponent*>(ULocalLightComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.LocalLightComponent.SetIntensityUnits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ELightUnits             NewIntensityUnits                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalLightComponent::SetIntensityUnits(enum class ELightUnits NewIntensityUnits)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LocalLightComponent", "SetIntensityUnits");

	Params::ULocalLightComponent_SetIntensityUnits_Params Parms{};

	Parms.NewIntensityUnits = NewIntensityUnits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LocalLightComponent.SetAttenuationRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewRadius                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalLightComponent::SetAttenuationRadius(float NewRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LocalLightComponent", "SetAttenuationRadius");

	Params::ULocalLightComponent_SetAttenuationRadius_Params Parms{};

	Parms.NewRadius = NewRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.LocalLightComponent.GetUnitsConversionFactor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// enum class ELightUnits             SrcUnits                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ELightUnits             TargetUnits                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              CosHalfConeAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULocalLightComponent::GetUnitsConversionFactor(enum class ELightUnits SrcUnits, enum class ELightUnits TargetUnits, float CosHalfConeAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("LocalLightComponent", "GetUnitsConversionFactor");

	Params::ULocalLightComponent_GetUnitsConversionFactor_Params Parms{};

	Parms.SrcUnits = SrcUnits;
	Parms.TargetUnits = TargetUnits;
	Parms.CosHalfConeAngle = CosHalfConeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.LODActor
// (Actor)

class UClass* ALODActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LODActor");

	return Clss;
}


// LODActor Engine.Default__LODActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ALODActor* ALODActor::GetDefaultObj()
{
	static class ALODActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ALODActor*>(ALODActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MapBuildDataRegistry
// (None)

class UClass* UMapBuildDataRegistry::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MapBuildDataRegistry");

	return Clss;
}


// MapBuildDataRegistry Engine.Default__MapBuildDataRegistry
// (Public, ClassDefaultObject, ArchetypeObject)

class UMapBuildDataRegistry* UMapBuildDataRegistry::GetDefaultObj()
{
	static class UMapBuildDataRegistry* Default = nullptr;

	if (!Default)
		Default = static_cast<UMapBuildDataRegistry*>(UMapBuildDataRegistry::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Material
// (None)

class UClass* UMaterial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Material");

	return Clss;
}


// Material Engine.Default__Material
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterial* UMaterial::GetDefaultObj()
{
	static class UMaterial* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterial*>(UMaterial::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialBillboardComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UMaterialBillboardComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialBillboardComponent");

	return Clss;
}


// MaterialBillboardComponent Engine.Default__MaterialBillboardComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialBillboardComponent* UMaterialBillboardComponent::GetDefaultObj()
{
	static class UMaterialBillboardComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialBillboardComponent*>(UMaterialBillboardComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.MaterialBillboardComponent.SetElements
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FMaterialSpriteElement>NewElements                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UMaterialBillboardComponent::SetElements(TArray<struct FMaterialSpriteElement>& NewElements)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialBillboardComponent", "SetElements");

	Params::UMaterialBillboardComponent_SetElements_Params Parms{};

	Parms.NewElements = NewElements;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MaterialBillboardComponent.AddElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                 DistanceToOpacityCurve                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bSizeIsInScreenSpace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BaseSizeX                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              BaseSizeY                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                 DistanceToSizeCurve                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialBillboardComponent::AddElement(class UMaterialInterface* Material, class UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UCurveFloat* DistanceToSizeCurve)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialBillboardComponent", "AddElement");

	Params::UMaterialBillboardComponent_AddElement_Params Parms{};

	Parms.Material = Material;
	Parms.DistanceToOpacityCurve = DistanceToOpacityCurve;
	Parms.bSizeIsInScreenSpace = bSizeIsInScreenSpace;
	Parms.BaseSizeX = BaseSizeX;
	Parms.BaseSizeY = BaseSizeY;
	Parms.DistanceToSizeCurve = DistanceToSizeCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.MaterialExpressionAbs
// (None)

class UClass* UMaterialExpressionAbs::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionAbs");

	return Clss;
}


// MaterialExpressionAbs Engine.Default__MaterialExpressionAbs
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionAbs* UMaterialExpressionAbs::GetDefaultObj()
{
	static class UMaterialExpressionAbs* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionAbs*>(UMaterialExpressionAbs::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionActorPositionWS
// (None)

class UClass* UMaterialExpressionActorPositionWS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionActorPositionWS");

	return Clss;
}


// MaterialExpressionActorPositionWS Engine.Default__MaterialExpressionActorPositionWS
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionActorPositionWS* UMaterialExpressionActorPositionWS::GetDefaultObj()
{
	static class UMaterialExpressionActorPositionWS* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionActorPositionWS*>(UMaterialExpressionActorPositionWS::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionAdd
// (None)

class UClass* UMaterialExpressionAdd::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionAdd");

	return Clss;
}


// MaterialExpressionAdd Engine.Default__MaterialExpressionAdd
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionAdd* UMaterialExpressionAdd::GetDefaultObj()
{
	static class UMaterialExpressionAdd* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionAdd*>(UMaterialExpressionAdd::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionAntialiasedTextureMask
// (None)

class UClass* UMaterialExpressionAntialiasedTextureMask::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionAntialiasedTextureMask");

	return Clss;
}


// MaterialExpressionAntialiasedTextureMask Engine.Default__MaterialExpressionAntialiasedTextureMask
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionAntialiasedTextureMask* UMaterialExpressionAntialiasedTextureMask::GetDefaultObj()
{
	static class UMaterialExpressionAntialiasedTextureMask* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionAntialiasedTextureMask*>(UMaterialExpressionAntialiasedTextureMask::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionAppendVector
// (None)

class UClass* UMaterialExpressionAppendVector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionAppendVector");

	return Clss;
}


// MaterialExpressionAppendVector Engine.Default__MaterialExpressionAppendVector
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionAppendVector* UMaterialExpressionAppendVector::GetDefaultObj()
{
	static class UMaterialExpressionAppendVector* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionAppendVector*>(UMaterialExpressionAppendVector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionArccosine
// (None)

class UClass* UMaterialExpressionArccosine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionArccosine");

	return Clss;
}


// MaterialExpressionArccosine Engine.Default__MaterialExpressionArccosine
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionArccosine* UMaterialExpressionArccosine::GetDefaultObj()
{
	static class UMaterialExpressionArccosine* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionArccosine*>(UMaterialExpressionArccosine::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionArccosineFast
// (None)

class UClass* UMaterialExpressionArccosineFast::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionArccosineFast");

	return Clss;
}


// MaterialExpressionArccosineFast Engine.Default__MaterialExpressionArccosineFast
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionArccosineFast* UMaterialExpressionArccosineFast::GetDefaultObj()
{
	static class UMaterialExpressionArccosineFast* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionArccosineFast*>(UMaterialExpressionArccosineFast::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionArcsine
// (None)

class UClass* UMaterialExpressionArcsine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionArcsine");

	return Clss;
}


// MaterialExpressionArcsine Engine.Default__MaterialExpressionArcsine
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionArcsine* UMaterialExpressionArcsine::GetDefaultObj()
{
	static class UMaterialExpressionArcsine* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionArcsine*>(UMaterialExpressionArcsine::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionArcsineFast
// (None)

class UClass* UMaterialExpressionArcsineFast::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionArcsineFast");

	return Clss;
}


// MaterialExpressionArcsineFast Engine.Default__MaterialExpressionArcsineFast
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionArcsineFast* UMaterialExpressionArcsineFast::GetDefaultObj()
{
	static class UMaterialExpressionArcsineFast* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionArcsineFast*>(UMaterialExpressionArcsineFast::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionArctangent
// (None)

class UClass* UMaterialExpressionArctangent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionArctangent");

	return Clss;
}


// MaterialExpressionArctangent Engine.Default__MaterialExpressionArctangent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionArctangent* UMaterialExpressionArctangent::GetDefaultObj()
{
	static class UMaterialExpressionArctangent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionArctangent*>(UMaterialExpressionArctangent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionArctangent2
// (None)

class UClass* UMaterialExpressionArctangent2::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionArctangent2");

	return Clss;
}


// MaterialExpressionArctangent2 Engine.Default__MaterialExpressionArctangent2
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionArctangent2* UMaterialExpressionArctangent2::GetDefaultObj()
{
	static class UMaterialExpressionArctangent2* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionArctangent2*>(UMaterialExpressionArctangent2::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionArctangent2Fast
// (None)

class UClass* UMaterialExpressionArctangent2Fast::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionArctangent2Fast");

	return Clss;
}


// MaterialExpressionArctangent2Fast Engine.Default__MaterialExpressionArctangent2Fast
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionArctangent2Fast* UMaterialExpressionArctangent2Fast::GetDefaultObj()
{
	static class UMaterialExpressionArctangent2Fast* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionArctangent2Fast*>(UMaterialExpressionArctangent2Fast::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionArctangentFast
// (None)

class UClass* UMaterialExpressionArctangentFast::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionArctangentFast");

	return Clss;
}


// MaterialExpressionArctangentFast Engine.Default__MaterialExpressionArctangentFast
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionArctangentFast* UMaterialExpressionArctangentFast::GetDefaultObj()
{
	static class UMaterialExpressionArctangentFast* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionArctangentFast*>(UMaterialExpressionArctangentFast::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionAtmosphericFogColor
// (None)

class UClass* UMaterialExpressionAtmosphericFogColor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionAtmosphericFogColor");

	return Clss;
}


// MaterialExpressionAtmosphericFogColor Engine.Default__MaterialExpressionAtmosphericFogColor
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionAtmosphericFogColor* UMaterialExpressionAtmosphericFogColor::GetDefaultObj()
{
	static class UMaterialExpressionAtmosphericFogColor* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionAtmosphericFogColor*>(UMaterialExpressionAtmosphericFogColor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionAtmosphericLightColor
// (None)

class UClass* UMaterialExpressionAtmosphericLightColor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionAtmosphericLightColor");

	return Clss;
}


// MaterialExpressionAtmosphericLightColor Engine.Default__MaterialExpressionAtmosphericLightColor
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionAtmosphericLightColor* UMaterialExpressionAtmosphericLightColor::GetDefaultObj()
{
	static class UMaterialExpressionAtmosphericLightColor* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionAtmosphericLightColor*>(UMaterialExpressionAtmosphericLightColor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionAtmosphericLightVector
// (None)

class UClass* UMaterialExpressionAtmosphericLightVector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionAtmosphericLightVector");

	return Clss;
}


// MaterialExpressionAtmosphericLightVector Engine.Default__MaterialExpressionAtmosphericLightVector
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionAtmosphericLightVector* UMaterialExpressionAtmosphericLightVector::GetDefaultObj()
{
	static class UMaterialExpressionAtmosphericLightVector* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionAtmosphericLightVector*>(UMaterialExpressionAtmosphericLightVector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionBentNormalCustomOutput
// (None)

class UClass* UMaterialExpressionBentNormalCustomOutput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionBentNormalCustomOutput");

	return Clss;
}


// MaterialExpressionBentNormalCustomOutput Engine.Default__MaterialExpressionBentNormalCustomOutput
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionBentNormalCustomOutput* UMaterialExpressionBentNormalCustomOutput::GetDefaultObj()
{
	static class UMaterialExpressionBentNormalCustomOutput* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionBentNormalCustomOutput*>(UMaterialExpressionBentNormalCustomOutput::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionBlackBody
// (None)

class UClass* UMaterialExpressionBlackBody::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionBlackBody");

	return Clss;
}


// MaterialExpressionBlackBody Engine.Default__MaterialExpressionBlackBody
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionBlackBody* UMaterialExpressionBlackBody::GetDefaultObj()
{
	static class UMaterialExpressionBlackBody* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionBlackBody*>(UMaterialExpressionBlackBody::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionBlendMaterialAttributes
// (None)

class UClass* UMaterialExpressionBlendMaterialAttributes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionBlendMaterialAttributes");

	return Clss;
}


// MaterialExpressionBlendMaterialAttributes Engine.Default__MaterialExpressionBlendMaterialAttributes
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionBlendMaterialAttributes* UMaterialExpressionBlendMaterialAttributes::GetDefaultObj()
{
	static class UMaterialExpressionBlendMaterialAttributes* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionBlendMaterialAttributes*>(UMaterialExpressionBlendMaterialAttributes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionBreakMaterialAttributes
// (None)

class UClass* UMaterialExpressionBreakMaterialAttributes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionBreakMaterialAttributes");

	return Clss;
}


// MaterialExpressionBreakMaterialAttributes Engine.Default__MaterialExpressionBreakMaterialAttributes
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionBreakMaterialAttributes* UMaterialExpressionBreakMaterialAttributes::GetDefaultObj()
{
	static class UMaterialExpressionBreakMaterialAttributes* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionBreakMaterialAttributes*>(UMaterialExpressionBreakMaterialAttributes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionBumpOffset
// (None)

class UClass* UMaterialExpressionBumpOffset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionBumpOffset");

	return Clss;
}


// MaterialExpressionBumpOffset Engine.Default__MaterialExpressionBumpOffset
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionBumpOffset* UMaterialExpressionBumpOffset::GetDefaultObj()
{
	static class UMaterialExpressionBumpOffset* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionBumpOffset*>(UMaterialExpressionBumpOffset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionCameraPositionWS
// (None)

class UClass* UMaterialExpressionCameraPositionWS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCameraPositionWS");

	return Clss;
}


// MaterialExpressionCameraPositionWS Engine.Default__MaterialExpressionCameraPositionWS
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCameraPositionWS* UMaterialExpressionCameraPositionWS::GetDefaultObj()
{
	static class UMaterialExpressionCameraPositionWS* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCameraPositionWS*>(UMaterialExpressionCameraPositionWS::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionCameraVectorWS
// (None)

class UClass* UMaterialExpressionCameraVectorWS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCameraVectorWS");

	return Clss;
}


// MaterialExpressionCameraVectorWS Engine.Default__MaterialExpressionCameraVectorWS
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCameraVectorWS* UMaterialExpressionCameraVectorWS::GetDefaultObj()
{
	static class UMaterialExpressionCameraVectorWS* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCameraVectorWS*>(UMaterialExpressionCameraVectorWS::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionCeil
// (None)

class UClass* UMaterialExpressionCeil::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCeil");

	return Clss;
}


// MaterialExpressionCeil Engine.Default__MaterialExpressionCeil
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCeil* UMaterialExpressionCeil::GetDefaultObj()
{
	static class UMaterialExpressionCeil* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCeil*>(UMaterialExpressionCeil::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParameter
// (None)

class UClass* UMaterialExpressionParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParameter");

	return Clss;
}


// MaterialExpressionParameter Engine.Default__MaterialExpressionParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParameter* UMaterialExpressionParameter::GetDefaultObj()
{
	static class UMaterialExpressionParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParameter*>(UMaterialExpressionParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionVectorParameter
// (None)

class UClass* UMaterialExpressionVectorParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionVectorParameter");

	return Clss;
}


// MaterialExpressionVectorParameter Engine.Default__MaterialExpressionVectorParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionVectorParameter* UMaterialExpressionVectorParameter::GetDefaultObj()
{
	static class UMaterialExpressionVectorParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionVectorParameter*>(UMaterialExpressionVectorParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionChannelMaskParameter
// (None)

class UClass* UMaterialExpressionChannelMaskParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionChannelMaskParameter");

	return Clss;
}


// MaterialExpressionChannelMaskParameter Engine.Default__MaterialExpressionChannelMaskParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionChannelMaskParameter* UMaterialExpressionChannelMaskParameter::GetDefaultObj()
{
	static class UMaterialExpressionChannelMaskParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionChannelMaskParameter*>(UMaterialExpressionChannelMaskParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionClamp
// (None)

class UClass* UMaterialExpressionClamp::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionClamp");

	return Clss;
}


// MaterialExpressionClamp Engine.Default__MaterialExpressionClamp
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionClamp* UMaterialExpressionClamp::GetDefaultObj()
{
	static class UMaterialExpressionClamp* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionClamp*>(UMaterialExpressionClamp::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionClearCoatNormalCustomOutput
// (None)

class UClass* UMaterialExpressionClearCoatNormalCustomOutput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionClearCoatNormalCustomOutput");

	return Clss;
}


// MaterialExpressionClearCoatNormalCustomOutput Engine.Default__MaterialExpressionClearCoatNormalCustomOutput
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionClearCoatNormalCustomOutput* UMaterialExpressionClearCoatNormalCustomOutput::GetDefaultObj()
{
	static class UMaterialExpressionClearCoatNormalCustomOutput* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionClearCoatNormalCustomOutput*>(UMaterialExpressionClearCoatNormalCustomOutput::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionCollectionParameter
// (None)

class UClass* UMaterialExpressionCollectionParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCollectionParameter");

	return Clss;
}


// MaterialExpressionCollectionParameter Engine.Default__MaterialExpressionCollectionParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCollectionParameter* UMaterialExpressionCollectionParameter::GetDefaultObj()
{
	static class UMaterialExpressionCollectionParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCollectionParameter*>(UMaterialExpressionCollectionParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionComment
// (None)

class UClass* UMaterialExpressionComment::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionComment");

	return Clss;
}


// MaterialExpressionComment Engine.Default__MaterialExpressionComment
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionComment* UMaterialExpressionComment::GetDefaultObj()
{
	static class UMaterialExpressionComment* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionComment*>(UMaterialExpressionComment::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionComponentMask
// (None)

class UClass* UMaterialExpressionComponentMask::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionComponentMask");

	return Clss;
}


// MaterialExpressionComponentMask Engine.Default__MaterialExpressionComponentMask
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionComponentMask* UMaterialExpressionComponentMask::GetDefaultObj()
{
	static class UMaterialExpressionComponentMask* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionComponentMask*>(UMaterialExpressionComponentMask::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionConstant
// (None)

class UClass* UMaterialExpressionConstant::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionConstant");

	return Clss;
}


// MaterialExpressionConstant Engine.Default__MaterialExpressionConstant
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionConstant* UMaterialExpressionConstant::GetDefaultObj()
{
	static class UMaterialExpressionConstant* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionConstant*>(UMaterialExpressionConstant::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionConstant2Vector
// (None)

class UClass* UMaterialExpressionConstant2Vector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionConstant2Vector");

	return Clss;
}


// MaterialExpressionConstant2Vector Engine.Default__MaterialExpressionConstant2Vector
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionConstant2Vector* UMaterialExpressionConstant2Vector::GetDefaultObj()
{
	static class UMaterialExpressionConstant2Vector* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionConstant2Vector*>(UMaterialExpressionConstant2Vector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionConstant3Vector
// (None)

class UClass* UMaterialExpressionConstant3Vector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionConstant3Vector");

	return Clss;
}


// MaterialExpressionConstant3Vector Engine.Default__MaterialExpressionConstant3Vector
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionConstant3Vector* UMaterialExpressionConstant3Vector::GetDefaultObj()
{
	static class UMaterialExpressionConstant3Vector* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionConstant3Vector*>(UMaterialExpressionConstant3Vector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionConstant4Vector
// (None)

class UClass* UMaterialExpressionConstant4Vector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionConstant4Vector");

	return Clss;
}


// MaterialExpressionConstant4Vector Engine.Default__MaterialExpressionConstant4Vector
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionConstant4Vector* UMaterialExpressionConstant4Vector::GetDefaultObj()
{
	static class UMaterialExpressionConstant4Vector* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionConstant4Vector*>(UMaterialExpressionConstant4Vector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionConstantBiasScale
// (None)

class UClass* UMaterialExpressionConstantBiasScale::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionConstantBiasScale");

	return Clss;
}


// MaterialExpressionConstantBiasScale Engine.Default__MaterialExpressionConstantBiasScale
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionConstantBiasScale* UMaterialExpressionConstantBiasScale::GetDefaultObj()
{
	static class UMaterialExpressionConstantBiasScale* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionConstantBiasScale*>(UMaterialExpressionConstantBiasScale::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionCosine
// (None)

class UClass* UMaterialExpressionCosine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCosine");

	return Clss;
}


// MaterialExpressionCosine Engine.Default__MaterialExpressionCosine
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCosine* UMaterialExpressionCosine::GetDefaultObj()
{
	static class UMaterialExpressionCosine* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCosine*>(UMaterialExpressionCosine::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionCrossProduct
// (None)

class UClass* UMaterialExpressionCrossProduct::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCrossProduct");

	return Clss;
}


// MaterialExpressionCrossProduct Engine.Default__MaterialExpressionCrossProduct
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCrossProduct* UMaterialExpressionCrossProduct::GetDefaultObj()
{
	static class UMaterialExpressionCrossProduct* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCrossProduct*>(UMaterialExpressionCrossProduct::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionScalarParameter
// (None)

class UClass* UMaterialExpressionScalarParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionScalarParameter");

	return Clss;
}


// MaterialExpressionScalarParameter Engine.Default__MaterialExpressionScalarParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionScalarParameter* UMaterialExpressionScalarParameter::GetDefaultObj()
{
	static class UMaterialExpressionScalarParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionScalarParameter*>(UMaterialExpressionScalarParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionCurveAtlasRowParameter
// (None)

class UClass* UMaterialExpressionCurveAtlasRowParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCurveAtlasRowParameter");

	return Clss;
}


// MaterialExpressionCurveAtlasRowParameter Engine.Default__MaterialExpressionCurveAtlasRowParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCurveAtlasRowParameter* UMaterialExpressionCurveAtlasRowParameter::GetDefaultObj()
{
	static class UMaterialExpressionCurveAtlasRowParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCurveAtlasRowParameter*>(UMaterialExpressionCurveAtlasRowParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionCustom
// (None)

class UClass* UMaterialExpressionCustom::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionCustom");

	return Clss;
}


// MaterialExpressionCustom Engine.Default__MaterialExpressionCustom
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionCustom* UMaterialExpressionCustom::GetDefaultObj()
{
	static class UMaterialExpressionCustom* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionCustom*>(UMaterialExpressionCustom::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDDX
// (None)

class UClass* UMaterialExpressionDDX::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDDX");

	return Clss;
}


// MaterialExpressionDDX Engine.Default__MaterialExpressionDDX
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDDX* UMaterialExpressionDDX::GetDefaultObj()
{
	static class UMaterialExpressionDDX* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDDX*>(UMaterialExpressionDDX::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDDY
// (None)

class UClass* UMaterialExpressionDDY::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDDY");

	return Clss;
}


// MaterialExpressionDDY Engine.Default__MaterialExpressionDDY
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDDY* UMaterialExpressionDDY::GetDefaultObj()
{
	static class UMaterialExpressionDDY* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDDY*>(UMaterialExpressionDDY::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDecalDerivative
// (None)

class UClass* UMaterialExpressionDecalDerivative::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDecalDerivative");

	return Clss;
}


// MaterialExpressionDecalDerivative Engine.Default__MaterialExpressionDecalDerivative
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDecalDerivative* UMaterialExpressionDecalDerivative::GetDefaultObj()
{
	static class UMaterialExpressionDecalDerivative* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDecalDerivative*>(UMaterialExpressionDecalDerivative::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDecalLifetimeOpacity
// (None)

class UClass* UMaterialExpressionDecalLifetimeOpacity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDecalLifetimeOpacity");

	return Clss;
}


// MaterialExpressionDecalLifetimeOpacity Engine.Default__MaterialExpressionDecalLifetimeOpacity
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDecalLifetimeOpacity* UMaterialExpressionDecalLifetimeOpacity::GetDefaultObj()
{
	static class UMaterialExpressionDecalLifetimeOpacity* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDecalLifetimeOpacity*>(UMaterialExpressionDecalLifetimeOpacity::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDecalMipmapLevel
// (None)

class UClass* UMaterialExpressionDecalMipmapLevel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDecalMipmapLevel");

	return Clss;
}


// MaterialExpressionDecalMipmapLevel Engine.Default__MaterialExpressionDecalMipmapLevel
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDecalMipmapLevel* UMaterialExpressionDecalMipmapLevel::GetDefaultObj()
{
	static class UMaterialExpressionDecalMipmapLevel* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDecalMipmapLevel*>(UMaterialExpressionDecalMipmapLevel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDeltaTime
// (None)

class UClass* UMaterialExpressionDeltaTime::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDeltaTime");

	return Clss;
}


// MaterialExpressionDeltaTime Engine.Default__MaterialExpressionDeltaTime
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDeltaTime* UMaterialExpressionDeltaTime::GetDefaultObj()
{
	static class UMaterialExpressionDeltaTime* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDeltaTime*>(UMaterialExpressionDeltaTime::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDepthFade
// (None)

class UClass* UMaterialExpressionDepthFade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDepthFade");

	return Clss;
}


// MaterialExpressionDepthFade Engine.Default__MaterialExpressionDepthFade
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDepthFade* UMaterialExpressionDepthFade::GetDefaultObj()
{
	static class UMaterialExpressionDepthFade* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDepthFade*>(UMaterialExpressionDepthFade::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDepthOfFieldFunction
// (None)

class UClass* UMaterialExpressionDepthOfFieldFunction::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDepthOfFieldFunction");

	return Clss;
}


// MaterialExpressionDepthOfFieldFunction Engine.Default__MaterialExpressionDepthOfFieldFunction
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDepthOfFieldFunction* UMaterialExpressionDepthOfFieldFunction::GetDefaultObj()
{
	static class UMaterialExpressionDepthOfFieldFunction* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDepthOfFieldFunction*>(UMaterialExpressionDepthOfFieldFunction::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDeriveNormalZ
// (None)

class UClass* UMaterialExpressionDeriveNormalZ::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDeriveNormalZ");

	return Clss;
}


// MaterialExpressionDeriveNormalZ Engine.Default__MaterialExpressionDeriveNormalZ
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDeriveNormalZ* UMaterialExpressionDeriveNormalZ::GetDefaultObj()
{
	static class UMaterialExpressionDeriveNormalZ* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDeriveNormalZ*>(UMaterialExpressionDeriveNormalZ::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDesaturation
// (None)

class UClass* UMaterialExpressionDesaturation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDesaturation");

	return Clss;
}


// MaterialExpressionDesaturation Engine.Default__MaterialExpressionDesaturation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDesaturation* UMaterialExpressionDesaturation::GetDefaultObj()
{
	static class UMaterialExpressionDesaturation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDesaturation*>(UMaterialExpressionDesaturation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDistance
// (None)

class UClass* UMaterialExpressionDistance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDistance");

	return Clss;
}


// MaterialExpressionDistance Engine.Default__MaterialExpressionDistance
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDistance* UMaterialExpressionDistance::GetDefaultObj()
{
	static class UMaterialExpressionDistance* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDistance*>(UMaterialExpressionDistance::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDistanceCullFade
// (None)

class UClass* UMaterialExpressionDistanceCullFade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDistanceCullFade");

	return Clss;
}


// MaterialExpressionDistanceCullFade Engine.Default__MaterialExpressionDistanceCullFade
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDistanceCullFade* UMaterialExpressionDistanceCullFade::GetDefaultObj()
{
	static class UMaterialExpressionDistanceCullFade* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDistanceCullFade*>(UMaterialExpressionDistanceCullFade::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDistanceFieldGradient
// (None)

class UClass* UMaterialExpressionDistanceFieldGradient::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDistanceFieldGradient");

	return Clss;
}


// MaterialExpressionDistanceFieldGradient Engine.Default__MaterialExpressionDistanceFieldGradient
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDistanceFieldGradient* UMaterialExpressionDistanceFieldGradient::GetDefaultObj()
{
	static class UMaterialExpressionDistanceFieldGradient* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDistanceFieldGradient*>(UMaterialExpressionDistanceFieldGradient::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDistanceToNearestSurface
// (None)

class UClass* UMaterialExpressionDistanceToNearestSurface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDistanceToNearestSurface");

	return Clss;
}


// MaterialExpressionDistanceToNearestSurface Engine.Default__MaterialExpressionDistanceToNearestSurface
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDistanceToNearestSurface* UMaterialExpressionDistanceToNearestSurface::GetDefaultObj()
{
	static class UMaterialExpressionDistanceToNearestSurface* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDistanceToNearestSurface*>(UMaterialExpressionDistanceToNearestSurface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDivide
// (None)

class UClass* UMaterialExpressionDivide::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDivide");

	return Clss;
}


// MaterialExpressionDivide Engine.Default__MaterialExpressionDivide
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDivide* UMaterialExpressionDivide::GetDefaultObj()
{
	static class UMaterialExpressionDivide* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDivide*>(UMaterialExpressionDivide::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDotProduct
// (None)

class UClass* UMaterialExpressionDotProduct::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDotProduct");

	return Clss;
}


// MaterialExpressionDotProduct Engine.Default__MaterialExpressionDotProduct
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDotProduct* UMaterialExpressionDotProduct::GetDefaultObj()
{
	static class UMaterialExpressionDotProduct* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDotProduct*>(UMaterialExpressionDotProduct::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionDynamicParameter
// (None)

class UClass* UMaterialExpressionDynamicParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionDynamicParameter");

	return Clss;
}


// MaterialExpressionDynamicParameter Engine.Default__MaterialExpressionDynamicParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionDynamicParameter* UMaterialExpressionDynamicParameter::GetDefaultObj()
{
	static class UMaterialExpressionDynamicParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionDynamicParameter*>(UMaterialExpressionDynamicParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionEyeAdaptation
// (None)

class UClass* UMaterialExpressionEyeAdaptation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionEyeAdaptation");

	return Clss;
}


// MaterialExpressionEyeAdaptation Engine.Default__MaterialExpressionEyeAdaptation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionEyeAdaptation* UMaterialExpressionEyeAdaptation::GetDefaultObj()
{
	static class UMaterialExpressionEyeAdaptation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionEyeAdaptation*>(UMaterialExpressionEyeAdaptation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFeatureLevelSwitch
// (None)

class UClass* UMaterialExpressionFeatureLevelSwitch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFeatureLevelSwitch");

	return Clss;
}


// MaterialExpressionFeatureLevelSwitch Engine.Default__MaterialExpressionFeatureLevelSwitch
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFeatureLevelSwitch* UMaterialExpressionFeatureLevelSwitch::GetDefaultObj()
{
	static class UMaterialExpressionFeatureLevelSwitch* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFeatureLevelSwitch*>(UMaterialExpressionFeatureLevelSwitch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFloor
// (None)

class UClass* UMaterialExpressionFloor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFloor");

	return Clss;
}


// MaterialExpressionFloor Engine.Default__MaterialExpressionFloor
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFloor* UMaterialExpressionFloor::GetDefaultObj()
{
	static class UMaterialExpressionFloor* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFloor*>(UMaterialExpressionFloor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFmod
// (None)

class UClass* UMaterialExpressionFmod::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFmod");

	return Clss;
}


// MaterialExpressionFmod Engine.Default__MaterialExpressionFmod
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFmod* UMaterialExpressionFmod::GetDefaultObj()
{
	static class UMaterialExpressionFmod* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFmod*>(UMaterialExpressionFmod::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFontSample
// (None)

class UClass* UMaterialExpressionFontSample::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFontSample");

	return Clss;
}


// MaterialExpressionFontSample Engine.Default__MaterialExpressionFontSample
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFontSample* UMaterialExpressionFontSample::GetDefaultObj()
{
	static class UMaterialExpressionFontSample* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFontSample*>(UMaterialExpressionFontSample::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFontSampleParameter
// (None)

class UClass* UMaterialExpressionFontSampleParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFontSampleParameter");

	return Clss;
}


// MaterialExpressionFontSampleParameter Engine.Default__MaterialExpressionFontSampleParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFontSampleParameter* UMaterialExpressionFontSampleParameter::GetDefaultObj()
{
	static class UMaterialExpressionFontSampleParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFontSampleParameter*>(UMaterialExpressionFontSampleParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFrac
// (None)

class UClass* UMaterialExpressionFrac::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFrac");

	return Clss;
}


// MaterialExpressionFrac Engine.Default__MaterialExpressionFrac
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFrac* UMaterialExpressionFrac::GetDefaultObj()
{
	static class UMaterialExpressionFrac* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFrac*>(UMaterialExpressionFrac::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFresnel
// (None)

class UClass* UMaterialExpressionFresnel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFresnel");

	return Clss;
}


// MaterialExpressionFresnel Engine.Default__MaterialExpressionFresnel
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFresnel* UMaterialExpressionFresnel::GetDefaultObj()
{
	static class UMaterialExpressionFresnel* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFresnel*>(UMaterialExpressionFresnel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFunctionInput
// (None)

class UClass* UMaterialExpressionFunctionInput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFunctionInput");

	return Clss;
}


// MaterialExpressionFunctionInput Engine.Default__MaterialExpressionFunctionInput
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFunctionInput* UMaterialExpressionFunctionInput::GetDefaultObj()
{
	static class UMaterialExpressionFunctionInput* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFunctionInput*>(UMaterialExpressionFunctionInput::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionFunctionOutput
// (None)

class UClass* UMaterialExpressionFunctionOutput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionFunctionOutput");

	return Clss;
}


// MaterialExpressionFunctionOutput Engine.Default__MaterialExpressionFunctionOutput
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionFunctionOutput* UMaterialExpressionFunctionOutput::GetDefaultObj()
{
	static class UMaterialExpressionFunctionOutput* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionFunctionOutput*>(UMaterialExpressionFunctionOutput::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionGetMaterialAttributes
// (None)

class UClass* UMaterialExpressionGetMaterialAttributes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionGetMaterialAttributes");

	return Clss;
}


// MaterialExpressionGetMaterialAttributes Engine.Default__MaterialExpressionGetMaterialAttributes
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionGetMaterialAttributes* UMaterialExpressionGetMaterialAttributes::GetDefaultObj()
{
	static class UMaterialExpressionGetMaterialAttributes* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionGetMaterialAttributes*>(UMaterialExpressionGetMaterialAttributes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionGIReplace
// (None)

class UClass* UMaterialExpressionGIReplace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionGIReplace");

	return Clss;
}


// MaterialExpressionGIReplace Engine.Default__MaterialExpressionGIReplace
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionGIReplace* UMaterialExpressionGIReplace::GetDefaultObj()
{
	static class UMaterialExpressionGIReplace* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionGIReplace*>(UMaterialExpressionGIReplace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionIf
// (None)

class UClass* UMaterialExpressionIf::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionIf");

	return Clss;
}


// MaterialExpressionIf Engine.Default__MaterialExpressionIf
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionIf* UMaterialExpressionIf::GetDefaultObj()
{
	static class UMaterialExpressionIf* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionIf*>(UMaterialExpressionIf::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionLightmapUVs
// (None)

class UClass* UMaterialExpressionLightmapUVs::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionLightmapUVs");

	return Clss;
}


// MaterialExpressionLightmapUVs Engine.Default__MaterialExpressionLightmapUVs
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionLightmapUVs* UMaterialExpressionLightmapUVs::GetDefaultObj()
{
	static class UMaterialExpressionLightmapUVs* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionLightmapUVs*>(UMaterialExpressionLightmapUVs::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionLightmassReplace
// (None)

class UClass* UMaterialExpressionLightmassReplace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionLightmassReplace");

	return Clss;
}


// MaterialExpressionLightmassReplace Engine.Default__MaterialExpressionLightmassReplace
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionLightmassReplace* UMaterialExpressionLightmassReplace::GetDefaultObj()
{
	static class UMaterialExpressionLightmassReplace* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionLightmassReplace*>(UMaterialExpressionLightmassReplace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionLightVector
// (None)

class UClass* UMaterialExpressionLightVector::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionLightVector");

	return Clss;
}


// MaterialExpressionLightVector Engine.Default__MaterialExpressionLightVector
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionLightVector* UMaterialExpressionLightVector::GetDefaultObj()
{
	static class UMaterialExpressionLightVector* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionLightVector*>(UMaterialExpressionLightVector::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionLinearInterpolate
// (None)

class UClass* UMaterialExpressionLinearInterpolate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionLinearInterpolate");

	return Clss;
}


// MaterialExpressionLinearInterpolate Engine.Default__MaterialExpressionLinearInterpolate
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionLinearInterpolate* UMaterialExpressionLinearInterpolate::GetDefaultObj()
{
	static class UMaterialExpressionLinearInterpolate* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionLinearInterpolate*>(UMaterialExpressionLinearInterpolate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionLogarithm10
// (None)

class UClass* UMaterialExpressionLogarithm10::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionLogarithm10");

	return Clss;
}


// MaterialExpressionLogarithm10 Engine.Default__MaterialExpressionLogarithm10
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionLogarithm10* UMaterialExpressionLogarithm10::GetDefaultObj()
{
	static class UMaterialExpressionLogarithm10* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionLogarithm10*>(UMaterialExpressionLogarithm10::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionLogarithm2
// (None)

class UClass* UMaterialExpressionLogarithm2::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionLogarithm2");

	return Clss;
}


// MaterialExpressionLogarithm2 Engine.Default__MaterialExpressionLogarithm2
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionLogarithm2* UMaterialExpressionLogarithm2::GetDefaultObj()
{
	static class UMaterialExpressionLogarithm2* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionLogarithm2*>(UMaterialExpressionLogarithm2::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionMakeMaterialAttributes
// (None)

class UClass* UMaterialExpressionMakeMaterialAttributes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionMakeMaterialAttributes");

	return Clss;
}


// MaterialExpressionMakeMaterialAttributes Engine.Default__MaterialExpressionMakeMaterialAttributes
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionMakeMaterialAttributes* UMaterialExpressionMakeMaterialAttributes::GetDefaultObj()
{
	static class UMaterialExpressionMakeMaterialAttributes* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionMakeMaterialAttributes*>(UMaterialExpressionMakeMaterialAttributes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionMaterialAttributeLayers
// (None)

class UClass* UMaterialExpressionMaterialAttributeLayers::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionMaterialAttributeLayers");

	return Clss;
}


// MaterialExpressionMaterialAttributeLayers Engine.Default__MaterialExpressionMaterialAttributeLayers
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionMaterialAttributeLayers* UMaterialExpressionMaterialAttributeLayers::GetDefaultObj()
{
	static class UMaterialExpressionMaterialAttributeLayers* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionMaterialAttributeLayers*>(UMaterialExpressionMaterialAttributeLayers::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionMaterialFunctionCall
// (None)

class UClass* UMaterialExpressionMaterialFunctionCall::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionMaterialFunctionCall");

	return Clss;
}


// MaterialExpressionMaterialFunctionCall Engine.Default__MaterialExpressionMaterialFunctionCall
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionMaterialFunctionCall* UMaterialExpressionMaterialFunctionCall::GetDefaultObj()
{
	static class UMaterialExpressionMaterialFunctionCall* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionMaterialFunctionCall*>(UMaterialExpressionMaterialFunctionCall::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionMaterialLayerOutput
// (None)

class UClass* UMaterialExpressionMaterialLayerOutput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionMaterialLayerOutput");

	return Clss;
}


// MaterialExpressionMaterialLayerOutput Engine.Default__MaterialExpressionMaterialLayerOutput
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionMaterialLayerOutput* UMaterialExpressionMaterialLayerOutput::GetDefaultObj()
{
	static class UMaterialExpressionMaterialLayerOutput* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionMaterialLayerOutput*>(UMaterialExpressionMaterialLayerOutput::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionMaterialProxyReplace
// (None)

class UClass* UMaterialExpressionMaterialProxyReplace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionMaterialProxyReplace");

	return Clss;
}


// MaterialExpressionMaterialProxyReplace Engine.Default__MaterialExpressionMaterialProxyReplace
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionMaterialProxyReplace* UMaterialExpressionMaterialProxyReplace::GetDefaultObj()
{
	static class UMaterialExpressionMaterialProxyReplace* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionMaterialProxyReplace*>(UMaterialExpressionMaterialProxyReplace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionMax
// (None)

class UClass* UMaterialExpressionMax::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionMax");

	return Clss;
}


// MaterialExpressionMax Engine.Default__MaterialExpressionMax
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionMax* UMaterialExpressionMax::GetDefaultObj()
{
	static class UMaterialExpressionMax* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionMax*>(UMaterialExpressionMax::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionMin
// (None)

class UClass* UMaterialExpressionMin::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionMin");

	return Clss;
}


// MaterialExpressionMin Engine.Default__MaterialExpressionMin
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionMin* UMaterialExpressionMin::GetDefaultObj()
{
	static class UMaterialExpressionMin* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionMin*>(UMaterialExpressionMin::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionMultiply
// (None)

class UClass* UMaterialExpressionMultiply::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionMultiply");

	return Clss;
}


// MaterialExpressionMultiply Engine.Default__MaterialExpressionMultiply
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionMultiply* UMaterialExpressionMultiply::GetDefaultObj()
{
	static class UMaterialExpressionMultiply* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionMultiply*>(UMaterialExpressionMultiply::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionNoise
// (None)

class UClass* UMaterialExpressionNoise::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionNoise");

	return Clss;
}


// MaterialExpressionNoise Engine.Default__MaterialExpressionNoise
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionNoise* UMaterialExpressionNoise::GetDefaultObj()
{
	static class UMaterialExpressionNoise* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionNoise*>(UMaterialExpressionNoise::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionNormalize
// (None)

class UClass* UMaterialExpressionNormalize::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionNormalize");

	return Clss;
}


// MaterialExpressionNormalize Engine.Default__MaterialExpressionNormalize
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionNormalize* UMaterialExpressionNormalize::GetDefaultObj()
{
	static class UMaterialExpressionNormalize* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionNormalize*>(UMaterialExpressionNormalize::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionObjectBounds
// (None)

class UClass* UMaterialExpressionObjectBounds::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionObjectBounds");

	return Clss;
}


// MaterialExpressionObjectBounds Engine.Default__MaterialExpressionObjectBounds
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionObjectBounds* UMaterialExpressionObjectBounds::GetDefaultObj()
{
	static class UMaterialExpressionObjectBounds* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionObjectBounds*>(UMaterialExpressionObjectBounds::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionObjectOrientation
// (None)

class UClass* UMaterialExpressionObjectOrientation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionObjectOrientation");

	return Clss;
}


// MaterialExpressionObjectOrientation Engine.Default__MaterialExpressionObjectOrientation
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionObjectOrientation* UMaterialExpressionObjectOrientation::GetDefaultObj()
{
	static class UMaterialExpressionObjectOrientation* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionObjectOrientation*>(UMaterialExpressionObjectOrientation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionObjectPositionWS
// (None)

class UClass* UMaterialExpressionObjectPositionWS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionObjectPositionWS");

	return Clss;
}


// MaterialExpressionObjectPositionWS Engine.Default__MaterialExpressionObjectPositionWS
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionObjectPositionWS* UMaterialExpressionObjectPositionWS::GetDefaultObj()
{
	static class UMaterialExpressionObjectPositionWS* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionObjectPositionWS*>(UMaterialExpressionObjectPositionWS::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionObjectRadius
// (None)

class UClass* UMaterialExpressionObjectRadius::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionObjectRadius");

	return Clss;
}


// MaterialExpressionObjectRadius Engine.Default__MaterialExpressionObjectRadius
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionObjectRadius* UMaterialExpressionObjectRadius::GetDefaultObj()
{
	static class UMaterialExpressionObjectRadius* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionObjectRadius*>(UMaterialExpressionObjectRadius::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionOneMinus
// (None)

class UClass* UMaterialExpressionOneMinus::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionOneMinus");

	return Clss;
}


// MaterialExpressionOneMinus Engine.Default__MaterialExpressionOneMinus
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionOneMinus* UMaterialExpressionOneMinus::GetDefaultObj()
{
	static class UMaterialExpressionOneMinus* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionOneMinus*>(UMaterialExpressionOneMinus::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPanner
// (None)

class UClass* UMaterialExpressionPanner::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPanner");

	return Clss;
}


// MaterialExpressionPanner Engine.Default__MaterialExpressionPanner
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPanner* UMaterialExpressionPanner::GetDefaultObj()
{
	static class UMaterialExpressionPanner* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPanner*>(UMaterialExpressionPanner::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleColor
// (None)

class UClass* UMaterialExpressionParticleColor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleColor");

	return Clss;
}


// MaterialExpressionParticleColor Engine.Default__MaterialExpressionParticleColor
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleColor* UMaterialExpressionParticleColor::GetDefaultObj()
{
	static class UMaterialExpressionParticleColor* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleColor*>(UMaterialExpressionParticleColor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleDirection
// (None)

class UClass* UMaterialExpressionParticleDirection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleDirection");

	return Clss;
}


// MaterialExpressionParticleDirection Engine.Default__MaterialExpressionParticleDirection
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleDirection* UMaterialExpressionParticleDirection::GetDefaultObj()
{
	static class UMaterialExpressionParticleDirection* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleDirection*>(UMaterialExpressionParticleDirection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleMacroUV
// (None)

class UClass* UMaterialExpressionParticleMacroUV::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleMacroUV");

	return Clss;
}


// MaterialExpressionParticleMacroUV Engine.Default__MaterialExpressionParticleMacroUV
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleMacroUV* UMaterialExpressionParticleMacroUV::GetDefaultObj()
{
	static class UMaterialExpressionParticleMacroUV* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleMacroUV*>(UMaterialExpressionParticleMacroUV::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleMotionBlurFade
// (None)

class UClass* UMaterialExpressionParticleMotionBlurFade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleMotionBlurFade");

	return Clss;
}


// MaterialExpressionParticleMotionBlurFade Engine.Default__MaterialExpressionParticleMotionBlurFade
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleMotionBlurFade* UMaterialExpressionParticleMotionBlurFade::GetDefaultObj()
{
	static class UMaterialExpressionParticleMotionBlurFade* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleMotionBlurFade*>(UMaterialExpressionParticleMotionBlurFade::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticlePositionWS
// (None)

class UClass* UMaterialExpressionParticlePositionWS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticlePositionWS");

	return Clss;
}


// MaterialExpressionParticlePositionWS Engine.Default__MaterialExpressionParticlePositionWS
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticlePositionWS* UMaterialExpressionParticlePositionWS::GetDefaultObj()
{
	static class UMaterialExpressionParticlePositionWS* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticlePositionWS*>(UMaterialExpressionParticlePositionWS::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleRadius
// (None)

class UClass* UMaterialExpressionParticleRadius::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleRadius");

	return Clss;
}


// MaterialExpressionParticleRadius Engine.Default__MaterialExpressionParticleRadius
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleRadius* UMaterialExpressionParticleRadius::GetDefaultObj()
{
	static class UMaterialExpressionParticleRadius* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleRadius*>(UMaterialExpressionParticleRadius::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleRandom
// (None)

class UClass* UMaterialExpressionParticleRandom::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleRandom");

	return Clss;
}


// MaterialExpressionParticleRandom Engine.Default__MaterialExpressionParticleRandom
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleRandom* UMaterialExpressionParticleRandom::GetDefaultObj()
{
	static class UMaterialExpressionParticleRandom* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleRandom*>(UMaterialExpressionParticleRandom::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleRelativeTime
// (None)

class UClass* UMaterialExpressionParticleRelativeTime::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleRelativeTime");

	return Clss;
}


// MaterialExpressionParticleRelativeTime Engine.Default__MaterialExpressionParticleRelativeTime
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleRelativeTime* UMaterialExpressionParticleRelativeTime::GetDefaultObj()
{
	static class UMaterialExpressionParticleRelativeTime* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleRelativeTime*>(UMaterialExpressionParticleRelativeTime::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleSize
// (None)

class UClass* UMaterialExpressionParticleSize::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleSize");

	return Clss;
}


// MaterialExpressionParticleSize Engine.Default__MaterialExpressionParticleSize
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleSize* UMaterialExpressionParticleSize::GetDefaultObj()
{
	static class UMaterialExpressionParticleSize* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleSize*>(UMaterialExpressionParticleSize::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleSpeed
// (None)

class UClass* UMaterialExpressionParticleSpeed::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleSpeed");

	return Clss;
}


// MaterialExpressionParticleSpeed Engine.Default__MaterialExpressionParticleSpeed
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleSpeed* UMaterialExpressionParticleSpeed::GetDefaultObj()
{
	static class UMaterialExpressionParticleSpeed* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleSpeed*>(UMaterialExpressionParticleSpeed::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionParticleSubUV
// (None)

class UClass* UMaterialExpressionParticleSubUV::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionParticleSubUV");

	return Clss;
}


// MaterialExpressionParticleSubUV Engine.Default__MaterialExpressionParticleSubUV
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionParticleSubUV* UMaterialExpressionParticleSubUV::GetDefaultObj()
{
	static class UMaterialExpressionParticleSubUV* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionParticleSubUV*>(UMaterialExpressionParticleSubUV::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPerInstanceFadeAmount
// (None)

class UClass* UMaterialExpressionPerInstanceFadeAmount::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPerInstanceFadeAmount");

	return Clss;
}


// MaterialExpressionPerInstanceFadeAmount Engine.Default__MaterialExpressionPerInstanceFadeAmount
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPerInstanceFadeAmount* UMaterialExpressionPerInstanceFadeAmount::GetDefaultObj()
{
	static class UMaterialExpressionPerInstanceFadeAmount* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPerInstanceFadeAmount*>(UMaterialExpressionPerInstanceFadeAmount::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPerInstanceRandom
// (None)

class UClass* UMaterialExpressionPerInstanceRandom::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPerInstanceRandom");

	return Clss;
}


// MaterialExpressionPerInstanceRandom Engine.Default__MaterialExpressionPerInstanceRandom
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPerInstanceRandom* UMaterialExpressionPerInstanceRandom::GetDefaultObj()
{
	static class UMaterialExpressionPerInstanceRandom* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPerInstanceRandom*>(UMaterialExpressionPerInstanceRandom::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPixelDepth
// (None)

class UClass* UMaterialExpressionPixelDepth::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPixelDepth");

	return Clss;
}


// MaterialExpressionPixelDepth Engine.Default__MaterialExpressionPixelDepth
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPixelDepth* UMaterialExpressionPixelDepth::GetDefaultObj()
{
	static class UMaterialExpressionPixelDepth* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPixelDepth*>(UMaterialExpressionPixelDepth::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPixelNormalWS
// (None)

class UClass* UMaterialExpressionPixelNormalWS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPixelNormalWS");

	return Clss;
}


// MaterialExpressionPixelNormalWS Engine.Default__MaterialExpressionPixelNormalWS
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPixelNormalWS* UMaterialExpressionPixelNormalWS::GetDefaultObj()
{
	static class UMaterialExpressionPixelNormalWS* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPixelNormalWS*>(UMaterialExpressionPixelNormalWS::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPower
// (None)

class UClass* UMaterialExpressionPower::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPower");

	return Clss;
}


// MaterialExpressionPower Engine.Default__MaterialExpressionPower
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPower* UMaterialExpressionPower::GetDefaultObj()
{
	static class UMaterialExpressionPower* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPower*>(UMaterialExpressionPower::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPrecomputedAOMask
// (None)

class UClass* UMaterialExpressionPrecomputedAOMask::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPrecomputedAOMask");

	return Clss;
}


// MaterialExpressionPrecomputedAOMask Engine.Default__MaterialExpressionPrecomputedAOMask
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPrecomputedAOMask* UMaterialExpressionPrecomputedAOMask::GetDefaultObj()
{
	static class UMaterialExpressionPrecomputedAOMask* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPrecomputedAOMask*>(UMaterialExpressionPrecomputedAOMask::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPreSkinnedLocalBounds
// (None)

class UClass* UMaterialExpressionPreSkinnedLocalBounds::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPreSkinnedLocalBounds");

	return Clss;
}


// MaterialExpressionPreSkinnedLocalBounds Engine.Default__MaterialExpressionPreSkinnedLocalBounds
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPreSkinnedLocalBounds* UMaterialExpressionPreSkinnedLocalBounds::GetDefaultObj()
{
	static class UMaterialExpressionPreSkinnedLocalBounds* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPreSkinnedLocalBounds*>(UMaterialExpressionPreSkinnedLocalBounds::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPreSkinnedNormal
// (None)

class UClass* UMaterialExpressionPreSkinnedNormal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPreSkinnedNormal");

	return Clss;
}


// MaterialExpressionPreSkinnedNormal Engine.Default__MaterialExpressionPreSkinnedNormal
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPreSkinnedNormal* UMaterialExpressionPreSkinnedNormal::GetDefaultObj()
{
	static class UMaterialExpressionPreSkinnedNormal* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPreSkinnedNormal*>(UMaterialExpressionPreSkinnedNormal::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPreSkinnedPosition
// (None)

class UClass* UMaterialExpressionPreSkinnedPosition::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPreSkinnedPosition");

	return Clss;
}


// MaterialExpressionPreSkinnedPosition Engine.Default__MaterialExpressionPreSkinnedPosition
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPreSkinnedPosition* UMaterialExpressionPreSkinnedPosition::GetDefaultObj()
{
	static class UMaterialExpressionPreSkinnedPosition* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPreSkinnedPosition*>(UMaterialExpressionPreSkinnedPosition::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionPreviousFrameSwitch
// (None)

class UClass* UMaterialExpressionPreviousFrameSwitch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionPreviousFrameSwitch");

	return Clss;
}


// MaterialExpressionPreviousFrameSwitch Engine.Default__MaterialExpressionPreviousFrameSwitch
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionPreviousFrameSwitch* UMaterialExpressionPreviousFrameSwitch::GetDefaultObj()
{
	static class UMaterialExpressionPreviousFrameSwitch* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionPreviousFrameSwitch*>(UMaterialExpressionPreviousFrameSwitch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionQualitySwitch
// (None)

class UClass* UMaterialExpressionQualitySwitch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionQualitySwitch");

	return Clss;
}


// MaterialExpressionQualitySwitch Engine.Default__MaterialExpressionQualitySwitch
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionQualitySwitch* UMaterialExpressionQualitySwitch::GetDefaultObj()
{
	static class UMaterialExpressionQualitySwitch* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionQualitySwitch*>(UMaterialExpressionQualitySwitch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionRayTracingQualitySwitch
// (None)

class UClass* UMaterialExpressionRayTracingQualitySwitch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionRayTracingQualitySwitch");

	return Clss;
}


// MaterialExpressionRayTracingQualitySwitch Engine.Default__MaterialExpressionRayTracingQualitySwitch
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionRayTracingQualitySwitch* UMaterialExpressionRayTracingQualitySwitch::GetDefaultObj()
{
	static class UMaterialExpressionRayTracingQualitySwitch* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionRayTracingQualitySwitch*>(UMaterialExpressionRayTracingQualitySwitch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionReflectionVectorWS
// (None)

class UClass* UMaterialExpressionReflectionVectorWS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionReflectionVectorWS");

	return Clss;
}


// MaterialExpressionReflectionVectorWS Engine.Default__MaterialExpressionReflectionVectorWS
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionReflectionVectorWS* UMaterialExpressionReflectionVectorWS::GetDefaultObj()
{
	static class UMaterialExpressionReflectionVectorWS* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionReflectionVectorWS*>(UMaterialExpressionReflectionVectorWS::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionReroute
// (None)

class UClass* UMaterialExpressionReroute::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionReroute");

	return Clss;
}


// MaterialExpressionReroute Engine.Default__MaterialExpressionReroute
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionReroute* UMaterialExpressionReroute::GetDefaultObj()
{
	static class UMaterialExpressionReroute* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionReroute*>(UMaterialExpressionReroute::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionRotateAboutAxis
// (None)

class UClass* UMaterialExpressionRotateAboutAxis::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionRotateAboutAxis");

	return Clss;
}


// MaterialExpressionRotateAboutAxis Engine.Default__MaterialExpressionRotateAboutAxis
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionRotateAboutAxis* UMaterialExpressionRotateAboutAxis::GetDefaultObj()
{
	static class UMaterialExpressionRotateAboutAxis* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionRotateAboutAxis*>(UMaterialExpressionRotateAboutAxis::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionRotator
// (None)

class UClass* UMaterialExpressionRotator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionRotator");

	return Clss;
}


// MaterialExpressionRotator Engine.Default__MaterialExpressionRotator
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionRotator* UMaterialExpressionRotator::GetDefaultObj()
{
	static class UMaterialExpressionRotator* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionRotator*>(UMaterialExpressionRotator::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionRound
// (None)

class UClass* UMaterialExpressionRound::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionRound");

	return Clss;
}


// MaterialExpressionRound Engine.Default__MaterialExpressionRound
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionRound* UMaterialExpressionRound::GetDefaultObj()
{
	static class UMaterialExpressionRound* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionRound*>(UMaterialExpressionRound::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSaturate
// (None)

class UClass* UMaterialExpressionSaturate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSaturate");

	return Clss;
}


// MaterialExpressionSaturate Engine.Default__MaterialExpressionSaturate
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSaturate* UMaterialExpressionSaturate::GetDefaultObj()
{
	static class UMaterialExpressionSaturate* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSaturate*>(UMaterialExpressionSaturate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSceneColor
// (None)

class UClass* UMaterialExpressionSceneColor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSceneColor");

	return Clss;
}


// MaterialExpressionSceneColor Engine.Default__MaterialExpressionSceneColor
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSceneColor* UMaterialExpressionSceneColor::GetDefaultObj()
{
	static class UMaterialExpressionSceneColor* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSceneColor*>(UMaterialExpressionSceneColor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSceneDepth
// (None)

class UClass* UMaterialExpressionSceneDepth::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSceneDepth");

	return Clss;
}


// MaterialExpressionSceneDepth Engine.Default__MaterialExpressionSceneDepth
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSceneDepth* UMaterialExpressionSceneDepth::GetDefaultObj()
{
	static class UMaterialExpressionSceneDepth* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSceneDepth*>(UMaterialExpressionSceneDepth::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSceneTexelSize
// (None)

class UClass* UMaterialExpressionSceneTexelSize::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSceneTexelSize");

	return Clss;
}


// MaterialExpressionSceneTexelSize Engine.Default__MaterialExpressionSceneTexelSize
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSceneTexelSize* UMaterialExpressionSceneTexelSize::GetDefaultObj()
{
	static class UMaterialExpressionSceneTexelSize* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSceneTexelSize*>(UMaterialExpressionSceneTexelSize::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSceneTexture
// (None)

class UClass* UMaterialExpressionSceneTexture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSceneTexture");

	return Clss;
}


// MaterialExpressionSceneTexture Engine.Default__MaterialExpressionSceneTexture
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSceneTexture* UMaterialExpressionSceneTexture::GetDefaultObj()
{
	static class UMaterialExpressionSceneTexture* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSceneTexture*>(UMaterialExpressionSceneTexture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionScreenPosition
// (None)

class UClass* UMaterialExpressionScreenPosition::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionScreenPosition");

	return Clss;
}


// MaterialExpressionScreenPosition Engine.Default__MaterialExpressionScreenPosition
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionScreenPosition* UMaterialExpressionScreenPosition::GetDefaultObj()
{
	static class UMaterialExpressionScreenPosition* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionScreenPosition*>(UMaterialExpressionScreenPosition::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSetMaterialAttributes
// (None)

class UClass* UMaterialExpressionSetMaterialAttributes::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSetMaterialAttributes");

	return Clss;
}


// MaterialExpressionSetMaterialAttributes Engine.Default__MaterialExpressionSetMaterialAttributes
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSetMaterialAttributes* UMaterialExpressionSetMaterialAttributes::GetDefaultObj()
{
	static class UMaterialExpressionSetMaterialAttributes* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSetMaterialAttributes*>(UMaterialExpressionSetMaterialAttributes::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionShadingModel
// (None)

class UClass* UMaterialExpressionShadingModel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionShadingModel");

	return Clss;
}


// MaterialExpressionShadingModel Engine.Default__MaterialExpressionShadingModel
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionShadingModel* UMaterialExpressionShadingModel::GetDefaultObj()
{
	static class UMaterialExpressionShadingModel* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionShadingModel*>(UMaterialExpressionShadingModel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionShadingPathSwitch
// (None)

class UClass* UMaterialExpressionShadingPathSwitch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionShadingPathSwitch");

	return Clss;
}


// MaterialExpressionShadingPathSwitch Engine.Default__MaterialExpressionShadingPathSwitch
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionShadingPathSwitch* UMaterialExpressionShadingPathSwitch::GetDefaultObj()
{
	static class UMaterialExpressionShadingPathSwitch* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionShadingPathSwitch*>(UMaterialExpressionShadingPathSwitch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionShadowReplace
// (None)

class UClass* UMaterialExpressionShadowReplace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionShadowReplace");

	return Clss;
}


// MaterialExpressionShadowReplace Engine.Default__MaterialExpressionShadowReplace
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionShadowReplace* UMaterialExpressionShadowReplace::GetDefaultObj()
{
	static class UMaterialExpressionShadowReplace* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionShadowReplace*>(UMaterialExpressionShadowReplace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSign
// (None)

class UClass* UMaterialExpressionSign::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSign");

	return Clss;
}


// MaterialExpressionSign Engine.Default__MaterialExpressionSign
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSign* UMaterialExpressionSign::GetDefaultObj()
{
	static class UMaterialExpressionSign* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSign*>(UMaterialExpressionSign::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSine
// (None)

class UClass* UMaterialExpressionSine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSine");

	return Clss;
}


// MaterialExpressionSine Engine.Default__MaterialExpressionSine
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSine* UMaterialExpressionSine::GetDefaultObj()
{
	static class UMaterialExpressionSine* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSine*>(UMaterialExpressionSine::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSobol
// (None)

class UClass* UMaterialExpressionSobol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSobol");

	return Clss;
}


// MaterialExpressionSobol Engine.Default__MaterialExpressionSobol
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSobol* UMaterialExpressionSobol::GetDefaultObj()
{
	static class UMaterialExpressionSobol* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSobol*>(UMaterialExpressionSobol::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSpeedTree
// (None)

class UClass* UMaterialExpressionSpeedTree::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSpeedTree");

	return Clss;
}


// MaterialExpressionSpeedTree Engine.Default__MaterialExpressionSpeedTree
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSpeedTree* UMaterialExpressionSpeedTree::GetDefaultObj()
{
	static class UMaterialExpressionSpeedTree* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSpeedTree*>(UMaterialExpressionSpeedTree::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSphereMask
// (None)

class UClass* UMaterialExpressionSphereMask::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSphereMask");

	return Clss;
}


// MaterialExpressionSphereMask Engine.Default__MaterialExpressionSphereMask
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSphereMask* UMaterialExpressionSphereMask::GetDefaultObj()
{
	static class UMaterialExpressionSphereMask* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSphereMask*>(UMaterialExpressionSphereMask::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSphericalParticleOpacity
// (None)

class UClass* UMaterialExpressionSphericalParticleOpacity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSphericalParticleOpacity");

	return Clss;
}


// MaterialExpressionSphericalParticleOpacity Engine.Default__MaterialExpressionSphericalParticleOpacity
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSphericalParticleOpacity* UMaterialExpressionSphericalParticleOpacity::GetDefaultObj()
{
	static class UMaterialExpressionSphericalParticleOpacity* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSphericalParticleOpacity*>(UMaterialExpressionSphericalParticleOpacity::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSquareRoot
// (None)

class UClass* UMaterialExpressionSquareRoot::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSquareRoot");

	return Clss;
}


// MaterialExpressionSquareRoot Engine.Default__MaterialExpressionSquareRoot
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSquareRoot* UMaterialExpressionSquareRoot::GetDefaultObj()
{
	static class UMaterialExpressionSquareRoot* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSquareRoot*>(UMaterialExpressionSquareRoot::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionStaticBool
// (None)

class UClass* UMaterialExpressionStaticBool::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionStaticBool");

	return Clss;
}


// MaterialExpressionStaticBool Engine.Default__MaterialExpressionStaticBool
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionStaticBool* UMaterialExpressionStaticBool::GetDefaultObj()
{
	static class UMaterialExpressionStaticBool* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionStaticBool*>(UMaterialExpressionStaticBool::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionStaticBoolParameter
// (None)

class UClass* UMaterialExpressionStaticBoolParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionStaticBoolParameter");

	return Clss;
}


// MaterialExpressionStaticBoolParameter Engine.Default__MaterialExpressionStaticBoolParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionStaticBoolParameter* UMaterialExpressionStaticBoolParameter::GetDefaultObj()
{
	static class UMaterialExpressionStaticBoolParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionStaticBoolParameter*>(UMaterialExpressionStaticBoolParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionStaticComponentMaskParameter
// (None)

class UClass* UMaterialExpressionStaticComponentMaskParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionStaticComponentMaskParameter");

	return Clss;
}


// MaterialExpressionStaticComponentMaskParameter Engine.Default__MaterialExpressionStaticComponentMaskParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionStaticComponentMaskParameter* UMaterialExpressionStaticComponentMaskParameter::GetDefaultObj()
{
	static class UMaterialExpressionStaticComponentMaskParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionStaticComponentMaskParameter*>(UMaterialExpressionStaticComponentMaskParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionStaticSwitch
// (None)

class UClass* UMaterialExpressionStaticSwitch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionStaticSwitch");

	return Clss;
}


// MaterialExpressionStaticSwitch Engine.Default__MaterialExpressionStaticSwitch
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionStaticSwitch* UMaterialExpressionStaticSwitch::GetDefaultObj()
{
	static class UMaterialExpressionStaticSwitch* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionStaticSwitch*>(UMaterialExpressionStaticSwitch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionStaticSwitchParameter
// (None)

class UClass* UMaterialExpressionStaticSwitchParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionStaticSwitchParameter");

	return Clss;
}


// MaterialExpressionStaticSwitchParameter Engine.Default__MaterialExpressionStaticSwitchParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionStaticSwitchParameter* UMaterialExpressionStaticSwitchParameter::GetDefaultObj()
{
	static class UMaterialExpressionStaticSwitchParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionStaticSwitchParameter*>(UMaterialExpressionStaticSwitchParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionSubtract
// (None)

class UClass* UMaterialExpressionSubtract::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionSubtract");

	return Clss;
}


// MaterialExpressionSubtract Engine.Default__MaterialExpressionSubtract
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionSubtract* UMaterialExpressionSubtract::GetDefaultObj()
{
	static class UMaterialExpressionSubtract* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionSubtract*>(UMaterialExpressionSubtract::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTangent
// (None)

class UClass* UMaterialExpressionTangent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTangent");

	return Clss;
}


// MaterialExpressionTangent Engine.Default__MaterialExpressionTangent
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTangent* UMaterialExpressionTangent::GetDefaultObj()
{
	static class UMaterialExpressionTangent* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTangent*>(UMaterialExpressionTangent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTangentOutput
// (None)

class UClass* UMaterialExpressionTangentOutput::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTangentOutput");

	return Clss;
}


// MaterialExpressionTangentOutput Engine.Default__MaterialExpressionTangentOutput
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTangentOutput* UMaterialExpressionTangentOutput::GetDefaultObj()
{
	static class UMaterialExpressionTangentOutput* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTangentOutput*>(UMaterialExpressionTangentOutput::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTemporalSobol
// (None)

class UClass* UMaterialExpressionTemporalSobol::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTemporalSobol");

	return Clss;
}


// MaterialExpressionTemporalSobol Engine.Default__MaterialExpressionTemporalSobol
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTemporalSobol* UMaterialExpressionTemporalSobol::GetDefaultObj()
{
	static class UMaterialExpressionTemporalSobol* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTemporalSobol*>(UMaterialExpressionTemporalSobol::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureCoordinate
// (None)

class UClass* UMaterialExpressionTextureCoordinate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureCoordinate");

	return Clss;
}


// MaterialExpressionTextureCoordinate Engine.Default__MaterialExpressionTextureCoordinate
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureCoordinate* UMaterialExpressionTextureCoordinate::GetDefaultObj()
{
	static class UMaterialExpressionTextureCoordinate* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureCoordinate*>(UMaterialExpressionTextureCoordinate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureObject
// (None)

class UClass* UMaterialExpressionTextureObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureObject");

	return Clss;
}


// MaterialExpressionTextureObject Engine.Default__MaterialExpressionTextureObject
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureObject* UMaterialExpressionTextureObject::GetDefaultObj()
{
	static class UMaterialExpressionTextureObject* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureObject*>(UMaterialExpressionTextureObject::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureObjectParameter
// (None)

class UClass* UMaterialExpressionTextureObjectParameter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureObjectParameter");

	return Clss;
}


// MaterialExpressionTextureObjectParameter Engine.Default__MaterialExpressionTextureObjectParameter
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureObjectParameter* UMaterialExpressionTextureObjectParameter::GetDefaultObj()
{
	static class UMaterialExpressionTextureObjectParameter* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureObjectParameter*>(UMaterialExpressionTextureObjectParameter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureProperty
// (None)

class UClass* UMaterialExpressionTextureProperty::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureProperty");

	return Clss;
}


// MaterialExpressionTextureProperty Engine.Default__MaterialExpressionTextureProperty
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureProperty* UMaterialExpressionTextureProperty::GetDefaultObj()
{
	static class UMaterialExpressionTextureProperty* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureProperty*>(UMaterialExpressionTextureProperty::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureSampleParameterCube
// (None)

class UClass* UMaterialExpressionTextureSampleParameterCube::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureSampleParameterCube");

	return Clss;
}


// MaterialExpressionTextureSampleParameterCube Engine.Default__MaterialExpressionTextureSampleParameterCube
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureSampleParameterCube* UMaterialExpressionTextureSampleParameterCube::GetDefaultObj()
{
	static class UMaterialExpressionTextureSampleParameterCube* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureSampleParameterCube*>(UMaterialExpressionTextureSampleParameterCube::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureSampleParameterSubUV
// (None)

class UClass* UMaterialExpressionTextureSampleParameterSubUV::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureSampleParameterSubUV");

	return Clss;
}


// MaterialExpressionTextureSampleParameterSubUV Engine.Default__MaterialExpressionTextureSampleParameterSubUV
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureSampleParameterSubUV* UMaterialExpressionTextureSampleParameterSubUV::GetDefaultObj()
{
	static class UMaterialExpressionTextureSampleParameterSubUV* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureSampleParameterSubUV*>(UMaterialExpressionTextureSampleParameterSubUV::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTextureSampleParameterVolume
// (None)

class UClass* UMaterialExpressionTextureSampleParameterVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTextureSampleParameterVolume");

	return Clss;
}


// MaterialExpressionTextureSampleParameterVolume Engine.Default__MaterialExpressionTextureSampleParameterVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTextureSampleParameterVolume* UMaterialExpressionTextureSampleParameterVolume::GetDefaultObj()
{
	static class UMaterialExpressionTextureSampleParameterVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTextureSampleParameterVolume*>(UMaterialExpressionTextureSampleParameterVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTime
// (None)

class UClass* UMaterialExpressionTime::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTime");

	return Clss;
}


// MaterialExpressionTime Engine.Default__MaterialExpressionTime
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTime* UMaterialExpressionTime::GetDefaultObj()
{
	static class UMaterialExpressionTime* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTime*>(UMaterialExpressionTime::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTransform
// (None)

class UClass* UMaterialExpressionTransform::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTransform");

	return Clss;
}


// MaterialExpressionTransform Engine.Default__MaterialExpressionTransform
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTransform* UMaterialExpressionTransform::GetDefaultObj()
{
	static class UMaterialExpressionTransform* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTransform*>(UMaterialExpressionTransform::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTransformPosition
// (None)

class UClass* UMaterialExpressionTransformPosition::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTransformPosition");

	return Clss;
}


// MaterialExpressionTransformPosition Engine.Default__MaterialExpressionTransformPosition
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTransformPosition* UMaterialExpressionTransformPosition::GetDefaultObj()
{
	static class UMaterialExpressionTransformPosition* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTransformPosition*>(UMaterialExpressionTransformPosition::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTruncate
// (None)

class UClass* UMaterialExpressionTruncate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTruncate");

	return Clss;
}


// MaterialExpressionTruncate Engine.Default__MaterialExpressionTruncate
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTruncate* UMaterialExpressionTruncate::GetDefaultObj()
{
	static class UMaterialExpressionTruncate* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTruncate*>(UMaterialExpressionTruncate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionTwoSidedSign
// (None)

class UClass* UMaterialExpressionTwoSidedSign::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionTwoSidedSign");

	return Clss;
}


// MaterialExpressionTwoSidedSign Engine.Default__MaterialExpressionTwoSidedSign
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionTwoSidedSign* UMaterialExpressionTwoSidedSign::GetDefaultObj()
{
	static class UMaterialExpressionTwoSidedSign* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionTwoSidedSign*>(UMaterialExpressionTwoSidedSign::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionVectorNoise
// (None)

class UClass* UMaterialExpressionVectorNoise::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionVectorNoise");

	return Clss;
}


// MaterialExpressionVectorNoise Engine.Default__MaterialExpressionVectorNoise
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionVectorNoise* UMaterialExpressionVectorNoise::GetDefaultObj()
{
	static class UMaterialExpressionVectorNoise* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionVectorNoise*>(UMaterialExpressionVectorNoise::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionVertexColor
// (None)

class UClass* UMaterialExpressionVertexColor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionVertexColor");

	return Clss;
}


// MaterialExpressionVertexColor Engine.Default__MaterialExpressionVertexColor
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionVertexColor* UMaterialExpressionVertexColor::GetDefaultObj()
{
	static class UMaterialExpressionVertexColor* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionVertexColor*>(UMaterialExpressionVertexColor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionVertexInterpolator
// (None)

class UClass* UMaterialExpressionVertexInterpolator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionVertexInterpolator");

	return Clss;
}


// MaterialExpressionVertexInterpolator Engine.Default__MaterialExpressionVertexInterpolator
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionVertexInterpolator* UMaterialExpressionVertexInterpolator::GetDefaultObj()
{
	static class UMaterialExpressionVertexInterpolator* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionVertexInterpolator*>(UMaterialExpressionVertexInterpolator::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionVertexNormalWS
// (None)

class UClass* UMaterialExpressionVertexNormalWS::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionVertexNormalWS");

	return Clss;
}


// MaterialExpressionVertexNormalWS Engine.Default__MaterialExpressionVertexNormalWS
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionVertexNormalWS* UMaterialExpressionVertexNormalWS::GetDefaultObj()
{
	static class UMaterialExpressionVertexNormalWS* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionVertexNormalWS*>(UMaterialExpressionVertexNormalWS::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionViewProperty
// (None)

class UClass* UMaterialExpressionViewProperty::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionViewProperty");

	return Clss;
}


// MaterialExpressionViewProperty Engine.Default__MaterialExpressionViewProperty
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionViewProperty* UMaterialExpressionViewProperty::GetDefaultObj()
{
	static class UMaterialExpressionViewProperty* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionViewProperty*>(UMaterialExpressionViewProperty::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionViewSize
// (None)

class UClass* UMaterialExpressionViewSize::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionViewSize");

	return Clss;
}


// MaterialExpressionViewSize Engine.Default__MaterialExpressionViewSize
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionViewSize* UMaterialExpressionViewSize::GetDefaultObj()
{
	static class UMaterialExpressionViewSize* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionViewSize*>(UMaterialExpressionViewSize::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialExpressionWorldPosition
// (None)

class UClass* UMaterialExpressionWorldPosition::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialExpressionWorldPosition");

	return Clss;
}


// MaterialExpressionWorldPosition Engine.Default__MaterialExpressionWorldPosition
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialExpressionWorldPosition* UMaterialExpressionWorldPosition::GetDefaultObj()
{
	static class UMaterialExpressionWorldPosition* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialExpressionWorldPosition*>(UMaterialExpressionWorldPosition::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialFunctionInterface
// (None)

class UClass* UMaterialFunctionInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialFunctionInterface");

	return Clss;
}


// MaterialFunctionInterface Engine.Default__MaterialFunctionInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialFunctionInterface* UMaterialFunctionInterface::GetDefaultObj()
{
	static class UMaterialFunctionInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialFunctionInterface*>(UMaterialFunctionInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialFunction
// (None)

class UClass* UMaterialFunction::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialFunction");

	return Clss;
}


// MaterialFunction Engine.Default__MaterialFunction
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialFunction* UMaterialFunction::GetDefaultObj()
{
	static class UMaterialFunction* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialFunction*>(UMaterialFunction::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialFunctionInstance
// (None)

class UClass* UMaterialFunctionInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialFunctionInstance");

	return Clss;
}


// MaterialFunctionInstance Engine.Default__MaterialFunctionInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialFunctionInstance* UMaterialFunctionInstance::GetDefaultObj()
{
	static class UMaterialFunctionInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialFunctionInstance*>(UMaterialFunctionInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialFunctionMaterialLayer
// (None)

class UClass* UMaterialFunctionMaterialLayer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialFunctionMaterialLayer");

	return Clss;
}


// MaterialFunctionMaterialLayer Engine.Default__MaterialFunctionMaterialLayer
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialFunctionMaterialLayer* UMaterialFunctionMaterialLayer::GetDefaultObj()
{
	static class UMaterialFunctionMaterialLayer* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialFunctionMaterialLayer*>(UMaterialFunctionMaterialLayer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialFunctionMaterialLayerInstance
// (None)

class UClass* UMaterialFunctionMaterialLayerInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialFunctionMaterialLayerInstance");

	return Clss;
}


// MaterialFunctionMaterialLayerInstance Engine.Default__MaterialFunctionMaterialLayerInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialFunctionMaterialLayerInstance* UMaterialFunctionMaterialLayerInstance::GetDefaultObj()
{
	static class UMaterialFunctionMaterialLayerInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialFunctionMaterialLayerInstance*>(UMaterialFunctionMaterialLayerInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialFunctionMaterialLayerBlend
// (None)

class UClass* UMaterialFunctionMaterialLayerBlend::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialFunctionMaterialLayerBlend");

	return Clss;
}


// MaterialFunctionMaterialLayerBlend Engine.Default__MaterialFunctionMaterialLayerBlend
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialFunctionMaterialLayerBlend* UMaterialFunctionMaterialLayerBlend::GetDefaultObj()
{
	static class UMaterialFunctionMaterialLayerBlend* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialFunctionMaterialLayerBlend*>(UMaterialFunctionMaterialLayerBlend::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialFunctionMaterialLayerBlendInstance
// (None)

class UClass* UMaterialFunctionMaterialLayerBlendInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialFunctionMaterialLayerBlendInstance");

	return Clss;
}


// MaterialFunctionMaterialLayerBlendInstance Engine.Default__MaterialFunctionMaterialLayerBlendInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialFunctionMaterialLayerBlendInstance* UMaterialFunctionMaterialLayerBlendInstance::GetDefaultObj()
{
	static class UMaterialFunctionMaterialLayerBlendInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialFunctionMaterialLayerBlendInstance*>(UMaterialFunctionMaterialLayerBlendInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialInstanceActor
// (Actor)

class UClass* AMaterialInstanceActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialInstanceActor");

	return Clss;
}


// MaterialInstanceActor Engine.Default__MaterialInstanceActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AMaterialInstanceActor* AMaterialInstanceActor::GetDefaultObj()
{
	static class AMaterialInstanceActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AMaterialInstanceActor*>(AMaterialInstanceActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialInstanceDynamic
// (None)

class UClass* UMaterialInstanceDynamic::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialInstanceDynamic");

	return Clss;
}


// MaterialInstanceDynamic Engine.Default__MaterialInstanceDynamic
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialInstanceDynamic* UMaterialInstanceDynamic::GetDefaultObj()
{
	static class UMaterialInstanceDynamic* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialInstanceDynamic*>(UMaterialInstanceDynamic::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.MaterialInstanceDynamic.SetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetVectorParameterValue(class FName ParameterName, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "SetVectorParameterValue");

	Params::UMaterialInstanceDynamic_SetVectorParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MaterialInstanceDynamic.SetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetTextureParameterValue(class FName ParameterName, class UTexture* Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "SetTextureParameterValue");

	Params::UMaterialInstanceDynamic_SetTextureParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MaterialInstanceDynamic.SetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetScalarParameterValue(class FName ParameterName, float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "SetScalarParameterValue");

	Params::UMaterialInstanceDynamic_SetScalarParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*           SourceA                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*           SourceB                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Alpha                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::K2_InterpolateMaterialInstanceParams(class UMaterialInstance* SourceA, class UMaterialInstance* SourceB, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "K2_InterpolateMaterialInstanceParams");

	Params::UMaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams_Params Parms{};

	Parms.SourceA = SourceA;
	Parms.SourceB = SourceB;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UMaterialInstanceDynamic::K2_GetVectorParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "K2_GetVectorParameterValue");

	Params::UMaterialInstanceDynamic_K2_GetVectorParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UMaterialInstanceDynamic::K2_GetTextureParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "K2_GetTextureParameterValue");

	Params::UMaterialInstanceDynamic_K2_GetTextureParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaterialInstanceDynamic::K2_GetScalarParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "K2_GetScalarParameterValue");

	Params::UMaterialInstanceDynamic_K2_GetScalarParameterValue_Params Parms{};

	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          Source                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bQuickParametersOnly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::K2_CopyMaterialInstanceParameters(class UMaterialInterface* Source, bool bQuickParametersOnly)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "K2_CopyMaterialInstanceParameters");

	Params::UMaterialInstanceDynamic_K2_CopyMaterialInstanceParameters_Params Parms{};

	Parms.Source = Source;
	Parms.bQuickParametersOnly = bQuickParametersOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MaterialInstanceDynamic.CopyParameterOverrides
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*           MaterialInstance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::CopyParameterOverrides(class UMaterialInstance* MaterialInstance)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "CopyParameterOverrides");

	Params::UMaterialInstanceDynamic_CopyParameterOverrides_Params Parms{};

	Parms.MaterialInstance = MaterialInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MaterialInstanceDynamic.CopyInterpParameters
// (Final, Native, Public)
// Parameters:
// class UMaterialInstance*           Source                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::CopyInterpParameters(class UMaterialInstance* Source)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MaterialInstanceDynamic", "CopyInterpParameters");

	Params::UMaterialInstanceDynamic_CopyInterpParameters_Params Parms{};

	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.MaterialParameterCollection
// (None)

class UClass* UMaterialParameterCollection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialParameterCollection");

	return Clss;
}


// MaterialParameterCollection Engine.Default__MaterialParameterCollection
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialParameterCollection* UMaterialParameterCollection::GetDefaultObj()
{
	static class UMaterialParameterCollection* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialParameterCollection*>(UMaterialParameterCollection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MaterialParameterCollectionInstance
// (None)

class UClass* UMaterialParameterCollectionInstance::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MaterialParameterCollectionInstance");

	return Clss;
}


// MaterialParameterCollectionInstance Engine.Default__MaterialParameterCollectionInstance
// (Public, ClassDefaultObject, ArchetypeObject)

class UMaterialParameterCollectionInstance* UMaterialParameterCollectionInstance::GetDefaultObj()
{
	static class UMaterialParameterCollectionInstance* Default = nullptr;

	if (!Default)
		Default = static_cast<UMaterialParameterCollectionInstance*>(UMaterialParameterCollectionInstance::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MatineeActor
// (Actor)

class UClass* AMatineeActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatineeActor");

	return Clss;
}


// MatineeActor Engine.Default__MatineeActor
// (Public, ClassDefaultObject, ArchetypeObject)

class AMatineeActor* AMatineeActor::GetDefaultObj()
{
	static class AMatineeActor* Default = nullptr;

	if (!Default)
		Default = static_cast<AMatineeActor*>(AMatineeActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.MatineeActor.Stop
// (Native, Public, BlueprintCallable)
// Parameters:

void AMatineeActor::Stop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatineeActor", "Stop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MatineeActor.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewPosition                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bJump                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatineeActor::SetPosition(float NewPosition, bool bJump)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatineeActor", "SetPosition");

	Params::AMatineeActor_SetPosition_Params Parms{};

	Parms.NewPosition = NewPosition;
	Parms.bJump = bJump;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MatineeActor.SetLoopingState
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewLooping                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatineeActor::SetLoopingState(bool bNewLooping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatineeActor", "SetLoopingState");

	Params::AMatineeActor_SetLoopingState_Params Parms{};

	Parms.bNewLooping = bNewLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MatineeActor.Reverse
// (Native, Public, BlueprintCallable)
// Parameters:

void AMatineeActor::Reverse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatineeActor", "Reverse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MatineeActor.Play
// (Native, Public, BlueprintCallable)
// Parameters:

void AMatineeActor::Play()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatineeActor", "Play");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MatineeActor.Pause
// (Native, Public, BlueprintCallable)
// Parameters:

void AMatineeActor::Pause()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatineeActor", "Pause");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MatineeActor.EnableGroupByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      GroupName                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatineeActor::EnableGroupByName(const class FString& GroupName, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatineeActor", "EnableGroupByName");

	Params::AMatineeActor_EnableGroupByName_Params Parms{};

	Parms.GroupName = GroupName;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MatineeActor.ChangePlaybackDirection
// (Native, Public, BlueprintCallable)
// Parameters:

void AMatineeActor::ChangePlaybackDirection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MatineeActor", "ChangePlaybackDirection");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.MatineeActorCameraAnim
// (Actor)

class UClass* AMatineeActorCameraAnim::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatineeActorCameraAnim");

	return Clss;
}


// MatineeActorCameraAnim Engine.Default__MatineeActorCameraAnim
// (Public, ClassDefaultObject, ArchetypeObject)

class AMatineeActorCameraAnim* AMatineeActorCameraAnim::GetDefaultObj()
{
	static class AMatineeActorCameraAnim* Default = nullptr;

	if (!Default)
		Default = static_cast<AMatineeActorCameraAnim*>(AMatineeActorCameraAnim::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MatineeAnimInterface
// (None)

class UClass* IMatineeAnimInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatineeAnimInterface");

	return Clss;
}


// MatineeAnimInterface Engine.Default__MatineeAnimInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IMatineeAnimInterface* IMatineeAnimInterface::GetDefaultObj()
{
	static class IMatineeAnimInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IMatineeAnimInterface*>(IMatineeAnimInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MatineeInterface
// (None)

class UClass* IMatineeInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MatineeInterface");

	return Clss;
}


// MatineeInterface Engine.Default__MatineeInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IMatineeInterface* IMatineeInterface::GetDefaultObj()
{
	static class IMatineeInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IMatineeInterface*>(IMatineeInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MeshMergeCullingVolume
// (Actor)

class UClass* AMeshMergeCullingVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MeshMergeCullingVolume");

	return Clss;
}


// MeshMergeCullingVolume Engine.Default__MeshMergeCullingVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AMeshMergeCullingVolume* AMeshMergeCullingVolume::GetDefaultObj()
{
	static class AMeshMergeCullingVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AMeshMergeCullingVolume*>(AMeshMergeCullingVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MeshSimplificationSettings
// (None)

class UClass* UMeshSimplificationSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MeshSimplificationSettings");

	return Clss;
}


// MeshSimplificationSettings Engine.Default__MeshSimplificationSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UMeshSimplificationSettings* UMeshSimplificationSettings::GetDefaultObj()
{
	static class UMeshSimplificationSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UMeshSimplificationSettings*>(UMeshSimplificationSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MeshVertexPainterKismetLibrary
// (None)

class UClass* UMeshVertexPainterKismetLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MeshVertexPainterKismetLibrary");

	return Clss;
}


// MeshVertexPainterKismetLibrary Engine.Default__MeshVertexPainterKismetLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UMeshVertexPainterKismetLibrary* UMeshVertexPainterKismetLibrary::GetDefaultObj()
{
	static class UMeshVertexPainterKismetLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UMeshVertexPainterKismetLibrary*>(UMeshVertexPainterKismetLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.MeshVertexPainterKismetLibrary.RemovePaintedVertices
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*        StaticMeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshVertexPainterKismetLibrary::RemovePaintedVertices(class UStaticMeshComponent* StaticMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshVertexPainterKismetLibrary", "RemovePaintedVertices");

	Params::UMeshVertexPainterKismetLibrary_RemovePaintedVertices_Params Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesSingleColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*        StaticMeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                FillColor                                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bConvertToSRGB                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshVertexPainterKismetLibrary::PaintVerticesSingleColor(class UStaticMeshComponent* StaticMeshComponent, struct FLinearColor& FillColor, bool bConvertToSRGB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshVertexPainterKismetLibrary", "PaintVerticesSingleColor");

	Params::UMeshVertexPainterKismetLibrary_PaintVerticesSingleColor_Params Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.FillColor = FillColor;
	Parms.bConvertToSRGB = bConvertToSRGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesLerpAlongAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*        StaticMeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                StartColor                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                EndColor                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EVertexPaintAxis        Axis                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bConvertToSRGB                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshVertexPainterKismetLibrary::PaintVerticesLerpAlongAxis(class UStaticMeshComponent* StaticMeshComponent, struct FLinearColor& StartColor, struct FLinearColor& EndColor, enum class EVertexPaintAxis Axis, bool bConvertToSRGB)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("MeshVertexPainterKismetLibrary", "PaintVerticesLerpAlongAxis");

	Params::UMeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis_Params Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.StartColor = StartColor;
	Parms.EndColor = EndColor;
	Parms.Axis = Axis;
	Parms.bConvertToSRGB = bConvertToSRGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.MicroTransactionBase
// (None)

class UClass* UMicroTransactionBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MicroTransactionBase");

	return Clss;
}


// MicroTransactionBase Engine.Default__MicroTransactionBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UMicroTransactionBase* UMicroTransactionBase::GetDefaultObj()
{
	static class UMicroTransactionBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UMicroTransactionBase*>(UMicroTransactionBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ModelComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UModelComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ModelComponent");

	return Clss;
}


// ModelComponent Engine.Default__ModelComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UModelComponent* UModelComponent::GetDefaultObj()
{
	static class UModelComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UModelComponent*>(UModelComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.MorphTarget
// (None)

class UClass* UMorphTarget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("MorphTarget");

	return Clss;
}


// MorphTarget Engine.Default__MorphTarget
// (Public, ClassDefaultObject, ArchetypeObject)

class UMorphTarget* UMorphTarget::GetDefaultObj()
{
	static class UMorphTarget* Default = nullptr;

	if (!Default)
		Default = static_cast<UMorphTarget*>(UMorphTarget::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavAgentInterface
// (None)

class UClass* INavAgentInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavAgentInterface");

	return Clss;
}


// NavAgentInterface Engine.Default__NavAgentInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class INavAgentInterface* INavAgentInterface::GetDefaultObj()
{
	static class INavAgentInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<INavAgentInterface*>(INavAgentInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavCollisionBase
// (None)

class UClass* UNavCollisionBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavCollisionBase");

	return Clss;
}


// NavCollisionBase Engine.Default__NavCollisionBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UNavCollisionBase* UNavCollisionBase::GetDefaultObj()
{
	static class UNavCollisionBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UNavCollisionBase*>(UNavCollisionBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavEdgeProviderInterface
// (None)

class UClass* INavEdgeProviderInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavEdgeProviderInterface");

	return Clss;
}


// NavEdgeProviderInterface Engine.Default__NavEdgeProviderInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class INavEdgeProviderInterface* INavEdgeProviderInterface::GetDefaultObj()
{
	static class INavEdgeProviderInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<INavEdgeProviderInterface*>(INavEdgeProviderInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavigationDataChunk
// (None)

class UClass* UNavigationDataChunk::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavigationDataChunk");

	return Clss;
}


// NavigationDataChunk Engine.Default__NavigationDataChunk
// (Public, ClassDefaultObject, ArchetypeObject)

class UNavigationDataChunk* UNavigationDataChunk::GetDefaultObj()
{
	static class UNavigationDataChunk* Default = nullptr;

	if (!Default)
		Default = static_cast<UNavigationDataChunk*>(UNavigationDataChunk::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavigationDataInterface
// (None)

class UClass* INavigationDataInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavigationDataInterface");

	return Clss;
}


// NavigationDataInterface Engine.Default__NavigationDataInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class INavigationDataInterface* INavigationDataInterface::GetDefaultObj()
{
	static class INavigationDataInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<INavigationDataInterface*>(INavigationDataInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NullNavSysConfig
// (None)

class UClass* UNullNavSysConfig::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NullNavSysConfig");

	return Clss;
}


// NullNavSysConfig Engine.Default__NullNavSysConfig
// (Public, ClassDefaultObject, ArchetypeObject)

class UNullNavSysConfig* UNullNavSysConfig::GetDefaultObj()
{
	static class UNullNavSysConfig* Default = nullptr;

	if (!Default)
		Default = static_cast<UNullNavSysConfig*>(UNullNavSysConfig::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavPathObserverInterface
// (None)

class UClass* INavPathObserverInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavPathObserverInterface");

	return Clss;
}


// NavPathObserverInterface Engine.Default__NavPathObserverInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class INavPathObserverInterface* INavPathObserverInterface::GetDefaultObj()
{
	static class INavPathObserverInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<INavPathObserverInterface*>(INavPathObserverInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NavRelevantInterface
// (None)

class UClass* INavRelevantInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NavRelevantInterface");

	return Clss;
}


// NavRelevantInterface Engine.Default__NavRelevantInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class INavRelevantInterface* INavRelevantInterface::GetDefaultObj()
{
	static class INavRelevantInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<INavRelevantInterface*>(INavRelevantInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SimulatedClientNetConnection
// (None)

class UClass* USimulatedClientNetConnection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SimulatedClientNetConnection");

	return Clss;
}


// SimulatedClientNetConnection Engine.Default__SimulatedClientNetConnection
// (Public, ClassDefaultObject, ArchetypeObject)

class USimulatedClientNetConnection* USimulatedClientNetConnection::GetDefaultObj()
{
	static class USimulatedClientNetConnection* Default = nullptr;

	if (!Default)
		Default = static_cast<USimulatedClientNetConnection*>(USimulatedClientNetConnection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NetworkPredictionInterface
// (None)

class UClass* INetworkPredictionInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NetworkPredictionInterface");

	return Clss;
}


// NetworkPredictionInterface Engine.Default__NetworkPredictionInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class INetworkPredictionInterface* INetworkPredictionInterface::GetDefaultObj()
{
	static class INetworkPredictionInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<INetworkPredictionInterface*>(INetworkPredictionInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NetworkSettings
// (None)

class UClass* UNetworkSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NetworkSettings");

	return Clss;
}


// NetworkSettings Engine.Default__NetworkSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UNetworkSettings* UNetworkSettings::GetDefaultObj()
{
	static class UNetworkSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UNetworkSettings*>(UNetworkSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NodeMappingContainer
// (None)

class UClass* UNodeMappingContainer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NodeMappingContainer");

	return Clss;
}


// NodeMappingContainer Engine.Default__NodeMappingContainer
// (Public, ClassDefaultObject, ArchetypeObject)

class UNodeMappingContainer* UNodeMappingContainer::GetDefaultObj()
{
	static class UNodeMappingContainer* Default = nullptr;

	if (!Default)
		Default = static_cast<UNodeMappingContainer*>(UNodeMappingContainer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.NodeMappingProviderInterface
// (None)

class UClass* INodeMappingProviderInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("NodeMappingProviderInterface");

	return Clss;
}


// NodeMappingProviderInterface Engine.Default__NodeMappingProviderInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class INodeMappingProviderInterface* INodeMappingProviderInterface::GetDefaultObj()
{
	static class INodeMappingProviderInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<INodeMappingProviderInterface*>(INodeMappingProviderInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Note
// (Actor)

class UClass* ANote::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Note");

	return Clss;
}


// Note Engine.Default__Note
// (Public, ClassDefaultObject, ArchetypeObject)

class ANote* ANote::GetDefaultObj()
{
	static class ANote* Default = nullptr;

	if (!Default)
		Default = static_cast<ANote*>(ANote::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ObjectLibrary
// (None)

class UClass* UObjectLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ObjectLibrary");

	return Clss;
}


// ObjectLibrary Engine.Default__ObjectLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UObjectLibrary* UObjectLibrary::GetDefaultObj()
{
	static class UObjectLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UObjectLibrary*>(UObjectLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ObjectReferencer
// (None)

class UClass* UObjectReferencer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ObjectReferencer");

	return Clss;
}


// ObjectReferencer Engine.Default__ObjectReferencer
// (Public, ClassDefaultObject, ArchetypeObject)

class UObjectReferencer* UObjectReferencer::GetDefaultObj()
{
	static class UObjectReferencer* Default = nullptr;

	if (!Default)
		Default = static_cast<UObjectReferencer*>(UObjectReferencer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PackageMapClient
// (None)

class UClass* UPackageMapClient::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PackageMapClient");

	return Clss;
}


// PackageMapClient Engine.Default__PackageMapClient
// (Public, ClassDefaultObject, ArchetypeObject)

class UPackageMapClient* UPackageMapClient::GetDefaultObj()
{
	static class UPackageMapClient* Default = nullptr;

	if (!Default)
		Default = static_cast<UPackageMapClient*>(UPackageMapClient::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PainCausingVolume
// (Actor)

class UClass* APainCausingVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PainCausingVolume");

	return Clss;
}


// PainCausingVolume Engine.Default__PainCausingVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class APainCausingVolume* APainCausingVolume::GetDefaultObj()
{
	static class APainCausingVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<APainCausingVolume*>(APainCausingVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleEmitter
// (None)

class UClass* UParticleEmitter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleEmitter");

	return Clss;
}


// ParticleEmitter Engine.Default__ParticleEmitter
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleEmitter* UParticleEmitter::GetDefaultObj()
{
	static class UParticleEmitter* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleEmitter*>(UParticleEmitter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleEventManager
// (Actor)

class UClass* AParticleEventManager::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleEventManager");

	return Clss;
}


// ParticleEventManager Engine.Default__ParticleEventManager
// (Public, ClassDefaultObject, ArchetypeObject)

class AParticleEventManager* AParticleEventManager::GetDefaultObj()
{
	static class AParticleEventManager* Default = nullptr;

	if (!Default)
		Default = static_cast<AParticleEventManager*>(AParticleEventManager::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleLODLevel
// (None)

class UClass* UParticleLODLevel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleLODLevel");

	return Clss;
}


// ParticleLODLevel Engine.Default__ParticleLODLevel
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleLODLevel* UParticleLODLevel::GetDefaultObj()
{
	static class UParticleLODLevel* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleLODLevel*>(UParticleLODLevel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAccelerationBase
// (None)

class UClass* UParticleModuleAccelerationBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAccelerationBase");

	return Clss;
}


// ParticleModuleAccelerationBase Engine.Default__ParticleModuleAccelerationBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAccelerationBase* UParticleModuleAccelerationBase::GetDefaultObj()
{
	static class UParticleModuleAccelerationBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAccelerationBase*>(UParticleModuleAccelerationBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAcceleration
// (None)

class UClass* UParticleModuleAcceleration::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAcceleration");

	return Clss;
}


// ParticleModuleAcceleration Engine.Default__ParticleModuleAcceleration
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAcceleration* UParticleModuleAcceleration::GetDefaultObj()
{
	static class UParticleModuleAcceleration* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAcceleration*>(UParticleModuleAcceleration::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAccelerationConstant
// (None)

class UClass* UParticleModuleAccelerationConstant::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAccelerationConstant");

	return Clss;
}


// ParticleModuleAccelerationConstant Engine.Default__ParticleModuleAccelerationConstant
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAccelerationConstant* UParticleModuleAccelerationConstant::GetDefaultObj()
{
	static class UParticleModuleAccelerationConstant* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAccelerationConstant*>(UParticleModuleAccelerationConstant::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAccelerationDrag
// (None)

class UClass* UParticleModuleAccelerationDrag::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAccelerationDrag");

	return Clss;
}


// ParticleModuleAccelerationDrag Engine.Default__ParticleModuleAccelerationDrag
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAccelerationDrag* UParticleModuleAccelerationDrag::GetDefaultObj()
{
	static class UParticleModuleAccelerationDrag* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAccelerationDrag*>(UParticleModuleAccelerationDrag::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAccelerationDragScaleOverLife
// (None)

class UClass* UParticleModuleAccelerationDragScaleOverLife::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAccelerationDragScaleOverLife");

	return Clss;
}


// ParticleModuleAccelerationDragScaleOverLife Engine.Default__ParticleModuleAccelerationDragScaleOverLife
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAccelerationDragScaleOverLife* UParticleModuleAccelerationDragScaleOverLife::GetDefaultObj()
{
	static class UParticleModuleAccelerationDragScaleOverLife* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAccelerationDragScaleOverLife*>(UParticleModuleAccelerationDragScaleOverLife::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAccelerationOverLifetime
// (None)

class UClass* UParticleModuleAccelerationOverLifetime::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAccelerationOverLifetime");

	return Clss;
}


// ParticleModuleAccelerationOverLifetime Engine.Default__ParticleModuleAccelerationOverLifetime
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAccelerationOverLifetime* UParticleModuleAccelerationOverLifetime::GetDefaultObj()
{
	static class UParticleModuleAccelerationOverLifetime* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAccelerationOverLifetime*>(UParticleModuleAccelerationOverLifetime::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAttractorBase
// (None)

class UClass* UParticleModuleAttractorBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAttractorBase");

	return Clss;
}


// ParticleModuleAttractorBase Engine.Default__ParticleModuleAttractorBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAttractorBase* UParticleModuleAttractorBase::GetDefaultObj()
{
	static class UParticleModuleAttractorBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAttractorBase*>(UParticleModuleAttractorBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAttractorLine
// (None)

class UClass* UParticleModuleAttractorLine::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAttractorLine");

	return Clss;
}


// ParticleModuleAttractorLine Engine.Default__ParticleModuleAttractorLine
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAttractorLine* UParticleModuleAttractorLine::GetDefaultObj()
{
	static class UParticleModuleAttractorLine* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAttractorLine*>(UParticleModuleAttractorLine::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAttractorParticle
// (None)

class UClass* UParticleModuleAttractorParticle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAttractorParticle");

	return Clss;
}


// ParticleModuleAttractorParticle Engine.Default__ParticleModuleAttractorParticle
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAttractorParticle* UParticleModuleAttractorParticle::GetDefaultObj()
{
	static class UParticleModuleAttractorParticle* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAttractorParticle*>(UParticleModuleAttractorParticle::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAttractorPoint
// (None)

class UClass* UParticleModuleAttractorPoint::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAttractorPoint");

	return Clss;
}


// ParticleModuleAttractorPoint Engine.Default__ParticleModuleAttractorPoint
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAttractorPoint* UParticleModuleAttractorPoint::GetDefaultObj()
{
	static class UParticleModuleAttractorPoint* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAttractorPoint*>(UParticleModuleAttractorPoint::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleAttractorPointGravity
// (None)

class UClass* UParticleModuleAttractorPointGravity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleAttractorPointGravity");

	return Clss;
}


// ParticleModuleAttractorPointGravity Engine.Default__ParticleModuleAttractorPointGravity
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleAttractorPointGravity* UParticleModuleAttractorPointGravity::GetDefaultObj()
{
	static class UParticleModuleAttractorPointGravity* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleAttractorPointGravity*>(UParticleModuleAttractorPointGravity::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleBeamBase
// (None)

class UClass* UParticleModuleBeamBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleBeamBase");

	return Clss;
}


// ParticleModuleBeamBase Engine.Default__ParticleModuleBeamBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleBeamBase* UParticleModuleBeamBase::GetDefaultObj()
{
	static class UParticleModuleBeamBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleBeamBase*>(UParticleModuleBeamBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleBeamModifier
// (None)

class UClass* UParticleModuleBeamModifier::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleBeamModifier");

	return Clss;
}


// ParticleModuleBeamModifier Engine.Default__ParticleModuleBeamModifier
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleBeamModifier* UParticleModuleBeamModifier::GetDefaultObj()
{
	static class UParticleModuleBeamModifier* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleBeamModifier*>(UParticleModuleBeamModifier::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleBeamNoise
// (None)

class UClass* UParticleModuleBeamNoise::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleBeamNoise");

	return Clss;
}


// ParticleModuleBeamNoise Engine.Default__ParticleModuleBeamNoise
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleBeamNoise* UParticleModuleBeamNoise::GetDefaultObj()
{
	static class UParticleModuleBeamNoise* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleBeamNoise*>(UParticleModuleBeamNoise::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleBeamSource
// (None)

class UClass* UParticleModuleBeamSource::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleBeamSource");

	return Clss;
}


// ParticleModuleBeamSource Engine.Default__ParticleModuleBeamSource
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleBeamSource* UParticleModuleBeamSource::GetDefaultObj()
{
	static class UParticleModuleBeamSource* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleBeamSource*>(UParticleModuleBeamSource::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleBeamTarget
// (None)

class UClass* UParticleModuleBeamTarget::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleBeamTarget");

	return Clss;
}


// ParticleModuleBeamTarget Engine.Default__ParticleModuleBeamTarget
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleBeamTarget* UParticleModuleBeamTarget::GetDefaultObj()
{
	static class UParticleModuleBeamTarget* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleBeamTarget*>(UParticleModuleBeamTarget::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleCameraBase
// (None)

class UClass* UParticleModuleCameraBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleCameraBase");

	return Clss;
}


// ParticleModuleCameraBase Engine.Default__ParticleModuleCameraBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleCameraBase* UParticleModuleCameraBase::GetDefaultObj()
{
	static class UParticleModuleCameraBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleCameraBase*>(UParticleModuleCameraBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleCameraOffset
// (None)

class UClass* UParticleModuleCameraOffset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleCameraOffset");

	return Clss;
}


// ParticleModuleCameraOffset Engine.Default__ParticleModuleCameraOffset
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleCameraOffset* UParticleModuleCameraOffset::GetDefaultObj()
{
	static class UParticleModuleCameraOffset* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleCameraOffset*>(UParticleModuleCameraOffset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleCollisionBase
// (None)

class UClass* UParticleModuleCollisionBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleCollisionBase");

	return Clss;
}


// ParticleModuleCollisionBase Engine.Default__ParticleModuleCollisionBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleCollisionBase* UParticleModuleCollisionBase::GetDefaultObj()
{
	static class UParticleModuleCollisionBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleCollisionBase*>(UParticleModuleCollisionBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleCollision
// (None)

class UClass* UParticleModuleCollision::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleCollision");

	return Clss;
}


// ParticleModuleCollision Engine.Default__ParticleModuleCollision
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleCollision* UParticleModuleCollision::GetDefaultObj()
{
	static class UParticleModuleCollision* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleCollision*>(UParticleModuleCollision::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleCollisionGPU
// (None)

class UClass* UParticleModuleCollisionGPU::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleCollisionGPU");

	return Clss;
}


// ParticleModuleCollisionGPU Engine.Default__ParticleModuleCollisionGPU
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleCollisionGPU* UParticleModuleCollisionGPU::GetDefaultObj()
{
	static class UParticleModuleCollisionGPU* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleCollisionGPU*>(UParticleModuleCollisionGPU::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleColorBase
// (None)

class UClass* UParticleModuleColorBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleColorBase");

	return Clss;
}


// ParticleModuleColorBase Engine.Default__ParticleModuleColorBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleColorBase* UParticleModuleColorBase::GetDefaultObj()
{
	static class UParticleModuleColorBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleColorBase*>(UParticleModuleColorBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleColor
// (None)

class UClass* UParticleModuleColor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleColor");

	return Clss;
}


// ParticleModuleColor Engine.Default__ParticleModuleColor
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleColor* UParticleModuleColor::GetDefaultObj()
{
	static class UParticleModuleColor* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleColor*>(UParticleModuleColor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleColor_Seeded
// (None)

class UClass* UParticleModuleColor_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleColor_Seeded");

	return Clss;
}


// ParticleModuleColor_Seeded Engine.Default__ParticleModuleColor_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleColor_Seeded* UParticleModuleColor_Seeded::GetDefaultObj()
{
	static class UParticleModuleColor_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleColor_Seeded*>(UParticleModuleColor_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleColorOverLife
// (None)

class UClass* UParticleModuleColorOverLife::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleColorOverLife");

	return Clss;
}


// ParticleModuleColorOverLife Engine.Default__ParticleModuleColorOverLife
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleColorOverLife* UParticleModuleColorOverLife::GetDefaultObj()
{
	static class UParticleModuleColorOverLife* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleColorOverLife*>(UParticleModuleColorOverLife::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleColorScaleOverLife
// (None)

class UClass* UParticleModuleColorScaleOverLife::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleColorScaleOverLife");

	return Clss;
}


// ParticleModuleColorScaleOverLife Engine.Default__ParticleModuleColorScaleOverLife
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleColorScaleOverLife* UParticleModuleColorScaleOverLife::GetDefaultObj()
{
	static class UParticleModuleColorScaleOverLife* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleColorScaleOverLife*>(UParticleModuleColorScaleOverLife::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleEventBase
// (None)

class UClass* UParticleModuleEventBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleEventBase");

	return Clss;
}


// ParticleModuleEventBase Engine.Default__ParticleModuleEventBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleEventBase* UParticleModuleEventBase::GetDefaultObj()
{
	static class UParticleModuleEventBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleEventBase*>(UParticleModuleEventBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleEventGenerator
// (None)

class UClass* UParticleModuleEventGenerator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleEventGenerator");

	return Clss;
}


// ParticleModuleEventGenerator Engine.Default__ParticleModuleEventGenerator
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleEventGenerator* UParticleModuleEventGenerator::GetDefaultObj()
{
	static class UParticleModuleEventGenerator* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleEventGenerator*>(UParticleModuleEventGenerator::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleEventReceiverBase
// (None)

class UClass* UParticleModuleEventReceiverBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleEventReceiverBase");

	return Clss;
}


// ParticleModuleEventReceiverBase Engine.Default__ParticleModuleEventReceiverBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleEventReceiverBase* UParticleModuleEventReceiverBase::GetDefaultObj()
{
	static class UParticleModuleEventReceiverBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleEventReceiverBase*>(UParticleModuleEventReceiverBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleEventReceiverKillParticles
// (None)

class UClass* UParticleModuleEventReceiverKillParticles::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleEventReceiverKillParticles");

	return Clss;
}


// ParticleModuleEventReceiverKillParticles Engine.Default__ParticleModuleEventReceiverKillParticles
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleEventReceiverKillParticles* UParticleModuleEventReceiverKillParticles::GetDefaultObj()
{
	static class UParticleModuleEventReceiverKillParticles* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleEventReceiverKillParticles*>(UParticleModuleEventReceiverKillParticles::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleEventReceiverSpawn
// (None)

class UClass* UParticleModuleEventReceiverSpawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleEventReceiverSpawn");

	return Clss;
}


// ParticleModuleEventReceiverSpawn Engine.Default__ParticleModuleEventReceiverSpawn
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleEventReceiverSpawn* UParticleModuleEventReceiverSpawn::GetDefaultObj()
{
	static class UParticleModuleEventReceiverSpawn* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleEventReceiverSpawn*>(UParticleModuleEventReceiverSpawn::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleEventSendToGame
// (None)

class UClass* UParticleModuleEventSendToGame::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleEventSendToGame");

	return Clss;
}


// ParticleModuleEventSendToGame Engine.Default__ParticleModuleEventSendToGame
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleEventSendToGame* UParticleModuleEventSendToGame::GetDefaultObj()
{
	static class UParticleModuleEventSendToGame* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleEventSendToGame*>(UParticleModuleEventSendToGame::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleKillBase
// (None)

class UClass* UParticleModuleKillBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleKillBase");

	return Clss;
}


// ParticleModuleKillBase Engine.Default__ParticleModuleKillBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleKillBase* UParticleModuleKillBase::GetDefaultObj()
{
	static class UParticleModuleKillBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleKillBase*>(UParticleModuleKillBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleKillBox
// (None)

class UClass* UParticleModuleKillBox::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleKillBox");

	return Clss;
}


// ParticleModuleKillBox Engine.Default__ParticleModuleKillBox
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleKillBox* UParticleModuleKillBox::GetDefaultObj()
{
	static class UParticleModuleKillBox* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleKillBox*>(UParticleModuleKillBox::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleKillHeight
// (None)

class UClass* UParticleModuleKillHeight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleKillHeight");

	return Clss;
}


// ParticleModuleKillHeight Engine.Default__ParticleModuleKillHeight
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleKillHeight* UParticleModuleKillHeight::GetDefaultObj()
{
	static class UParticleModuleKillHeight* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleKillHeight*>(UParticleModuleKillHeight::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLifetimeBase
// (None)

class UClass* UParticleModuleLifetimeBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLifetimeBase");

	return Clss;
}


// ParticleModuleLifetimeBase Engine.Default__ParticleModuleLifetimeBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLifetimeBase* UParticleModuleLifetimeBase::GetDefaultObj()
{
	static class UParticleModuleLifetimeBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLifetimeBase*>(UParticleModuleLifetimeBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLifetime
// (None)

class UClass* UParticleModuleLifetime::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLifetime");

	return Clss;
}


// ParticleModuleLifetime Engine.Default__ParticleModuleLifetime
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLifetime* UParticleModuleLifetime::GetDefaultObj()
{
	static class UParticleModuleLifetime* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLifetime*>(UParticleModuleLifetime::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLifetime_Seeded
// (None)

class UClass* UParticleModuleLifetime_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLifetime_Seeded");

	return Clss;
}


// ParticleModuleLifetime_Seeded Engine.Default__ParticleModuleLifetime_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLifetime_Seeded* UParticleModuleLifetime_Seeded::GetDefaultObj()
{
	static class UParticleModuleLifetime_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLifetime_Seeded*>(UParticleModuleLifetime_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLightBase
// (None)

class UClass* UParticleModuleLightBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLightBase");

	return Clss;
}


// ParticleModuleLightBase Engine.Default__ParticleModuleLightBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLightBase* UParticleModuleLightBase::GetDefaultObj()
{
	static class UParticleModuleLightBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLightBase*>(UParticleModuleLightBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLight
// (None)

class UClass* UParticleModuleLight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLight");

	return Clss;
}


// ParticleModuleLight Engine.Default__ParticleModuleLight
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLight* UParticleModuleLight::GetDefaultObj()
{
	static class UParticleModuleLight* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLight*>(UParticleModuleLight::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLight_Seeded
// (None)

class UClass* UParticleModuleLight_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLight_Seeded");

	return Clss;
}


// ParticleModuleLight_Seeded Engine.Default__ParticleModuleLight_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLight_Seeded* UParticleModuleLight_Seeded::GetDefaultObj()
{
	static class UParticleModuleLight_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLight_Seeded*>(UParticleModuleLight_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationBase
// (None)

class UClass* UParticleModuleLocationBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationBase");

	return Clss;
}


// ParticleModuleLocationBase Engine.Default__ParticleModuleLocationBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationBase* UParticleModuleLocationBase::GetDefaultObj()
{
	static class UParticleModuleLocationBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationBase*>(UParticleModuleLocationBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocation
// (None)

class UClass* UParticleModuleLocation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocation");

	return Clss;
}


// ParticleModuleLocation Engine.Default__ParticleModuleLocation
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocation* UParticleModuleLocation::GetDefaultObj()
{
	static class UParticleModuleLocation* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocation*>(UParticleModuleLocation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocation_Seeded
// (None)

class UClass* UParticleModuleLocation_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocation_Seeded");

	return Clss;
}


// ParticleModuleLocation_Seeded Engine.Default__ParticleModuleLocation_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocation_Seeded* UParticleModuleLocation_Seeded::GetDefaultObj()
{
	static class UParticleModuleLocation_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocation_Seeded*>(UParticleModuleLocation_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationBoneSocket
// (None)

class UClass* UParticleModuleLocationBoneSocket::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationBoneSocket");

	return Clss;
}


// ParticleModuleLocationBoneSocket Engine.Default__ParticleModuleLocationBoneSocket
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationBoneSocket* UParticleModuleLocationBoneSocket::GetDefaultObj()
{
	static class UParticleModuleLocationBoneSocket* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationBoneSocket*>(UParticleModuleLocationBoneSocket::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationDirect
// (None)

class UClass* UParticleModuleLocationDirect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationDirect");

	return Clss;
}


// ParticleModuleLocationDirect Engine.Default__ParticleModuleLocationDirect
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationDirect* UParticleModuleLocationDirect::GetDefaultObj()
{
	static class UParticleModuleLocationDirect* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationDirect*>(UParticleModuleLocationDirect::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationEmitter
// (None)

class UClass* UParticleModuleLocationEmitter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationEmitter");

	return Clss;
}


// ParticleModuleLocationEmitter Engine.Default__ParticleModuleLocationEmitter
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationEmitter* UParticleModuleLocationEmitter::GetDefaultObj()
{
	static class UParticleModuleLocationEmitter* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationEmitter*>(UParticleModuleLocationEmitter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationEmitterDirect
// (None)

class UClass* UParticleModuleLocationEmitterDirect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationEmitterDirect");

	return Clss;
}


// ParticleModuleLocationEmitterDirect Engine.Default__ParticleModuleLocationEmitterDirect
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationEmitterDirect* UParticleModuleLocationEmitterDirect::GetDefaultObj()
{
	static class UParticleModuleLocationEmitterDirect* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationEmitterDirect*>(UParticleModuleLocationEmitterDirect::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationPrimitiveBase
// (None)

class UClass* UParticleModuleLocationPrimitiveBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationPrimitiveBase");

	return Clss;
}


// ParticleModuleLocationPrimitiveBase Engine.Default__ParticleModuleLocationPrimitiveBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationPrimitiveBase* UParticleModuleLocationPrimitiveBase::GetDefaultObj()
{
	static class UParticleModuleLocationPrimitiveBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationPrimitiveBase*>(UParticleModuleLocationPrimitiveBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationPrimitiveCylinder
// (None)

class UClass* UParticleModuleLocationPrimitiveCylinder::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationPrimitiveCylinder");

	return Clss;
}


// ParticleModuleLocationPrimitiveCylinder Engine.Default__ParticleModuleLocationPrimitiveCylinder
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationPrimitiveCylinder* UParticleModuleLocationPrimitiveCylinder::GetDefaultObj()
{
	static class UParticleModuleLocationPrimitiveCylinder* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationPrimitiveCylinder*>(UParticleModuleLocationPrimitiveCylinder::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationPrimitiveCylinder_Seeded
// (None)

class UClass* UParticleModuleLocationPrimitiveCylinder_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationPrimitiveCylinder_Seeded");

	return Clss;
}


// ParticleModuleLocationPrimitiveCylinder_Seeded Engine.Default__ParticleModuleLocationPrimitiveCylinder_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationPrimitiveCylinder_Seeded* UParticleModuleLocationPrimitiveCylinder_Seeded::GetDefaultObj()
{
	static class UParticleModuleLocationPrimitiveCylinder_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationPrimitiveCylinder_Seeded*>(UParticleModuleLocationPrimitiveCylinder_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationPrimitiveSphere
// (None)

class UClass* UParticleModuleLocationPrimitiveSphere::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationPrimitiveSphere");

	return Clss;
}


// ParticleModuleLocationPrimitiveSphere Engine.Default__ParticleModuleLocationPrimitiveSphere
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationPrimitiveSphere* UParticleModuleLocationPrimitiveSphere::GetDefaultObj()
{
	static class UParticleModuleLocationPrimitiveSphere* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationPrimitiveSphere*>(UParticleModuleLocationPrimitiveSphere::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationPrimitiveSphere_Seeded
// (None)

class UClass* UParticleModuleLocationPrimitiveSphere_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationPrimitiveSphere_Seeded");

	return Clss;
}


// ParticleModuleLocationPrimitiveSphere_Seeded Engine.Default__ParticleModuleLocationPrimitiveSphere_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationPrimitiveSphere_Seeded* UParticleModuleLocationPrimitiveSphere_Seeded::GetDefaultObj()
{
	static class UParticleModuleLocationPrimitiveSphere_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationPrimitiveSphere_Seeded*>(UParticleModuleLocationPrimitiveSphere_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationPrimitiveTriangle
// (None)

class UClass* UParticleModuleLocationPrimitiveTriangle::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationPrimitiveTriangle");

	return Clss;
}


// ParticleModuleLocationPrimitiveTriangle Engine.Default__ParticleModuleLocationPrimitiveTriangle
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationPrimitiveTriangle* UParticleModuleLocationPrimitiveTriangle::GetDefaultObj()
{
	static class UParticleModuleLocationPrimitiveTriangle* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationPrimitiveTriangle*>(UParticleModuleLocationPrimitiveTriangle::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationSkelVertSurface
// (None)

class UClass* UParticleModuleLocationSkelVertSurface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationSkelVertSurface");

	return Clss;
}


// ParticleModuleLocationSkelVertSurface Engine.Default__ParticleModuleLocationSkelVertSurface
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationSkelVertSurface* UParticleModuleLocationSkelVertSurface::GetDefaultObj()
{
	static class UParticleModuleLocationSkelVertSurface* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationSkelVertSurface*>(UParticleModuleLocationSkelVertSurface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationWorldOffset
// (None)

class UClass* UParticleModuleLocationWorldOffset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationWorldOffset");

	return Clss;
}


// ParticleModuleLocationWorldOffset Engine.Default__ParticleModuleLocationWorldOffset
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationWorldOffset* UParticleModuleLocationWorldOffset::GetDefaultObj()
{
	static class UParticleModuleLocationWorldOffset* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationWorldOffset*>(UParticleModuleLocationWorldOffset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleLocationWorldOffset_Seeded
// (None)

class UClass* UParticleModuleLocationWorldOffset_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleLocationWorldOffset_Seeded");

	return Clss;
}


// ParticleModuleLocationWorldOffset_Seeded Engine.Default__ParticleModuleLocationWorldOffset_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleLocationWorldOffset_Seeded* UParticleModuleLocationWorldOffset_Seeded::GetDefaultObj()
{
	static class UParticleModuleLocationWorldOffset_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleLocationWorldOffset_Seeded*>(UParticleModuleLocationWorldOffset_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleMaterialBase
// (None)

class UClass* UParticleModuleMaterialBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleMaterialBase");

	return Clss;
}


// ParticleModuleMaterialBase Engine.Default__ParticleModuleMaterialBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleMaterialBase* UParticleModuleMaterialBase::GetDefaultObj()
{
	static class UParticleModuleMaterialBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleMaterialBase*>(UParticleModuleMaterialBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleMeshMaterial
// (None)

class UClass* UParticleModuleMeshMaterial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleMeshMaterial");

	return Clss;
}


// ParticleModuleMeshMaterial Engine.Default__ParticleModuleMeshMaterial
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleMeshMaterial* UParticleModuleMeshMaterial::GetDefaultObj()
{
	static class UParticleModuleMeshMaterial* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleMeshMaterial*>(UParticleModuleMeshMaterial::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRotationBase
// (None)

class UClass* UParticleModuleRotationBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRotationBase");

	return Clss;
}


// ParticleModuleRotationBase Engine.Default__ParticleModuleRotationBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRotationBase* UParticleModuleRotationBase::GetDefaultObj()
{
	static class UParticleModuleRotationBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRotationBase*>(UParticleModuleRotationBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleMeshRotation
// (None)

class UClass* UParticleModuleMeshRotation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleMeshRotation");

	return Clss;
}


// ParticleModuleMeshRotation Engine.Default__ParticleModuleMeshRotation
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleMeshRotation* UParticleModuleMeshRotation::GetDefaultObj()
{
	static class UParticleModuleMeshRotation* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleMeshRotation*>(UParticleModuleMeshRotation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleMeshRotation_Seeded
// (None)

class UClass* UParticleModuleMeshRotation_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleMeshRotation_Seeded");

	return Clss;
}


// ParticleModuleMeshRotation_Seeded Engine.Default__ParticleModuleMeshRotation_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleMeshRotation_Seeded* UParticleModuleMeshRotation_Seeded::GetDefaultObj()
{
	static class UParticleModuleMeshRotation_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleMeshRotation_Seeded*>(UParticleModuleMeshRotation_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRotationRateBase
// (None)

class UClass* UParticleModuleRotationRateBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRotationRateBase");

	return Clss;
}


// ParticleModuleRotationRateBase Engine.Default__ParticleModuleRotationRateBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRotationRateBase* UParticleModuleRotationRateBase::GetDefaultObj()
{
	static class UParticleModuleRotationRateBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRotationRateBase*>(UParticleModuleRotationRateBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleMeshRotationRate
// (None)

class UClass* UParticleModuleMeshRotationRate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleMeshRotationRate");

	return Clss;
}


// ParticleModuleMeshRotationRate Engine.Default__ParticleModuleMeshRotationRate
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleMeshRotationRate* UParticleModuleMeshRotationRate::GetDefaultObj()
{
	static class UParticleModuleMeshRotationRate* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleMeshRotationRate*>(UParticleModuleMeshRotationRate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleMeshRotationRate_Seeded
// (None)

class UClass* UParticleModuleMeshRotationRate_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleMeshRotationRate_Seeded");

	return Clss;
}


// ParticleModuleMeshRotationRate_Seeded Engine.Default__ParticleModuleMeshRotationRate_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleMeshRotationRate_Seeded* UParticleModuleMeshRotationRate_Seeded::GetDefaultObj()
{
	static class UParticleModuleMeshRotationRate_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleMeshRotationRate_Seeded*>(UParticleModuleMeshRotationRate_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleMeshRotationRateMultiplyLife
// (None)

class UClass* UParticleModuleMeshRotationRateMultiplyLife::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleMeshRotationRateMultiplyLife");

	return Clss;
}


// ParticleModuleMeshRotationRateMultiplyLife Engine.Default__ParticleModuleMeshRotationRateMultiplyLife
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleMeshRotationRateMultiplyLife* UParticleModuleMeshRotationRateMultiplyLife::GetDefaultObj()
{
	static class UParticleModuleMeshRotationRateMultiplyLife* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleMeshRotationRateMultiplyLife*>(UParticleModuleMeshRotationRateMultiplyLife::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleMeshRotationRateOverLife
// (None)

class UClass* UParticleModuleMeshRotationRateOverLife::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleMeshRotationRateOverLife");

	return Clss;
}


// ParticleModuleMeshRotationRateOverLife Engine.Default__ParticleModuleMeshRotationRateOverLife
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleMeshRotationRateOverLife* UParticleModuleMeshRotationRateOverLife::GetDefaultObj()
{
	static class UParticleModuleMeshRotationRateOverLife* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleMeshRotationRateOverLife*>(UParticleModuleMeshRotationRateOverLife::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleOrbitBase
// (None)

class UClass* UParticleModuleOrbitBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleOrbitBase");

	return Clss;
}


// ParticleModuleOrbitBase Engine.Default__ParticleModuleOrbitBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleOrbitBase* UParticleModuleOrbitBase::GetDefaultObj()
{
	static class UParticleModuleOrbitBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleOrbitBase*>(UParticleModuleOrbitBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleOrbit
// (None)

class UClass* UParticleModuleOrbit::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleOrbit");

	return Clss;
}


// ParticleModuleOrbit Engine.Default__ParticleModuleOrbit
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleOrbit* UParticleModuleOrbit::GetDefaultObj()
{
	static class UParticleModuleOrbit* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleOrbit*>(UParticleModuleOrbit::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleOrientationBase
// (None)

class UClass* UParticleModuleOrientationBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleOrientationBase");

	return Clss;
}


// ParticleModuleOrientationBase Engine.Default__ParticleModuleOrientationBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleOrientationBase* UParticleModuleOrientationBase::GetDefaultObj()
{
	static class UParticleModuleOrientationBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleOrientationBase*>(UParticleModuleOrientationBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleOrientationAxisLock
// (None)

class UClass* UParticleModuleOrientationAxisLock::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleOrientationAxisLock");

	return Clss;
}


// ParticleModuleOrientationAxisLock Engine.Default__ParticleModuleOrientationAxisLock
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleOrientationAxisLock* UParticleModuleOrientationAxisLock::GetDefaultObj()
{
	static class UParticleModuleOrientationAxisLock* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleOrientationAxisLock*>(UParticleModuleOrientationAxisLock::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleParameterBase
// (None)

class UClass* UParticleModuleParameterBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleParameterBase");

	return Clss;
}


// ParticleModuleParameterBase Engine.Default__ParticleModuleParameterBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleParameterBase* UParticleModuleParameterBase::GetDefaultObj()
{
	static class UParticleModuleParameterBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleParameterBase*>(UParticleModuleParameterBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleParameterDynamic
// (None)

class UClass* UParticleModuleParameterDynamic::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleParameterDynamic");

	return Clss;
}


// ParticleModuleParameterDynamic Engine.Default__ParticleModuleParameterDynamic
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleParameterDynamic* UParticleModuleParameterDynamic::GetDefaultObj()
{
	static class UParticleModuleParameterDynamic* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleParameterDynamic*>(UParticleModuleParameterDynamic::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleParameterDynamic_Seeded
// (None)

class UClass* UParticleModuleParameterDynamic_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleParameterDynamic_Seeded");

	return Clss;
}


// ParticleModuleParameterDynamic_Seeded Engine.Default__ParticleModuleParameterDynamic_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleParameterDynamic_Seeded* UParticleModuleParameterDynamic_Seeded::GetDefaultObj()
{
	static class UParticleModuleParameterDynamic_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleParameterDynamic_Seeded*>(UParticleModuleParameterDynamic_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModulePivotOffset
// (None)

class UClass* UParticleModulePivotOffset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModulePivotOffset");

	return Clss;
}


// ParticleModulePivotOffset Engine.Default__ParticleModulePivotOffset
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModulePivotOffset* UParticleModulePivotOffset::GetDefaultObj()
{
	static class UParticleModulePivotOffset* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModulePivotOffset*>(UParticleModulePivotOffset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRequired
// (None)

class UClass* UParticleModuleRequired::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRequired");

	return Clss;
}


// ParticleModuleRequired Engine.Default__ParticleModuleRequired
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRequired* UParticleModuleRequired::GetDefaultObj()
{
	static class UParticleModuleRequired* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRequired*>(UParticleModuleRequired::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRotation
// (None)

class UClass* UParticleModuleRotation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRotation");

	return Clss;
}


// ParticleModuleRotation Engine.Default__ParticleModuleRotation
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRotation* UParticleModuleRotation::GetDefaultObj()
{
	static class UParticleModuleRotation* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRotation*>(UParticleModuleRotation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRotation_Seeded
// (None)

class UClass* UParticleModuleRotation_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRotation_Seeded");

	return Clss;
}


// ParticleModuleRotation_Seeded Engine.Default__ParticleModuleRotation_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRotation_Seeded* UParticleModuleRotation_Seeded::GetDefaultObj()
{
	static class UParticleModuleRotation_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRotation_Seeded*>(UParticleModuleRotation_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRotationOverLifetime
// (None)

class UClass* UParticleModuleRotationOverLifetime::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRotationOverLifetime");

	return Clss;
}


// ParticleModuleRotationOverLifetime Engine.Default__ParticleModuleRotationOverLifetime
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRotationOverLifetime* UParticleModuleRotationOverLifetime::GetDefaultObj()
{
	static class UParticleModuleRotationOverLifetime* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRotationOverLifetime*>(UParticleModuleRotationOverLifetime::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRotationRate
// (None)

class UClass* UParticleModuleRotationRate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRotationRate");

	return Clss;
}


// ParticleModuleRotationRate Engine.Default__ParticleModuleRotationRate
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRotationRate* UParticleModuleRotationRate::GetDefaultObj()
{
	static class UParticleModuleRotationRate* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRotationRate*>(UParticleModuleRotationRate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRotationRate_Seeded
// (None)

class UClass* UParticleModuleRotationRate_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRotationRate_Seeded");

	return Clss;
}


// ParticleModuleRotationRate_Seeded Engine.Default__ParticleModuleRotationRate_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRotationRate_Seeded* UParticleModuleRotationRate_Seeded::GetDefaultObj()
{
	static class UParticleModuleRotationRate_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRotationRate_Seeded*>(UParticleModuleRotationRate_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleRotationRateMultiplyLife
// (None)

class UClass* UParticleModuleRotationRateMultiplyLife::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleRotationRateMultiplyLife");

	return Clss;
}


// ParticleModuleRotationRateMultiplyLife Engine.Default__ParticleModuleRotationRateMultiplyLife
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleRotationRateMultiplyLife* UParticleModuleRotationRateMultiplyLife::GetDefaultObj()
{
	static class UParticleModuleRotationRateMultiplyLife* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleRotationRateMultiplyLife*>(UParticleModuleRotationRateMultiplyLife::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSizeBase
// (None)

class UClass* UParticleModuleSizeBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSizeBase");

	return Clss;
}


// ParticleModuleSizeBase Engine.Default__ParticleModuleSizeBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSizeBase* UParticleModuleSizeBase::GetDefaultObj()
{
	static class UParticleModuleSizeBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSizeBase*>(UParticleModuleSizeBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSize
// (None)

class UClass* UParticleModuleSize::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSize");

	return Clss;
}


// ParticleModuleSize Engine.Default__ParticleModuleSize
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSize* UParticleModuleSize::GetDefaultObj()
{
	static class UParticleModuleSize* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSize*>(UParticleModuleSize::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSize_Seeded
// (None)

class UClass* UParticleModuleSize_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSize_Seeded");

	return Clss;
}


// ParticleModuleSize_Seeded Engine.Default__ParticleModuleSize_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSize_Seeded* UParticleModuleSize_Seeded::GetDefaultObj()
{
	static class UParticleModuleSize_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSize_Seeded*>(UParticleModuleSize_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSizeMultiplyLife
// (None)

class UClass* UParticleModuleSizeMultiplyLife::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSizeMultiplyLife");

	return Clss;
}


// ParticleModuleSizeMultiplyLife Engine.Default__ParticleModuleSizeMultiplyLife
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSizeMultiplyLife* UParticleModuleSizeMultiplyLife::GetDefaultObj()
{
	static class UParticleModuleSizeMultiplyLife* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSizeMultiplyLife*>(UParticleModuleSizeMultiplyLife::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSizeScale
// (None)

class UClass* UParticleModuleSizeScale::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSizeScale");

	return Clss;
}


// ParticleModuleSizeScale Engine.Default__ParticleModuleSizeScale
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSizeScale* UParticleModuleSizeScale::GetDefaultObj()
{
	static class UParticleModuleSizeScale* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSizeScale*>(UParticleModuleSizeScale::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSizeScaleBySpeed
// (None)

class UClass* UParticleModuleSizeScaleBySpeed::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSizeScaleBySpeed");

	return Clss;
}


// ParticleModuleSizeScaleBySpeed Engine.Default__ParticleModuleSizeScaleBySpeed
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSizeScaleBySpeed* UParticleModuleSizeScaleBySpeed::GetDefaultObj()
{
	static class UParticleModuleSizeScaleBySpeed* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSizeScaleBySpeed*>(UParticleModuleSizeScaleBySpeed::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSourceMovement
// (None)

class UClass* UParticleModuleSourceMovement::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSourceMovement");

	return Clss;
}


// ParticleModuleSourceMovement Engine.Default__ParticleModuleSourceMovement
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSourceMovement* UParticleModuleSourceMovement::GetDefaultObj()
{
	static class UParticleModuleSourceMovement* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSourceMovement*>(UParticleModuleSourceMovement::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSpawnBase
// (None)

class UClass* UParticleModuleSpawnBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSpawnBase");

	return Clss;
}


// ParticleModuleSpawnBase Engine.Default__ParticleModuleSpawnBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSpawnBase* UParticleModuleSpawnBase::GetDefaultObj()
{
	static class UParticleModuleSpawnBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSpawnBase*>(UParticleModuleSpawnBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSpawn
// (None)

class UClass* UParticleModuleSpawn::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSpawn");

	return Clss;
}


// ParticleModuleSpawn Engine.Default__ParticleModuleSpawn
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSpawn* UParticleModuleSpawn::GetDefaultObj()
{
	static class UParticleModuleSpawn* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSpawn*>(UParticleModuleSpawn::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSpawnPerUnit
// (None)

class UClass* UParticleModuleSpawnPerUnit::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSpawnPerUnit");

	return Clss;
}


// ParticleModuleSpawnPerUnit Engine.Default__ParticleModuleSpawnPerUnit
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSpawnPerUnit* UParticleModuleSpawnPerUnit::GetDefaultObj()
{
	static class UParticleModuleSpawnPerUnit* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSpawnPerUnit*>(UParticleModuleSpawnPerUnit::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSubUVBase
// (None)

class UClass* UParticleModuleSubUVBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSubUVBase");

	return Clss;
}


// ParticleModuleSubUVBase Engine.Default__ParticleModuleSubUVBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSubUVBase* UParticleModuleSubUVBase::GetDefaultObj()
{
	static class UParticleModuleSubUVBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSubUVBase*>(UParticleModuleSubUVBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSubUV
// (None)

class UClass* UParticleModuleSubUV::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSubUV");

	return Clss;
}


// ParticleModuleSubUV Engine.Default__ParticleModuleSubUV
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSubUV* UParticleModuleSubUV::GetDefaultObj()
{
	static class UParticleModuleSubUV* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSubUV*>(UParticleModuleSubUV::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleSubUVMovie
// (None)

class UClass* UParticleModuleSubUVMovie::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleSubUVMovie");

	return Clss;
}


// ParticleModuleSubUVMovie Engine.Default__ParticleModuleSubUVMovie
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleSubUVMovie* UParticleModuleSubUVMovie::GetDefaultObj()
{
	static class UParticleModuleSubUVMovie* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleSubUVMovie*>(UParticleModuleSubUVMovie::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleTrailBase
// (None)

class UClass* UParticleModuleTrailBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleTrailBase");

	return Clss;
}


// ParticleModuleTrailBase Engine.Default__ParticleModuleTrailBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleTrailBase* UParticleModuleTrailBase::GetDefaultObj()
{
	static class UParticleModuleTrailBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleTrailBase*>(UParticleModuleTrailBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleTrailSource
// (None)

class UClass* UParticleModuleTrailSource::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleTrailSource");

	return Clss;
}


// ParticleModuleTrailSource Engine.Default__ParticleModuleTrailSource
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleTrailSource* UParticleModuleTrailSource::GetDefaultObj()
{
	static class UParticleModuleTrailSource* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleTrailSource*>(UParticleModuleTrailSource::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleTypeDataBase
// (None)

class UClass* UParticleModuleTypeDataBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleTypeDataBase");

	return Clss;
}


// ParticleModuleTypeDataBase Engine.Default__ParticleModuleTypeDataBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleTypeDataBase* UParticleModuleTypeDataBase::GetDefaultObj()
{
	static class UParticleModuleTypeDataBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleTypeDataBase*>(UParticleModuleTypeDataBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleTypeDataAnimTrail
// (None)

class UClass* UParticleModuleTypeDataAnimTrail::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleTypeDataAnimTrail");

	return Clss;
}


// ParticleModuleTypeDataAnimTrail Engine.Default__ParticleModuleTypeDataAnimTrail
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleTypeDataAnimTrail* UParticleModuleTypeDataAnimTrail::GetDefaultObj()
{
	static class UParticleModuleTypeDataAnimTrail* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleTypeDataAnimTrail*>(UParticleModuleTypeDataAnimTrail::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleTypeDataBeam2
// (None)

class UClass* UParticleModuleTypeDataBeam2::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleTypeDataBeam2");

	return Clss;
}


// ParticleModuleTypeDataBeam2 Engine.Default__ParticleModuleTypeDataBeam2
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleTypeDataBeam2* UParticleModuleTypeDataBeam2::GetDefaultObj()
{
	static class UParticleModuleTypeDataBeam2* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleTypeDataBeam2*>(UParticleModuleTypeDataBeam2::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleTypeDataGpu
// (None)

class UClass* UParticleModuleTypeDataGpu::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleTypeDataGpu");

	return Clss;
}


// ParticleModuleTypeDataGpu Engine.Default__ParticleModuleTypeDataGpu
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleTypeDataGpu* UParticleModuleTypeDataGpu::GetDefaultObj()
{
	static class UParticleModuleTypeDataGpu* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleTypeDataGpu*>(UParticleModuleTypeDataGpu::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleTypeDataMesh
// (None)

class UClass* UParticleModuleTypeDataMesh::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleTypeDataMesh");

	return Clss;
}


// ParticleModuleTypeDataMesh Engine.Default__ParticleModuleTypeDataMesh
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleTypeDataMesh* UParticleModuleTypeDataMesh::GetDefaultObj()
{
	static class UParticleModuleTypeDataMesh* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleTypeDataMesh*>(UParticleModuleTypeDataMesh::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleTypeDataRibbon
// (None)

class UClass* UParticleModuleTypeDataRibbon::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleTypeDataRibbon");

	return Clss;
}


// ParticleModuleTypeDataRibbon Engine.Default__ParticleModuleTypeDataRibbon
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleTypeDataRibbon* UParticleModuleTypeDataRibbon::GetDefaultObj()
{
	static class UParticleModuleTypeDataRibbon* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleTypeDataRibbon*>(UParticleModuleTypeDataRibbon::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVectorFieldBase
// (None)

class UClass* UParticleModuleVectorFieldBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVectorFieldBase");

	return Clss;
}


// ParticleModuleVectorFieldBase Engine.Default__ParticleModuleVectorFieldBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVectorFieldBase* UParticleModuleVectorFieldBase::GetDefaultObj()
{
	static class UParticleModuleVectorFieldBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVectorFieldBase*>(UParticleModuleVectorFieldBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVectorFieldGlobal
// (None)

class UClass* UParticleModuleVectorFieldGlobal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVectorFieldGlobal");

	return Clss;
}


// ParticleModuleVectorFieldGlobal Engine.Default__ParticleModuleVectorFieldGlobal
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVectorFieldGlobal* UParticleModuleVectorFieldGlobal::GetDefaultObj()
{
	static class UParticleModuleVectorFieldGlobal* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVectorFieldGlobal*>(UParticleModuleVectorFieldGlobal::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVectorFieldLocal
// (None)

class UClass* UParticleModuleVectorFieldLocal::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVectorFieldLocal");

	return Clss;
}


// ParticleModuleVectorFieldLocal Engine.Default__ParticleModuleVectorFieldLocal
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVectorFieldLocal* UParticleModuleVectorFieldLocal::GetDefaultObj()
{
	static class UParticleModuleVectorFieldLocal* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVectorFieldLocal*>(UParticleModuleVectorFieldLocal::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVectorFieldRotation
// (None)

class UClass* UParticleModuleVectorFieldRotation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVectorFieldRotation");

	return Clss;
}


// ParticleModuleVectorFieldRotation Engine.Default__ParticleModuleVectorFieldRotation
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVectorFieldRotation* UParticleModuleVectorFieldRotation::GetDefaultObj()
{
	static class UParticleModuleVectorFieldRotation* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVectorFieldRotation*>(UParticleModuleVectorFieldRotation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVectorFieldRotationRate
// (None)

class UClass* UParticleModuleVectorFieldRotationRate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVectorFieldRotationRate");

	return Clss;
}


// ParticleModuleVectorFieldRotationRate Engine.Default__ParticleModuleVectorFieldRotationRate
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVectorFieldRotationRate* UParticleModuleVectorFieldRotationRate::GetDefaultObj()
{
	static class UParticleModuleVectorFieldRotationRate* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVectorFieldRotationRate*>(UParticleModuleVectorFieldRotationRate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVectorFieldScale
// (None)

class UClass* UParticleModuleVectorFieldScale::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVectorFieldScale");

	return Clss;
}


// ParticleModuleVectorFieldScale Engine.Default__ParticleModuleVectorFieldScale
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVectorFieldScale* UParticleModuleVectorFieldScale::GetDefaultObj()
{
	static class UParticleModuleVectorFieldScale* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVectorFieldScale*>(UParticleModuleVectorFieldScale::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVectorFieldScaleOverLife
// (None)

class UClass* UParticleModuleVectorFieldScaleOverLife::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVectorFieldScaleOverLife");

	return Clss;
}


// ParticleModuleVectorFieldScaleOverLife Engine.Default__ParticleModuleVectorFieldScaleOverLife
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVectorFieldScaleOverLife* UParticleModuleVectorFieldScaleOverLife::GetDefaultObj()
{
	static class UParticleModuleVectorFieldScaleOverLife* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVectorFieldScaleOverLife*>(UParticleModuleVectorFieldScaleOverLife::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVelocityBase
// (None)

class UClass* UParticleModuleVelocityBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVelocityBase");

	return Clss;
}


// ParticleModuleVelocityBase Engine.Default__ParticleModuleVelocityBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVelocityBase* UParticleModuleVelocityBase::GetDefaultObj()
{
	static class UParticleModuleVelocityBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVelocityBase*>(UParticleModuleVelocityBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVelocity
// (None)

class UClass* UParticleModuleVelocity::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVelocity");

	return Clss;
}


// ParticleModuleVelocity Engine.Default__ParticleModuleVelocity
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVelocity* UParticleModuleVelocity::GetDefaultObj()
{
	static class UParticleModuleVelocity* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVelocity*>(UParticleModuleVelocity::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVelocity_Seeded
// (None)

class UClass* UParticleModuleVelocity_Seeded::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVelocity_Seeded");

	return Clss;
}


// ParticleModuleVelocity_Seeded Engine.Default__ParticleModuleVelocity_Seeded
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVelocity_Seeded* UParticleModuleVelocity_Seeded::GetDefaultObj()
{
	static class UParticleModuleVelocity_Seeded* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVelocity_Seeded*>(UParticleModuleVelocity_Seeded::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVelocityCone
// (None)

class UClass* UParticleModuleVelocityCone::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVelocityCone");

	return Clss;
}


// ParticleModuleVelocityCone Engine.Default__ParticleModuleVelocityCone
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVelocityCone* UParticleModuleVelocityCone::GetDefaultObj()
{
	static class UParticleModuleVelocityCone* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVelocityCone*>(UParticleModuleVelocityCone::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVelocityInheritParent
// (None)

class UClass* UParticleModuleVelocityInheritParent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVelocityInheritParent");

	return Clss;
}


// ParticleModuleVelocityInheritParent Engine.Default__ParticleModuleVelocityInheritParent
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVelocityInheritParent* UParticleModuleVelocityInheritParent::GetDefaultObj()
{
	static class UParticleModuleVelocityInheritParent* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVelocityInheritParent*>(UParticleModuleVelocityInheritParent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleModuleVelocityOverLifetime
// (None)

class UClass* UParticleModuleVelocityOverLifetime::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleModuleVelocityOverLifetime");

	return Clss;
}


// ParticleModuleVelocityOverLifetime Engine.Default__ParticleModuleVelocityOverLifetime
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleModuleVelocityOverLifetime* UParticleModuleVelocityOverLifetime::GetDefaultObj()
{
	static class UParticleModuleVelocityOverLifetime* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleModuleVelocityOverLifetime*>(UParticleModuleVelocityOverLifetime::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleSpriteEmitter
// (None)

class UClass* UParticleSpriteEmitter::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleSpriteEmitter");

	return Clss;
}


// ParticleSpriteEmitter Engine.Default__ParticleSpriteEmitter
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleSpriteEmitter* UParticleSpriteEmitter::GetDefaultObj()
{
	static class UParticleSpriteEmitter* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleSpriteEmitter*>(UParticleSpriteEmitter::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ParticleSystem
// (None)

class UClass* UParticleSystem::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleSystem");

	return Clss;
}


// ParticleSystem Engine.Default__ParticleSystem
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleSystem* UParticleSystem::GetDefaultObj()
{
	static class UParticleSystem* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleSystem*>(UParticleSystem::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ParticleSystem.ContainsEmitterType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                      TypeData                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystem::ContainsEmitterType(class UClass* TypeData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystem", "ContainsEmitterType");

	Params::UParticleSystem_ContainsEmitterType_Params Parms{};

	Parms.TypeData = TypeData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.ParticleSystemComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UParticleSystemComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleSystemComponent");

	return Clss;
}


// ParticleSystemComponent Engine.Default__ParticleSystemComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleSystemComponent* UParticleSystemComponent::GetDefaultObj()
{
	static class UParticleSystemComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleSystemComponent*>(UParticleSystemComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.ParticleSystemComponent.SetTrailSourceData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InFirstSocketName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSecondSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETrailWidthMode         InWidthMode                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InWidth                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetTrailSourceData(class FName InFirstSocketName, class FName InSecondSocketName, enum class ETrailWidthMode InWidthMode, float InWidth)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetTrailSourceData");

	Params::UParticleSystemComponent_SetTrailSourceData_Params Parms{};

	Parms.InFirstSocketName = InFirstSocketName;
	Parms.InSecondSocketName = InSecondSocketName;
	Parms.InWidthMode = InWidthMode;
	Parms.InWidth = InWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetTemplate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystem*             NewTemplate                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetTemplate(class UParticleSystem* NewTemplate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetTemplate");

	Params::UParticleSystemComponent_SetTemplate_Params Parms{};

	Parms.NewTemplate = NewTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetMaterialParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        ParameterName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          Param                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetMaterialParameter(class FName ParameterName, class UMaterialInterface* Param)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetMaterialParameter");

	Params::UParticleSystemComponent_SetMaterialParameter_Params Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetBeamTargetTangent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewTangentPoint                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TargetIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamTargetTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetBeamTargetTangent");

	Params::UParticleSystemComponent_SetBeamTargetTangent_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTangentPoint = NewTangentPoint;
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetBeamTargetStrength
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NewTargetStrength                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TargetIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamTargetStrength(int32 EmitterIndex, float NewTargetStrength, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetBeamTargetStrength");

	Params::UParticleSystemComponent_SetBeamTargetStrength_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTargetStrength = NewTargetStrength;
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetBeamTargetPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewTargetPoint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TargetIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamTargetPoint(int32 EmitterIndex, const struct FVector& NewTargetPoint, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetBeamTargetPoint");

	Params::UParticleSystemComponent_SetBeamTargetPoint_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTargetPoint = NewTargetPoint;
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetBeamSourceTangent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewTangentPoint                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SourceIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamSourceTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetBeamSourceTangent");

	Params::UParticleSystemComponent_SetBeamSourceTangent_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTangentPoint = NewTangentPoint;
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetBeamSourceStrength
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              NewSourceStrength                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SourceIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamSourceStrength(int32 EmitterIndex, float NewSourceStrength, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetBeamSourceStrength");

	Params::UParticleSystemComponent_SetBeamSourceStrength_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewSourceStrength = NewSourceStrength;
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetBeamSourcePoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewSourcePoint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SourceIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamSourcePoint(int32 EmitterIndex, const struct FVector& NewSourcePoint, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetBeamSourcePoint");

	Params::UParticleSystemComponent_SetBeamSourcePoint_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewSourcePoint = NewSourcePoint;
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetBeamEndPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NewEndPoint                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamEndPoint(int32 EmitterIndex, const struct FVector& NewEndPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetBeamEndPoint");

	Params::UParticleSystemComponent_SetBeamEndPoint_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewEndPoint = NewEndPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.SetAutoAttachParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*             Parent                                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        SocketName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAttachLocation         LocationType                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetAutoAttachParams(class USceneComponent* Parent, class FName SocketName, enum class EAttachLocation LocationType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "SetAutoAttachParams");

	Params::UParticleSystemComponent_SetAutoAttachParams_Params Parms{};

	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationType = LocationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.ReleaseToPool
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UParticleSystemComponent::ReleaseToPool()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "ReleaseToPool");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.GetNumActiveParticles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UParticleSystemComponent::GetNumActiveParticles()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetNumActiveParticles");

	Params::UParticleSystemComponent_GetNumActiveParticles_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GetNamedMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UParticleSystemComponent::GetNamedMaterial(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetNamedMaterial");

	Params::UParticleSystemComponent_GetNamedMaterial_Params Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GetBeamTargetTangent
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TargetIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutTangentPoint                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamTargetTangent(int32 EmitterIndex, int32 TargetIndex, struct FVector* OutTangentPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetBeamTargetTangent");

	Params::UParticleSystemComponent_GetBeamTargetTangent_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTangentPoint != nullptr)
		*OutTangentPoint = std::move(Parms.OutTangentPoint);

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GetBeamTargetStrength
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TargetIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutTargetStrength                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamTargetStrength(int32 EmitterIndex, int32 TargetIndex, float* OutTargetStrength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetBeamTargetStrength");

	Params::UParticleSystemComponent_GetBeamTargetStrength_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTargetStrength != nullptr)
		*OutTargetStrength = Parms.OutTargetStrength;

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GetBeamTargetPoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              TargetIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutTargetPoint                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamTargetPoint(int32 EmitterIndex, int32 TargetIndex, struct FVector* OutTargetPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetBeamTargetPoint");

	Params::UParticleSystemComponent_GetBeamTargetPoint_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.TargetIndex = TargetIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTargetPoint != nullptr)
		*OutTargetPoint = std::move(Parms.OutTargetPoint);

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GetBeamSourceTangent
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SourceIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutTangentPoint                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamSourceTangent(int32 EmitterIndex, int32 SourceIndex, struct FVector* OutTangentPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetBeamSourceTangent");

	Params::UParticleSystemComponent_GetBeamSourceTangent_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTangentPoint != nullptr)
		*OutTangentPoint = std::move(Parms.OutTangentPoint);

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GetBeamSourceStrength
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SourceIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              OutSourceStrength                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamSourceStrength(int32 EmitterIndex, int32 SourceIndex, float* OutSourceStrength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetBeamSourceStrength");

	Params::UParticleSystemComponent_GetBeamSourceStrength_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSourceStrength != nullptr)
		*OutSourceStrength = Parms.OutSourceStrength;

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GetBeamSourcePoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              SourceIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutSourcePoint                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamSourcePoint(int32 EmitterIndex, int32 SourceIndex, struct FVector* OutSourcePoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetBeamSourcePoint");

	Params::UParticleSystemComponent_GetBeamSourcePoint_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.SourceIndex = SourceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutSourcePoint != nullptr)
		*OutSourcePoint = std::move(Parms.OutSourcePoint);

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GetBeamEndPoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              EmitterIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutEndPoint                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamEndPoint(int32 EmitterIndex, struct FVector* OutEndPoint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GetBeamEndPoint");

	Params::UParticleSystemComponent_GetBeamEndPoint_Params Parms{};

	Parms.EmitterIndex = EmitterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutEndPoint != nullptr)
		*OutEndPoint = std::move(Parms.OutEndPoint);

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.GenerateParticleEvent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        InEventName                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InEmitterTime                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InLocation                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InDirection                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InVelocity                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::GenerateParticleEvent(class FName InEventName, float InEmitterTime, const struct FVector& InLocation, const struct FVector& InDirection, const struct FVector& InVelocity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "GenerateParticleEvent");

	Params::UParticleSystemComponent_GenerateParticleEvent_Params Parms{};

	Parms.InEventName = InEventName;
	Parms.InEmitterTime = InEmitterTime;
	Parms.InLocation = InLocation;
	Parms.InDirection = InDirection;
	Parms.InVelocity = InVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.EndTrails
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UParticleSystemComponent::EndTrails()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "EndTrails");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InName                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          SourceMaterial                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UParticleSystemComponent::CreateNamedDynamicMaterialInstance(class FName InName, class UMaterialInterface* SourceMaterial)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "CreateNamedDynamicMaterialInstance");

	Params::UParticleSystemComponent_CreateNamedDynamicMaterialInstance_Params Parms{};

	Parms.InName = InName;
	Parms.SourceMaterial = SourceMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.ParticleSystemComponent.BeginTrails
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        InFirstSocketName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InSecondSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class ETrailWidthMode         InWidthMode                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InWidth                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::BeginTrails(class FName InFirstSocketName, class FName InSecondSocketName, enum class ETrailWidthMode InWidthMode, float InWidth)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("ParticleSystemComponent", "BeginTrails");

	Params::UParticleSystemComponent_BeginTrails_Params Parms{};

	Parms.InFirstSocketName = InFirstSocketName;
	Parms.InSecondSocketName = InSecondSocketName;
	Parms.InWidthMode = InWidthMode;
	Parms.InWidth = InWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.ParticleSystemReplay
// (None)

class UClass* UParticleSystemReplay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ParticleSystemReplay");

	return Clss;
}


// ParticleSystemReplay Engine.Default__ParticleSystemReplay
// (Public, ClassDefaultObject, ArchetypeObject)

class UParticleSystemReplay* UParticleSystemReplay::GetDefaultObj()
{
	static class UParticleSystemReplay* Default = nullptr;

	if (!Default)
		Default = static_cast<UParticleSystemReplay*>(UParticleSystemReplay::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PathFollowingAgentInterface
// (None)

class UClass* IPathFollowingAgentInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PathFollowingAgentInterface");

	return Clss;
}


// PathFollowingAgentInterface Engine.Default__PathFollowingAgentInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IPathFollowingAgentInterface* IPathFollowingAgentInterface::GetDefaultObj()
{
	static class IPathFollowingAgentInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IPathFollowingAgentInterface*>(IPathFollowingAgentInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PawnNoiseEmitterComponent
// (None)

class UClass* UPawnNoiseEmitterComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PawnNoiseEmitterComponent");

	return Clss;
}


// PawnNoiseEmitterComponent Engine.Default__PawnNoiseEmitterComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPawnNoiseEmitterComponent* UPawnNoiseEmitterComponent::GetDefaultObj()
{
	static class UPawnNoiseEmitterComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPawnNoiseEmitterComponent*>(UPawnNoiseEmitterComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PawnNoiseEmitterComponent.MakeNoise
// (BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                      NoiseMaker                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Loudness                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     NoiseLocation                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPawnNoiseEmitterComponent::MakeNoise(class AActor* NoiseMaker, float Loudness, struct FVector& NoiseLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PawnNoiseEmitterComponent", "MakeNoise");

	Params::UPawnNoiseEmitterComponent_MakeNoise_Params Parms{};

	Parms.NoiseMaker = NoiseMaker;
	Parms.Loudness = Loudness;
	Parms.NoiseLocation = NoiseLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PhysicalAnimationComponent
// (None)

class UClass* UPhysicalAnimationComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicalAnimationComponent");

	return Clss;
}


// PhysicalAnimationComponent Engine.Default__PhysicalAnimationComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicalAnimationComponent* UPhysicalAnimationComponent::GetDefaultObj()
{
	static class UPhysicalAnimationComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicalAnimationComponent*>(UPhysicalAnimationComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PhysicalAnimationComponent.SetStrengthMultiplyer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InStrengthMultiplyer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::SetStrengthMultiplyer(float InStrengthMultiplyer)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicalAnimationComponent", "SetStrengthMultiplyer");

	Params::UPhysicalAnimationComponent_SetStrengthMultiplyer_Params Parms{};

	Parms.InStrengthMultiplyer = InStrengthMultiplyer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicalAnimationComponent.SetSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*      InSkeletalMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::SetSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicalAnimationComponent", "SetSkeletalMeshComponent");

	Params::UPhysicalAnimationComponent_SetSkeletalMeshComponent_Params Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicalAnimationComponent.GetBodyTargetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        BodyName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UPhysicalAnimationComponent::GetBodyTargetTransform(class FName BodyName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicalAnimationComponent", "GetBodyTargetTransform");

	Params::UPhysicalAnimationComponent_GetBodyTargetTransform_Params Parms{};

	Parms.BodyName = BodyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettingsBelow
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        BodyName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPhysicalAnimationData      PhysicalAnimationData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                               bIncludeSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::ApplyPhysicalAnimationSettingsBelow(class FName BodyName, struct FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicalAnimationComponent", "ApplyPhysicalAnimationSettingsBelow");

	Params::UPhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow_Params Parms{};

	Parms.BodyName = BodyName;
	Parms.PhysicalAnimationData = PhysicalAnimationData;
	Parms.bIncludeSelf = bIncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                        BodyName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPhysicalAnimationData      PhysicalAnimationData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::ApplyPhysicalAnimationSettings(class FName BodyName, struct FPhysicalAnimationData& PhysicalAnimationData)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicalAnimationComponent", "ApplyPhysicalAnimationSettings");

	Params::UPhysicalAnimationComponent_ApplyPhysicalAnimationSettings_Params Parms{};

	Parms.BodyName = BodyName;
	Parms.PhysicalAnimationData = PhysicalAnimationData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationProfileBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BodyName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        ProfileName                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bIncludeSelf                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bClearNotFound                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::ApplyPhysicalAnimationProfileBelow(class FName BodyName, class FName ProfileName, bool bIncludeSelf, bool bClearNotFound)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicalAnimationComponent", "ApplyPhysicalAnimationProfileBelow");

	Params::UPhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow_Params Parms{};

	Parms.BodyName = BodyName;
	Parms.ProfileName = ProfileName;
	Parms.bIncludeSelf = bIncludeSelf;
	Parms.bClearNotFound = bClearNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PhysicalMaterial
// (None)

class UClass* UPhysicalMaterial::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicalMaterial");

	return Clss;
}


// PhysicalMaterial Engine.Default__PhysicalMaterial
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicalMaterial* UPhysicalMaterial::GetDefaultObj()
{
	static class UPhysicalMaterial* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicalMaterial*>(UPhysicalMaterial::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PhysicalMaterialPropertyBase
// (None)

class UClass* UPhysicalMaterialPropertyBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicalMaterialPropertyBase");

	return Clss;
}


// PhysicalMaterialPropertyBase Engine.Default__PhysicalMaterialPropertyBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicalMaterialPropertyBase* UPhysicalMaterialPropertyBase::GetDefaultObj()
{
	static class UPhysicalMaterialPropertyBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicalMaterialPropertyBase*>(UPhysicalMaterialPropertyBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PhysicsAsset
// (None)

class UClass* UPhysicsAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsAsset");

	return Clss;
}


// PhysicsAsset Engine.Default__PhysicsAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicsAsset* UPhysicsAsset::GetDefaultObj()
{
	static class UPhysicsAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicsAsset*>(UPhysicsAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SkeletalBodySetup
// (None)

class UClass* USkeletalBodySetup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkeletalBodySetup");

	return Clss;
}


// SkeletalBodySetup Engine.Default__SkeletalBodySetup
// (Public, Transactional, ClassDefaultObject, ArchetypeObject)

class USkeletalBodySetup* USkeletalBodySetup::GetDefaultObj()
{
	static class USkeletalBodySetup* Default = nullptr;

	if (!Default)
		Default = static_cast<USkeletalBodySetup*>(USkeletalBodySetup::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PhysicsCollisionHandler
// (None)

class UClass* UPhysicsCollisionHandler::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsCollisionHandler");

	return Clss;
}


// PhysicsCollisionHandler Engine.Default__PhysicsCollisionHandler
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicsCollisionHandler* UPhysicsCollisionHandler::GetDefaultObj()
{
	static class UPhysicsCollisionHandler* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicsCollisionHandler*>(UPhysicsCollisionHandler::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.RigidBodyBase
// (Actor)

class UClass* ARigidBodyBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RigidBodyBase");

	return Clss;
}


// RigidBodyBase Engine.Default__RigidBodyBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ARigidBodyBase* ARigidBodyBase::GetDefaultObj()
{
	static class ARigidBodyBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ARigidBodyBase*>(ARigidBodyBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PhysicsConstraintActor
// (Actor)

class UClass* APhysicsConstraintActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsConstraintActor");

	return Clss;
}


// PhysicsConstraintActor Engine.Default__PhysicsConstraintActor
// (Public, ClassDefaultObject, ArchetypeObject)

class APhysicsConstraintActor* APhysicsConstraintActor::GetDefaultObj()
{
	static class APhysicsConstraintActor* Default = nullptr;

	if (!Default)
		Default = static_cast<APhysicsConstraintActor*>(APhysicsConstraintActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PhysicsConstraintComponent
// (SceneComponent)

class UClass* UPhysicsConstraintComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsConstraintComponent");

	return Clss;
}


// PhysicsConstraintComponent Engine.Default__PhysicsConstraintComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicsConstraintComponent* UPhysicsConstraintComponent::GetDefaultObj()
{
	static class UPhysicsConstraintComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicsConstraintComponent*>(UPhysicsConstraintComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PhysicsConstraintComponent.SetOrientationDriveTwistAndSwing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableTwistDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableSwingDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetOrientationDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetOrientationDriveTwistAndSwing");

	Params::UPhysicsConstraintComponent_SetOrientationDriveTwistAndSwing_Params Parms{};

	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bEnableSwingDrive = bEnableSwingDrive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetOrientationDriveSLERP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableSLERP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetOrientationDriveSLERP(bool bEnableSLERP)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetOrientationDriveSLERP");

	Params::UPhysicsConstraintComponent_SetOrientationDriveSLERP_Params Parms{};

	Parms.bEnableSLERP = bEnableSLERP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearZLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ELinearConstraintMotion ConstraintType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LimitSize                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearZLimit(enum class ELinearConstraintMotion ConstraintType, float LimitSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearZLimit");

	Params::UPhysicsConstraintComponent_SetLinearZLimit_Params Parms{};

	Parms.ConstraintType = ConstraintType;
	Parms.LimitSize = LimitSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearYLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ELinearConstraintMotion ConstraintType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LimitSize                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearYLimit(enum class ELinearConstraintMotion ConstraintType, float LimitSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearYLimit");

	Params::UPhysicsConstraintComponent_SetLinearYLimit_Params Parms{};

	Parms.ConstraintType = ConstraintType;
	Parms.LimitSize = LimitSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearXLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ELinearConstraintMotion ConstraintType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LimitSize                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearXLimit(enum class ELinearConstraintMotion ConstraintType, float LimitSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearXLimit");

	Params::UPhysicsConstraintComponent_SetLinearXLimit_Params Parms{};

	Parms.ConstraintType = ConstraintType;
	Parms.LimitSize = LimitSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InVelTarget                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearVelocityTarget(struct FVector& InVelTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearVelocityTarget");

	Params::UPhysicsConstraintComponent_SetLinearVelocityTarget_Params Parms{};

	Parms.InVelTarget = InVelTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableDriveX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableDriveY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableDriveZ                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearVelocityDrive");

	Params::UPhysicsConstraintComponent_SetLinearVelocityDrive_Params Parms{};

	Parms.bEnableDriveX = bEnableDriveX;
	Parms.bEnableDriveY = bEnableDriveY;
	Parms.bEnableDriveZ = bEnableDriveZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InPosTarget                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearPositionTarget(struct FVector& InPosTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearPositionTarget");

	Params::UPhysicsConstraintComponent_SetLinearPositionTarget_Params Parms{};

	Parms.InPosTarget = InPosTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableDriveX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableDriveY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableDriveZ                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearPositionDrive");

	Params::UPhysicsConstraintComponent_SetLinearPositionDrive_Params Parms{};

	Parms.bEnableDriveX = bEnableDriveX;
	Parms.bEnableDriveY = bEnableDriveY;
	Parms.bEnableDriveZ = bEnableDriveZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              PositionStrength                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VelocityStrength                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InForceLimit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearDriveParams");

	Params::UPhysicsConstraintComponent_SetLinearDriveParams_Params Parms{};

	Parms.PositionStrength = PositionStrength;
	Parms.VelocityStrength = VelocityStrength;
	Parms.InForceLimit = InForceLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetLinearBreakable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bLinearBreakable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              LinearBreakThreshold                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearBreakable(bool bLinearBreakable, float LinearBreakThreshold)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetLinearBreakable");

	Params::UPhysicsConstraintComponent_SetLinearBreakable_Params Parms{};

	Parms.bLinearBreakable = bLinearBreakable;
	Parms.LinearBreakThreshold = LinearBreakThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetDisableCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bDisableCollision                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetDisableCollision(bool bDisableCollision)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetDisableCollision");

	Params::UPhysicsConstraintComponent_SetDisableCollision_Params Parms{};

	Parms.bDisableCollision = bDisableCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// enum class EConstraintFrame        Frame                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     RefPosition                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetConstraintReferencePosition(enum class EConstraintFrame Frame, struct FVector& RefPosition)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetConstraintReferencePosition");

	Params::UPhysicsConstraintComponent_SetConstraintReferencePosition_Params Parms{};

	Parms.Frame = Frame;
	Parms.RefPosition = RefPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// enum class EConstraintFrame        Frame                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     PriAxis                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SecAxis                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetConstraintReferenceOrientation(enum class EConstraintFrame Frame, struct FVector& PriAxis, struct FVector& SecAxis)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetConstraintReferenceOrientation");

	Params::UPhysicsConstraintComponent_SetConstraintReferenceOrientation_Params Parms{};

	Parms.Frame = Frame;
	Parms.PriAxis = PriAxis;
	Parms.SecAxis = SecAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// enum class EConstraintFrame        Frame                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  RefFrame                                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetConstraintReferenceFrame(enum class EConstraintFrame Frame, struct FTransform& RefFrame)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetConstraintReferenceFrame");

	Params::UPhysicsConstraintComponent_SetConstraintReferenceFrame_Params Parms{};

	Parms.Frame = Frame;
	Parms.RefFrame = RefFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetConstrainedComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component1                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName1                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*         Component2                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        BoneName2                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetConstrainedComponents(class UPrimitiveComponent* Component1, class FName BoneName1, class UPrimitiveComponent* Component2, class FName BoneName2)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetConstrainedComponents");

	Params::UPhysicsConstraintComponent_SetConstrainedComponents_Params Parms{};

	Parms.Component1 = Component1;
	Parms.BoneName1 = BoneName1;
	Parms.Component2 = Component2;
	Parms.BoneName2 = BoneName2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InVelTarget                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularVelocityTarget(struct FVector& InVelTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularVelocityTarget");

	Params::UPhysicsConstraintComponent_SetAngularVelocityTarget_Params Parms{};

	Parms.InVelTarget = InVelTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveTwistAndSwing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableTwistDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableSwingDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularVelocityDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularVelocityDriveTwistAndSwing");

	Params::UPhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing_Params Parms{};

	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bEnableSwingDrive = bEnableSwingDrive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveSLERP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableSLERP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularVelocityDriveSLERP(bool bEnableSLERP)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularVelocityDriveSLERP");

	Params::UPhysicsConstraintComponent_SetAngularVelocityDriveSLERP_Params Parms{};

	Parms.bEnableSLERP = bEnableSLERP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableSwingDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableTwistDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularVelocityDrive");

	Params::UPhysicsConstraintComponent_SetAngularVelocityDrive_Params Parms{};

	Parms.bEnableSwingDrive = bEnableSwingDrive;
	Parms.bEnableTwistDrive = bEnableTwistDrive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EAngularConstraintMotionConstraintType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              TwistLimitAngle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularTwistLimit(enum class EAngularConstraintMotion ConstraintType, float TwistLimitAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularTwistLimit");

	Params::UPhysicsConstraintComponent_SetAngularTwistLimit_Params Parms{};

	Parms.ConstraintType = ConstraintType;
	Parms.TwistLimitAngle = TwistLimitAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EAngularConstraintMotionMotionType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Swing2LimitAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularSwing2Limit(enum class EAngularConstraintMotion MotionType, float Swing2LimitAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularSwing2Limit");

	Params::UPhysicsConstraintComponent_SetAngularSwing2Limit_Params Parms{};

	Parms.MotionType = MotionType;
	Parms.Swing2LimitAngle = Swing2LimitAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EAngularConstraintMotionMotionType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Swing1LimitAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularSwing1Limit(enum class EAngularConstraintMotion MotionType, float Swing1LimitAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularSwing1Limit");

	Params::UPhysicsConstraintComponent_SetAngularSwing1Limit_Params Parms{};

	Parms.MotionType = MotionType;
	Parms.Swing1LimitAngle = Swing1LimitAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    InPosTarget                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularOrientationTarget(struct FRotator& InPosTarget)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularOrientationTarget");

	Params::UPhysicsConstraintComponent_SetAngularOrientationTarget_Params Parms{};

	Parms.InPosTarget = InPosTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnableSwingDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bEnableTwistDrive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularOrientationDrive");

	Params::UPhysicsConstraintComponent_SetAngularOrientationDrive_Params Parms{};

	Parms.bEnableSwingDrive = bEnableSwingDrive;
	Parms.bEnableTwistDrive = bEnableTwistDrive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              PositionStrength                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              VelocityStrength                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InForceLimit                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularDriveParams");

	Params::UPhysicsConstraintComponent_SetAngularDriveParams_Params Parms{};

	Parms.PositionStrength = PositionStrength;
	Parms.VelocityStrength = VelocityStrength;
	Parms.InForceLimit = InForceLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularDriveMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EAngularDriveMode       DriveMode                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularDriveMode(enum class EAngularDriveMode DriveMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularDriveMode");

	Params::UPhysicsConstraintComponent_SetAngularDriveMode_Params Parms{};

	Parms.DriveMode = DriveMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.SetAngularBreakable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bAngularBreakable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              AngularBreakThreshold                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularBreakable(bool bAngularBreakable, float AngularBreakThreshold)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "SetAngularBreakable");

	Params::UPhysicsConstraintComponent_SetAngularBreakable_Params Parms{};

	Parms.bAngularBreakable = bAngularBreakable;
	Parms.AngularBreakThreshold = AngularBreakThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsConstraintComponent.IsBroken
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhysicsConstraintComponent::IsBroken()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "IsBroken");

	Params::UPhysicsConstraintComponent_IsBroken_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PhysicsConstraintComponent.GetCurrentTwist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhysicsConstraintComponent::GetCurrentTwist()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "GetCurrentTwist");

	Params::UPhysicsConstraintComponent_GetCurrentTwist_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PhysicsConstraintComponent.GetCurrentSwing2
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhysicsConstraintComponent::GetCurrentSwing2()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "GetCurrentSwing2");

	Params::UPhysicsConstraintComponent_GetCurrentSwing2_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PhysicsConstraintComponent.GetCurrentSwing1
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhysicsConstraintComponent::GetCurrentSwing1()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "GetCurrentSwing1");

	Params::UPhysicsConstraintComponent_GetCurrentSwing1_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PhysicsConstraintComponent.GetConstraintForce
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     OutLinearForce                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     OutAngularForce                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::GetConstraintForce(struct FVector* OutLinearForce, struct FVector* OutAngularForce)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "GetConstraintForce");

	Params::UPhysicsConstraintComponent_GetConstraintForce_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutLinearForce != nullptr)
		*OutLinearForce = std::move(Parms.OutLinearForce);

	if (OutAngularForce != nullptr)
		*OutAngularForce = std::move(Parms.OutAngularForce);

}


// Function Engine.PhysicsConstraintComponent.BreakConstraint
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UPhysicsConstraintComponent::BreakConstraint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsConstraintComponent", "BreakConstraint");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PhysicsConstraintTemplate
// (None)

class UClass* UPhysicsConstraintTemplate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsConstraintTemplate");

	return Clss;
}


// PhysicsConstraintTemplate Engine.Default__PhysicsConstraintTemplate
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicsConstraintTemplate* UPhysicsConstraintTemplate::GetDefaultObj()
{
	static class UPhysicsConstraintTemplate* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicsConstraintTemplate*>(UPhysicsConstraintTemplate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PhysicsHandleComponent
// (None)

class UClass* UPhysicsHandleComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsHandleComponent");

	return Clss;
}


// PhysicsHandleComponent Engine.Default__PhysicsHandleComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicsHandleComponent* UPhysicsHandleComponent::GetDefaultObj()
{
	static class UPhysicsHandleComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicsHandleComponent*>(UPhysicsHandleComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PhysicsHandleComponent.SetTargetRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetTargetRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "SetTargetRotation");

	Params::UPhysicsHandleComponent_SetTargetRotation_Params Parms{};

	Parms.NewRotation = NewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    NewRotation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetTargetLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "SetTargetLocationAndRotation");

	Params::UPhysicsHandleComponent_SetTargetLocationAndRotation_Params Parms{};

	Parms.NewLocation = NewLocation;
	Parms.NewRotation = NewRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.SetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     NewLocation                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetTargetLocation(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "SetTargetLocation");

	Params::UPhysicsHandleComponent_SetTargetLocation_Params Parms{};

	Parms.NewLocation = NewLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.SetLinearStiffness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewLinearStiffness                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetLinearStiffness(float NewLinearStiffness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "SetLinearStiffness");

	Params::UPhysicsHandleComponent_SetLinearStiffness_Params Parms{};

	Parms.NewLinearStiffness = NewLinearStiffness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.SetLinearDamping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewLinearDamping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetLinearDamping(float NewLinearDamping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "SetLinearDamping");

	Params::UPhysicsHandleComponent_SetLinearDamping_Params Parms{};

	Parms.NewLinearDamping = NewLinearDamping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.SetInterpolationSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewInterpolationSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetInterpolationSpeed(float NewInterpolationSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "SetInterpolationSpeed");

	Params::UPhysicsHandleComponent_SetInterpolationSpeed_Params Parms{};

	Parms.NewInterpolationSpeed = NewInterpolationSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.SetAngularStiffness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewAngularStiffness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetAngularStiffness(float NewAngularStiffness)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "SetAngularStiffness");

	Params::UPhysicsHandleComponent_SetAngularStiffness_Params Parms{};

	Parms.NewAngularStiffness = NewAngularStiffness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.SetAngularDamping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewAngularDamping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetAngularDamping(float NewAngularDamping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "SetAngularDamping");

	Params::UPhysicsHandleComponent_SetAngularDamping_Params Parms{};

	Parms.NewAngularDamping = NewAngularDamping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.ReleaseComponent
// (Native, Public, BlueprintCallable)
// Parameters:

void UPhysicsHandleComponent::ReleaseComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "ReleaseComponent");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.GrabComponentAtLocationWithRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    Rotation                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::GrabComponentAtLocationWithRotation(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "GrabComponentAtLocationWithRotation");

	Params::UPhysicsHandleComponent_GrabComponentAtLocationWithRotation_Params Parms{};

	Parms.Component = Component;
	Parms.InBoneName = InBoneName;
	Parms.Location = Location;
	Parms.Rotation = Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.GrabComponentAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     GrabLocation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::GrabComponentAtLocation(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& GrabLocation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "GrabComponentAtLocation");

	Params::UPhysicsHandleComponent_GrabComponentAtLocation_Params Parms{};

	Parms.Component = Component;
	Parms.InBoneName = InBoneName;
	Parms.GrabLocation = GrabLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.GrabComponent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*         Component                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        InBoneName                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     GrabLocation                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bConstrainRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::GrabComponent(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "GrabComponent");

	Params::UPhysicsHandleComponent_GrabComponent_Params Parms{};

	Parms.Component = Component;
	Parms.InBoneName = InBoneName;
	Parms.GrabLocation = GrabLocation;
	Parms.bConstrainRotation = bConstrainRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     TargetLocation                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    TargetRotation                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::GetTargetLocationAndRotation(struct FVector* TargetLocation, struct FRotator* TargetRotation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "GetTargetLocationAndRotation");

	Params::UPhysicsHandleComponent_GetTargetLocationAndRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (TargetLocation != nullptr)
		*TargetLocation = std::move(Parms.TargetLocation);

	if (TargetRotation != nullptr)
		*TargetRotation = std::move(Parms.TargetRotation);

}


// Function Engine.PhysicsHandleComponent.GetGrabbedComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*         ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UPhysicsHandleComponent::GetGrabbedComponent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsHandleComponent", "GetGrabbedComponent");

	Params::UPhysicsHandleComponent_GetGrabbedComponent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.PhysicsSettings
// (None)

class UClass* UPhysicsSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsSettings");

	return Clss;
}


// PhysicsSettings Engine.Default__PhysicsSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicsSettings* UPhysicsSettings::GetDefaultObj()
{
	static class UPhysicsSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicsSettings*>(UPhysicsSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PhysicsSpringComponent
// (SceneComponent)

class UClass* UPhysicsSpringComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsSpringComponent");

	return Clss;
}


// PhysicsSpringComponent Engine.Default__PhysicsSpringComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicsSpringComponent* UPhysicsSpringComponent::GetDefaultObj()
{
	static class UPhysicsSpringComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicsSpringComponent*>(UPhysicsSpringComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PhysicsSpringComponent.GetSpringRestingPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPhysicsSpringComponent::GetSpringRestingPoint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsSpringComponent", "GetSpringRestingPoint");

	Params::UPhysicsSpringComponent_GetSpringRestingPoint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PhysicsSpringComponent.GetSpringDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPhysicsSpringComponent::GetSpringDirection()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsSpringComponent", "GetSpringDirection");

	Params::UPhysicsSpringComponent_GetSpringDirection_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPhysicsSpringComponent::GetSpringCurrentEndPoint()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsSpringComponent", "GetSpringCurrentEndPoint");

	Params::UPhysicsSpringComponent_GetSpringCurrentEndPoint_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhysicsSpringComponent::GetNormalizedCompressionScalar()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PhysicsSpringComponent", "GetNormalizedCompressionScalar");

	Params::UPhysicsSpringComponent_GetNormalizedCompressionScalar_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.PhysicsThruster
// (Actor)

class UClass* APhysicsThruster::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsThruster");

	return Clss;
}


// PhysicsThruster Engine.Default__PhysicsThruster
// (Public, ClassDefaultObject, ArchetypeObject)

class APhysicsThruster* APhysicsThruster::GetDefaultObj()
{
	static class APhysicsThruster* Default = nullptr;

	if (!Default)
		Default = static_cast<APhysicsThruster*>(APhysicsThruster::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PhysicsThrusterComponent
// (SceneComponent)

class UClass* UPhysicsThrusterComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PhysicsThrusterComponent");

	return Clss;
}


// PhysicsThrusterComponent Engine.Default__PhysicsThrusterComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPhysicsThrusterComponent* UPhysicsThrusterComponent::GetDefaultObj()
{
	static class UPhysicsThrusterComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPhysicsThrusterComponent*>(UPhysicsThrusterComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SceneCapture
// (Actor)

class UClass* ASceneCapture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SceneCapture");

	return Clss;
}


// SceneCapture Engine.Default__SceneCapture
// (Public, ClassDefaultObject, ArchetypeObject)

class ASceneCapture* ASceneCapture::GetDefaultObj()
{
	static class ASceneCapture* Default = nullptr;

	if (!Default)
		Default = static_cast<ASceneCapture*>(ASceneCapture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PlanarReflection
// (Actor)

class UClass* APlanarReflection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlanarReflection");

	return Clss;
}


// PlanarReflection Engine.Default__PlanarReflection
// (Public, ClassDefaultObject, ArchetypeObject)

class APlanarReflection* APlanarReflection::GetDefaultObj()
{
	static class APlanarReflection* Default = nullptr;

	if (!Default)
		Default = static_cast<APlanarReflection*>(APlanarReflection::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PlanarReflection.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlanarReflection::OnInterpToggle(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlanarReflection", "OnInterpToggle");

	Params::APlanarReflection_OnInterpToggle_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PlanarReflectionComponent
// (SceneComponent)

class UClass* UPlanarReflectionComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlanarReflectionComponent");

	return Clss;
}


// PlanarReflectionComponent Engine.Default__PlanarReflectionComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlanarReflectionComponent* UPlanarReflectionComponent::GetDefaultObj()
{
	static class UPlanarReflectionComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlanarReflectionComponent*>(UPlanarReflectionComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PlaneReflectionCapture
// (Actor)

class UClass* APlaneReflectionCapture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlaneReflectionCapture");

	return Clss;
}


// PlaneReflectionCapture Engine.Default__PlaneReflectionCapture
// (Public, ClassDefaultObject, ArchetypeObject)

class APlaneReflectionCapture* APlaneReflectionCapture::GetDefaultObj()
{
	static class APlaneReflectionCapture* Default = nullptr;

	if (!Default)
		Default = static_cast<APlaneReflectionCapture*>(APlaneReflectionCapture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PlaneReflectionCaptureComponent
// (SceneComponent)

class UClass* UPlaneReflectionCaptureComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlaneReflectionCaptureComponent");

	return Clss;
}


// PlaneReflectionCaptureComponent Engine.Default__PlaneReflectionCaptureComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlaneReflectionCaptureComponent* UPlaneReflectionCaptureComponent::GetDefaultObj()
{
	static class UPlaneReflectionCaptureComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlaneReflectionCaptureComponent*>(UPlaneReflectionCaptureComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PlatformEventsComponent
// (None)

class UClass* UPlatformEventsComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlatformEventsComponent");

	return Clss;
}


// PlatformEventsComponent Engine.Default__PlatformEventsComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlatformEventsComponent* UPlatformEventsComponent::GetDefaultObj()
{
	static class UPlatformEventsComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlatformEventsComponent*>(UPlatformEventsComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformEventsComponent::SupportsConvertibleLaptops()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlatformEventsComponent", "SupportsConvertibleLaptops");

	Params::UPlatformEventsComponent_SupportsConvertibleLaptops_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// DelegateFunction Engine.PlatformEventsComponent.PlatformEventDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:

void UPlatformEventsComponent::PlatformEventDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlatformEventsComponent", "PlatformEventDelegate__DelegateSignature");



	UObject::ProcessEvent(Func, nullptr);

}


// Function Engine.PlatformEventsComponent.IsInTabletMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformEventsComponent::IsInTabletMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlatformEventsComponent", "IsInTabletMode");

	Params::UPlatformEventsComponent_IsInTabletMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlatformEventsComponent.IsInLaptopMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformEventsComponent::IsInLaptopMode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlatformEventsComponent", "IsInLaptopMode");

	Params::UPlatformEventsComponent_IsInLaptopMode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.PlatformInterfaceWebResponse
// (None)

class UClass* UPlatformInterfaceWebResponse::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlatformInterfaceWebResponse");

	return Clss;
}


// PlatformInterfaceWebResponse Engine.Default__PlatformInterfaceWebResponse
// (Public, ClassDefaultObject, ArchetypeObject)

class UPlatformInterfaceWebResponse* UPlatformInterfaceWebResponse::GetDefaultObj()
{
	static class UPlatformInterfaceWebResponse* Default = nullptr;

	if (!Default)
		Default = static_cast<UPlatformInterfaceWebResponse*>(UPlatformInterfaceWebResponse::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PlatformInterfaceWebResponse.GetNumHeaders
// (Native, Public)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlatformInterfaceWebResponse::GetNumHeaders()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlatformInterfaceWebResponse", "GetNumHeaders");

	Params::UPlatformInterfaceWebResponse_GetNumHeaders_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlatformInterfaceWebResponse.GetHeaderValue
// (Native, Public)
// Parameters:
// class FString                      HeaderName                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlatformInterfaceWebResponse::GetHeaderValue(const class FString& HeaderName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlatformInterfaceWebResponse", "GetHeaderValue");

	Params::UPlatformInterfaceWebResponse_GetHeaderValue_Params Parms{};

	Parms.HeaderName = HeaderName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PlatformInterfaceWebResponse.GetHeader
// (Native, Public, HasOutParams)
// Parameters:
// int32                              HeaderIndex                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Header                                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Value                                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatformInterfaceWebResponse::GetHeader(int32 HeaderIndex, class FString* Header, class FString* Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PlatformInterfaceWebResponse", "GetHeader");

	Params::UPlatformInterfaceWebResponse_GetHeader_Params Parms{};

	Parms.HeaderIndex = HeaderIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (Header != nullptr)
		*Header = std::move(Parms.Header);

	if (Value != nullptr)
		*Value = std::move(Parms.Value);

}


// Class Engine.PlayerStartPIE
// (Actor)

class UClass* APlayerStartPIE::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PlayerStartPIE");

	return Clss;
}


// PlayerStartPIE Engine.Default__PlayerStartPIE
// (Public, ClassDefaultObject, ArchetypeObject)

class APlayerStartPIE* APlayerStartPIE::GetDefaultObj()
{
	static class APlayerStartPIE* Default = nullptr;

	if (!Default)
		Default = static_cast<APlayerStartPIE*>(APlayerStartPIE::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PluginCommandlet
// (None)

class UClass* UPluginCommandlet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PluginCommandlet");

	return Clss;
}


// PluginCommandlet Engine.Default__PluginCommandlet
// (Public, ClassDefaultObject, ArchetypeObject)

class UPluginCommandlet* UPluginCommandlet::GetDefaultObj()
{
	static class UPluginCommandlet* Default = nullptr;

	if (!Default)
		Default = static_cast<UPluginCommandlet*>(UPluginCommandlet::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PointLight
// (Actor)

class UClass* APointLight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PointLight");

	return Clss;
}


// PointLight Engine.Default__PointLight
// (Public, ClassDefaultObject, ArchetypeObject)

class APointLight* APointLight::GetDefaultObj()
{
	static class APointLight* Default = nullptr;

	if (!Default)
		Default = static_cast<APointLight*>(APointLight::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PointLight.SetRadius
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewRadius                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APointLight::SetRadius(float NewRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PointLight", "SetRadius");

	Params::APointLight_SetRadius_Params Parms{};

	Parms.NewRadius = NewRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PointLight.SetLightFalloffExponent
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewLightFalloffExponent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APointLight::SetLightFalloffExponent(float NewLightFalloffExponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PointLight", "SetLightFalloffExponent");

	Params::APointLight_SetLightFalloffExponent_Params Parms{};

	Parms.NewLightFalloffExponent = NewLightFalloffExponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PointLightComponent
// (SceneComponent)

class UClass* UPointLightComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PointLightComponent");

	return Clss;
}


// PointLightComponent Engine.Default__PointLightComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPointLightComponent* UPointLightComponent::GetDefaultObj()
{
	static class UPointLightComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPointLightComponent*>(UPointLightComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PointLightComponent.SetSourceRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointLightComponent::SetSourceRadius(float bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PointLightComponent", "SetSourceRadius");

	Params::UPointLightComponent_SetSourceRadius_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PointLightComponent.SetSourceLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointLightComponent::SetSourceLength(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PointLightComponent", "SetSourceLength");

	Params::UPointLightComponent_SetSourceLength_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PointLightComponent.SetSoftSourceRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointLightComponent::SetSoftSourceRadius(float bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PointLightComponent", "SetSoftSourceRadius");

	Params::UPointLightComponent_SetSoftSourceRadius_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PointLightComponent.SetLightFalloffExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewLightFalloffExponent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointLightComponent::SetLightFalloffExponent(float NewLightFalloffExponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PointLightComponent", "SetLightFalloffExponent");

	Params::UPointLightComponent_SetLightFalloffExponent_Params Parms{};

	Parms.NewLightFalloffExponent = NewLightFalloffExponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.Polys
// (None)

class UClass* UPolys::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Polys");

	return Clss;
}


// Polys Engine.Default__Polys
// (Public, ClassDefaultObject, ArchetypeObject)

class UPolys* UPolys::GetDefaultObj()
{
	static class UPolys* Default = nullptr;

	if (!Default)
		Default = static_cast<UPolys*>(UPolys::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PoseableMeshComponent
// (SceneComponent, PrimitiveComponent, SkinnedMeshComponent)

class UClass* UPoseableMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PoseableMeshComponent");

	return Clss;
}


// PoseableMeshComponent Engine.Default__PoseableMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPoseableMeshComponent* UPoseableMeshComponent::GetDefaultObj()
{
	static class UPoseableMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPoseableMeshComponent*>(UPoseableMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PoseableMeshComponent.SetBoneTransformByName
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  InTransform                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// enum class EBoneSpaces             BoneSpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::SetBoneTransformByName(class FName BoneName, struct FTransform& InTransform, enum class EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "SetBoneTransformByName");

	Params::UPoseableMeshComponent_SetBoneTransformByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.InTransform = InTransform;
	Parms.BoneSpace = BoneSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PoseableMeshComponent.SetBoneScaleByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InScale3D                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBoneSpaces             BoneSpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::SetBoneScaleByName(class FName BoneName, const struct FVector& InScale3D, enum class EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "SetBoneScaleByName");

	Params::UPoseableMeshComponent_SetBoneScaleByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.InScale3D = InScale3D;
	Parms.BoneSpace = BoneSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PoseableMeshComponent.SetBoneRotationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    InRotation                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// enum class EBoneSpaces             BoneSpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::SetBoneRotationByName(class FName BoneName, const struct FRotator& InRotation, enum class EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "SetBoneRotationByName");

	Params::UPoseableMeshComponent_SetBoneRotationByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.InRotation = InRotation;
	Parms.BoneSpace = BoneSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PoseableMeshComponent.SetBoneLocationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     InLocation                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBoneSpaces             BoneSpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::SetBoneLocationByName(class FName BoneName, const struct FVector& InLocation, enum class EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "SetBoneLocationByName");

	Params::UPoseableMeshComponent_SetBoneLocationByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.InLocation = InLocation;
	Parms.BoneSpace = BoneSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PoseableMeshComponent.ResetBoneTransformByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::ResetBoneTransformByName(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "ResetBoneTransformByName");

	Params::UPoseableMeshComponent_ResetBoneTransformByName_Params Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.PoseableMeshComponent.GetBoneTransformByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBoneSpaces             BoneSpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  ReturnValue                                                      (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UPoseableMeshComponent::GetBoneTransformByName(class FName BoneName, enum class EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "GetBoneTransformByName");

	Params::UPoseableMeshComponent_GetBoneTransformByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.BoneSpace = BoneSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PoseableMeshComponent.GetBoneScaleByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBoneSpaces             BoneSpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPoseableMeshComponent::GetBoneScaleByName(class FName BoneName, enum class EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "GetBoneScaleByName");

	Params::UPoseableMeshComponent_GetBoneScaleByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.BoneSpace = BoneSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PoseableMeshComponent.GetBoneRotationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBoneSpaces             BoneSpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UPoseableMeshComponent::GetBoneRotationByName(class FName BoneName, enum class EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "GetBoneRotationByName");

	Params::UPoseableMeshComponent_GetBoneRotationByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.BoneSpace = BoneSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PoseableMeshComponent.GetBoneLocationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                        BoneName                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EBoneSpaces             BoneSpace                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPoseableMeshComponent::GetBoneLocationByName(class FName BoneName, enum class EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "GetBoneLocationByName");

	Params::UPoseableMeshComponent_GetBoneLocationByName_Params Parms{};

	Parms.BoneName = BoneName;
	Parms.BoneSpace = BoneSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.PoseableMeshComponent.CopyPoseFromSkeletalComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*      InComponentToCopy                                                (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::CopyPoseFromSkeletalComponent(class USkeletalMeshComponent* InComponentToCopy)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PoseableMeshComponent", "CopyPoseFromSkeletalComponent");

	Params::UPoseableMeshComponent_CopyPoseFromSkeletalComponent_Params Parms{};

	Parms.InComponentToCopy = InComponentToCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PoseAsset
// (None)

class UClass* UPoseAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PoseAsset");

	return Clss;
}


// PoseAsset Engine.Default__PoseAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class UPoseAsset* UPoseAsset::GetDefaultObj()
{
	static class UPoseAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<UPoseAsset*>(UPoseAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PoseWatch
// (None)

class UClass* UPoseWatch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PoseWatch");

	return Clss;
}


// PoseWatch Engine.Default__PoseWatch
// (Public, ClassDefaultObject, ArchetypeObject)

class UPoseWatch* UPoseWatch::GetDefaultObj()
{
	static class UPoseWatch* Default = nullptr;

	if (!Default)
		Default = static_cast<UPoseWatch*>(UPoseWatch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PostProcessComponent
// (SceneComponent)

class UClass* UPostProcessComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PostProcessComponent");

	return Clss;
}


// PostProcessComponent Engine.Default__PostProcessComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UPostProcessComponent* UPostProcessComponent::GetDefaultObj()
{
	static class UPostProcessComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UPostProcessComponent*>(UPostProcessComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PostProcessComponent.AddOrUpdateBlendable
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                              InWeight                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessComponent::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PostProcessComponent", "AddOrUpdateBlendable");

	Params::UPostProcessComponent_AddOrUpdateBlendable_Params Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PostProcessVolume
// (Actor)

class UClass* APostProcessVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PostProcessVolume");

	return Clss;
}


// PostProcessVolume Engine.Default__PostProcessVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class APostProcessVolume* APostProcessVolume::GetDefaultObj()
{
	static class APostProcessVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<APostProcessVolume*>(APostProcessVolume::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.PostProcessVolume.AddOrUpdateBlendable
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                              InWeight                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APostProcessVolume::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("PostProcessVolume", "AddOrUpdateBlendable");

	Params::APostProcessVolume_AddOrUpdateBlendable_Params Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.PrecomputedVisibilityOverrideVolume
// (Actor)

class UClass* APrecomputedVisibilityOverrideVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PrecomputedVisibilityOverrideVolume");

	return Clss;
}


// PrecomputedVisibilityOverrideVolume Engine.Default__PrecomputedVisibilityOverrideVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class APrecomputedVisibilityOverrideVolume* APrecomputedVisibilityOverrideVolume::GetDefaultObj()
{
	static class APrecomputedVisibilityOverrideVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<APrecomputedVisibilityOverrideVolume*>(APrecomputedVisibilityOverrideVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PrecomputedVisibilityVolume
// (Actor)

class UClass* APrecomputedVisibilityVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PrecomputedVisibilityVolume");

	return Clss;
}


// PrecomputedVisibilityVolume Engine.Default__PrecomputedVisibilityVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class APrecomputedVisibilityVolume* APrecomputedVisibilityVolume::GetDefaultObj()
{
	static class APrecomputedVisibilityVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<APrecomputedVisibilityVolume*>(APrecomputedVisibilityVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PreviewCollectionInterface
// (None)

class UClass* IPreviewCollectionInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PreviewCollectionInterface");

	return Clss;
}


// PreviewCollectionInterface Engine.Default__PreviewCollectionInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IPreviewCollectionInterface* IPreviewCollectionInterface::GetDefaultObj()
{
	static class IPreviewCollectionInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IPreviewCollectionInterface*>(IPreviewCollectionInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PreviewMeshCollection
// (None)

class UClass* UPreviewMeshCollection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PreviewMeshCollection");

	return Clss;
}


// PreviewMeshCollection Engine.Default__PreviewMeshCollection
// (Public, ClassDefaultObject, ArchetypeObject)

class UPreviewMeshCollection* UPreviewMeshCollection::GetDefaultObj()
{
	static class UPreviewMeshCollection* Default = nullptr;

	if (!Default)
		Default = static_cast<UPreviewMeshCollection*>(UPreviewMeshCollection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.PrimaryAssetLabel
// (None)

class UClass* UPrimaryAssetLabel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("PrimaryAssetLabel");

	return Clss;
}


// PrimaryAssetLabel Engine.Default__PrimaryAssetLabel
// (Public, ClassDefaultObject, ArchetypeObject)

class UPrimaryAssetLabel* UPrimaryAssetLabel::GetDefaultObj()
{
	static class UPrimaryAssetLabel* Default = nullptr;

	if (!Default)
		Default = static_cast<UPrimaryAssetLabel*>(UPrimaryAssetLabel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ProxyLODMeshSimplificationSettings
// (None)

class UClass* UProxyLODMeshSimplificationSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ProxyLODMeshSimplificationSettings");

	return Clss;
}


// ProxyLODMeshSimplificationSettings Engine.Default__ProxyLODMeshSimplificationSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UProxyLODMeshSimplificationSettings* UProxyLODMeshSimplificationSettings::GetDefaultObj()
{
	static class UProxyLODMeshSimplificationSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UProxyLODMeshSimplificationSettings*>(UProxyLODMeshSimplificationSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.RadialForceActor
// (Actor)

class UClass* ARadialForceActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RadialForceActor");

	return Clss;
}


// RadialForceActor Engine.Default__RadialForceActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ARadialForceActor* ARadialForceActor::GetDefaultObj()
{
	static class ARadialForceActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ARadialForceActor*>(ARadialForceActor::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.RadialForceActor.ToggleForce
// (Native, Public, BlueprintCallable)
// Parameters:

void ARadialForceActor::ToggleForce()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadialForceActor", "ToggleForce");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RadialForceActor.FireImpulse
// (Native, Public, BlueprintCallable)
// Parameters:

void ARadialForceActor::FireImpulse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadialForceActor", "FireImpulse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RadialForceActor.EnableForce
// (Native, Public, BlueprintCallable)
// Parameters:

void ARadialForceActor::EnableForce()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadialForceActor", "EnableForce");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RadialForceActor.DisableForce
// (Native, Public, BlueprintCallable)
// Parameters:

void ARadialForceActor::DisableForce()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadialForceActor", "DisableForce");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.RadialForceComponent
// (SceneComponent)

class UClass* URadialForceComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RadialForceComponent");

	return Clss;
}


// RadialForceComponent Engine.Default__RadialForceComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class URadialForceComponent* URadialForceComponent::GetDefaultObj()
{
	static class URadialForceComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<URadialForceComponent*>(URadialForceComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.RadialForceComponent.RemoveObjectTypeToAffect
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EObjectTypeQuery        ObjectType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialForceComponent::RemoveObjectTypeToAffect(enum class EObjectTypeQuery ObjectType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadialForceComponent", "RemoveObjectTypeToAffect");

	Params::URadialForceComponent_RemoveObjectTypeToAffect_Params Parms{};

	Parms.ObjectType = ObjectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RadialForceComponent.FireImpulse
// (Native, Public, BlueprintCallable)
// Parameters:

void URadialForceComponent::FireImpulse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadialForceComponent", "FireImpulse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RadialForceComponent.AddObjectTypeToAffect
// (Native, Public, BlueprintCallable)
// Parameters:
// enum class EObjectTypeQuery        ObjectType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialForceComponent::AddObjectTypeToAffect(enum class EObjectTypeQuery ObjectType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RadialForceComponent", "AddObjectTypeToAffect");

	Params::URadialForceComponent_AddObjectTypeToAffect_Params Parms{};

	Parms.ObjectType = ObjectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.RectLight
// (Actor)

class UClass* ARectLight::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RectLight");

	return Clss;
}


// RectLight Engine.Default__RectLight
// (Public, ClassDefaultObject, ArchetypeObject)

class ARectLight* ARectLight::GetDefaultObj()
{
	static class ARectLight* Default = nullptr;

	if (!Default)
		Default = static_cast<ARectLight*>(ARectLight::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.RectLightComponent
// (SceneComponent)

class UClass* URectLightComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RectLightComponent");

	return Clss;
}


// RectLightComponent Engine.Default__RectLightComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class URectLightComponent* URectLightComponent::GetDefaultObj()
{
	static class URectLightComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<URectLightComponent*>(URectLightComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.RectLightComponent.SetSourceWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetSourceWidth(float bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RectLightComponent", "SetSourceWidth");

	Params::URectLightComponent_SetSourceWidth_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RectLightComponent.SetSourceTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                    bNewValue                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetSourceTexture(class UTexture* bNewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RectLightComponent", "SetSourceTexture");

	Params::URectLightComponent_SetSourceTexture_Params Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RectLightComponent.SetSourceHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetSourceHeight(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RectLightComponent", "SetSourceHeight");

	Params::URectLightComponent_SetSourceHeight_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RectLightComponent.SetBarnDoorLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetBarnDoorLength(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RectLightComponent", "SetBarnDoorLength");

	Params::URectLightComponent_SetBarnDoorLength_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.RectLightComponent.SetBarnDoorAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewValue                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetBarnDoorAngle(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("RectLightComponent", "SetBarnDoorAngle");

	Params::URectLightComponent_SetBarnDoorAngle_Params Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.RendererSettings
// (None)

class UClass* URendererSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RendererSettings");

	return Clss;
}


// RendererSettings Engine.Default__RendererSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class URendererSettings* URendererSettings::GetDefaultObj()
{
	static class URendererSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<URendererSettings*>(URendererSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.RendererOverrideSettings
// (None)

class UClass* URendererOverrideSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RendererOverrideSettings");

	return Clss;
}


// RendererOverrideSettings Engine.Default__RendererOverrideSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class URendererOverrideSettings* URendererOverrideSettings::GetDefaultObj()
{
	static class URendererOverrideSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<URendererOverrideSettings*>(URendererOverrideSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ReporterBase
// (None)

class UClass* UReporterBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReporterBase");

	return Clss;
}


// ReporterBase Engine.Default__ReporterBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UReporterBase* UReporterBase::GetDefaultObj()
{
	static class UReporterBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UReporterBase*>(UReporterBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ReporterGraph
// (None)

class UClass* UReporterGraph::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReporterGraph");

	return Clss;
}


// ReporterGraph Engine.Default__ReporterGraph
// (Public, ClassDefaultObject, ArchetypeObject)

class UReporterGraph* UReporterGraph::GetDefaultObj()
{
	static class UReporterGraph* Default = nullptr;

	if (!Default)
		Default = static_cast<UReporterGraph*>(UReporterGraph::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ReverbEffect
// (None)

class UClass* UReverbEffect::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ReverbEffect");

	return Clss;
}


// ReverbEffect Engine.Default__ReverbEffect
// (Public, ClassDefaultObject, ArchetypeObject)

class UReverbEffect* UReverbEffect::GetDefaultObj()
{
	static class UReverbEffect* Default = nullptr;

	if (!Default)
		Default = static_cast<UReverbEffect*>(UReverbEffect::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Rig
// (None)

class UClass* URig::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Rig");

	return Clss;
}


// Rig Engine.Default__Rig
// (Public, ClassDefaultObject, ArchetypeObject)

class URig* URig::GetDefaultObj()
{
	static class URig* Default = nullptr;

	if (!Default)
		Default = static_cast<URig*>(URig::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.RotatingMovementComponent
// (None)

class UClass* URotatingMovementComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RotatingMovementComponent");

	return Clss;
}


// RotatingMovementComponent Engine.Default__RotatingMovementComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class URotatingMovementComponent* URotatingMovementComponent::GetDefaultObj()
{
	static class URotatingMovementComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<URotatingMovementComponent*>(URotatingMovementComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.RVOAvoidanceInterface
// (None)

class UClass* IRVOAvoidanceInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("RVOAvoidanceInterface");

	return Clss;
}


// RVOAvoidanceInterface Engine.Default__RVOAvoidanceInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IRVOAvoidanceInterface* IRVOAvoidanceInterface::GetDefaultObj()
{
	static class IRVOAvoidanceInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IRVOAvoidanceInterface*>(IRVOAvoidanceInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SaveGame
// (None)

class UClass* USaveGame::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SaveGame");

	return Clss;
}


// SaveGame Engine.Default__SaveGame
// (Public, ClassDefaultObject, ArchetypeObject)

class USaveGame* USaveGame::GetDefaultObj()
{
	static class USaveGame* Default = nullptr;

	if (!Default)
		Default = static_cast<USaveGame*>(USaveGame::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Scene
// (None)

class UClass* UScene::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Scene");

	return Clss;
}


// Scene Engine.Default__Scene
// (Public, ClassDefaultObject, ArchetypeObject)

class UScene* UScene::GetDefaultObj()
{
	static class UScene* Default = nullptr;

	if (!Default)
		Default = static_cast<UScene*>(UScene::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SceneCapture2D
// (Actor)

class UClass* ASceneCapture2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SceneCapture2D");

	return Clss;
}


// SceneCapture2D Engine.Default__SceneCapture2D
// (Public, ClassDefaultObject, ArchetypeObject)

class ASceneCapture2D* ASceneCapture2D::GetDefaultObj()
{
	static class ASceneCapture2D* Default = nullptr;

	if (!Default)
		Default = static_cast<ASceneCapture2D*>(ASceneCapture2D::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SceneCapture2D.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASceneCapture2D::OnInterpToggle(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCapture2D", "OnInterpToggle");

	Params::ASceneCapture2D_OnInterpToggle_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SceneCaptureComponentCube
// (SceneComponent)

class UClass* USceneCaptureComponentCube::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SceneCaptureComponentCube");

	return Clss;
}


// SceneCaptureComponentCube Engine.Default__SceneCaptureComponentCube
// (Public, ClassDefaultObject, ArchetypeObject)

class USceneCaptureComponentCube* USceneCaptureComponentCube::GetDefaultObj()
{
	static class USceneCaptureComponentCube* Default = nullptr;

	if (!Default)
		Default = static_cast<USceneCaptureComponentCube*>(USceneCaptureComponentCube::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SceneCaptureComponentCube.CaptureScene
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USceneCaptureComponentCube::CaptureScene()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureComponentCube", "CaptureScene");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SceneCaptureCube
// (Actor)

class UClass* ASceneCaptureCube::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SceneCaptureCube");

	return Clss;
}


// SceneCaptureCube Engine.Default__SceneCaptureCube
// (Public, ClassDefaultObject, ArchetypeObject)

class ASceneCaptureCube* ASceneCaptureCube::GetDefaultObj()
{
	static class ASceneCaptureCube* Default = nullptr;

	if (!Default)
		Default = static_cast<ASceneCaptureCube*>(ASceneCaptureCube::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SceneCaptureCube.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bEnable                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASceneCaptureCube::OnInterpToggle(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SceneCaptureCube", "OnInterpToggle");

	Params::ASceneCaptureCube_OnInterpToggle_Params Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SCS_Node
// (None)

class UClass* USCS_Node::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SCS_Node");

	return Clss;
}


// SCS_Node Engine.Default__SCS_Node
// (Public, ClassDefaultObject, ArchetypeObject)

class USCS_Node* USCS_Node::GetDefaultObj()
{
	static class USCS_Node* Default = nullptr;

	if (!Default)
		Default = static_cast<USCS_Node*>(USCS_Node::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.Selection
// (None)

class UClass* USelection::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Selection");

	return Clss;
}


// Selection Engine.Default__Selection
// (Public, ClassDefaultObject, ArchetypeObject)

class USelection* USelection::GetDefaultObj()
{
	static class USelection* Default = nullptr;

	if (!Default)
		Default = static_cast<USelection*>(USelection::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ServerStatReplicator
// (Actor)

class UClass* AServerStatReplicator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ServerStatReplicator");

	return Clss;
}


// ServerStatReplicator Engine.Default__ServerStatReplicator
// (Public, ClassDefaultObject, ArchetypeObject)

class AServerStatReplicator* AServerStatReplicator::GetDefaultObj()
{
	static class AServerStatReplicator* Default = nullptr;

	if (!Default)
		Default = static_cast<AServerStatReplicator*>(AServerStatReplicator::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ShadowMapTexture2D
// (None)

class UClass* UShadowMapTexture2D::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ShadowMapTexture2D");

	return Clss;
}


// ShadowMapTexture2D Engine.Default__ShadowMapTexture2D
// (Public, ClassDefaultObject, ArchetypeObject)

class UShadowMapTexture2D* UShadowMapTexture2D::GetDefaultObj()
{
	static class UShadowMapTexture2D* Default = nullptr;

	if (!Default)
		Default = static_cast<UShadowMapTexture2D*>(UShadowMapTexture2D::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SimpleConstructionScript
// (None)

class UClass* USimpleConstructionScript::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SimpleConstructionScript");

	return Clss;
}


// SimpleConstructionScript Engine.Default__SimpleConstructionScript
// (Public, ClassDefaultObject, ArchetypeObject)

class USimpleConstructionScript* USimpleConstructionScript::GetDefaultObj()
{
	static class USimpleConstructionScript* Default = nullptr;

	if (!Default)
		Default = static_cast<USimpleConstructionScript*>(USimpleConstructionScript::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SkeletalMesh
// (None)

class UClass* USkeletalMesh::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkeletalMesh");

	return Clss;
}


// SkeletalMesh Engine.Default__SkeletalMesh
// (Public, ClassDefaultObject, ArchetypeObject)

class USkeletalMesh* USkeletalMesh::GetDefaultObj()
{
	static class USkeletalMesh* Default = nullptr;

	if (!Default)
		Default = static_cast<USkeletalMesh*>(USkeletalMesh::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SkeletalMesh.SetLODSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshLODSettings*    InLODSettings                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMesh::SetLODSettings(class USkeletalMeshLODSettings* InLODSettings)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "SetLODSettings");

	Params::USkeletalMesh_SetLODSettings_Params Parms{};

	Parms.InLODSettings = InLODSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMesh.NumSockets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkeletalMesh::NumSockets()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "NumSockets");

	Params::USkeletalMesh_NumSockets_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMesh.IsSectionUsingCloth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              InSectionIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bCheckCorrespondingSections                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMesh::IsSectionUsingCloth(int32 InSectionIndex, bool bCheckCorrespondingSections)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "IsSectionUsingCloth");

	Params::USkeletalMesh_IsSectionUsingCloth_Params Parms{};

	Parms.InSectionIndex = InSectionIndex;
	Parms.bCheckCorrespondingSections = bCheckCorrespondingSections;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMesh.GetSocketByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              Index                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshSocket*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshSocket* USkeletalMesh::GetSocketByIndex(int32 Index)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "GetSocketByIndex");

	Params::USkeletalMesh_GetSocketByIndex_Params Parms{};

	Parms.Index = Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMesh.GetNodeMappingContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlueprint*                  SourceAsset                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNodeMappingContainer*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNodeMappingContainer* USkeletalMesh::GetNodeMappingContainer(class UBlueprint* SourceAsset)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "GetNodeMappingContainer");

	Params::USkeletalMesh_GetNodeMappingContainer_Params Parms{};

	Parms.SourceAsset = SourceAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMesh.GetImportedBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds USkeletalMesh::GetImportedBounds()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "GetImportedBounds");

	Params::USkeletalMesh_GetImportedBounds_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMesh.GetBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds USkeletalMesh::GetBounds()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "GetBounds");

	Params::USkeletalMesh_GetBounds_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMesh.FindSocketInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                  OutTransform                                                     (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                              OutBoneIndex                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OutIndex                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshSocket*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshSocket* USkeletalMesh::FindSocketInfo(class FName InSocketName, struct FTransform* OutTransform, int32* OutBoneIndex, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "FindSocketInfo");

	Params::USkeletalMesh_FindSocketInfo_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	if (OutBoneIndex != nullptr)
		*OutBoneIndex = Parms.OutBoneIndex;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMesh.FindSocketAndIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              OutIndex                                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshSocket*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshSocket* USkeletalMesh::FindSocketAndIndex(class FName InSocketName, int32* OutIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "FindSocketAndIndex");

	Params::USkeletalMesh_FindSocketAndIndex_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	return Parms.ReturnValue;

}


// Function Engine.SkeletalMesh.FindSocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshSocket*         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshSocket* USkeletalMesh::FindSocket(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMesh", "FindSocket");

	Params::USkeletalMesh_FindSocket_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.SkeletalMeshLODSettings
// (None)

class UClass* USkeletalMeshLODSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkeletalMeshLODSettings");

	return Clss;
}


// SkeletalMeshLODSettings Engine.Default__SkeletalMeshLODSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class USkeletalMeshLODSettings* USkeletalMeshLODSettings::GetDefaultObj()
{
	static class USkeletalMeshLODSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<USkeletalMeshLODSettings*>(USkeletalMeshLODSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SkeletalMeshSimplificationSettings
// (None)

class UClass* USkeletalMeshSimplificationSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkeletalMeshSimplificationSettings");

	return Clss;
}


// SkeletalMeshSimplificationSettings Engine.Default__SkeletalMeshSimplificationSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class USkeletalMeshSimplificationSettings* USkeletalMeshSimplificationSettings::GetDefaultObj()
{
	static class USkeletalMeshSimplificationSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<USkeletalMeshSimplificationSettings*>(USkeletalMeshSimplificationSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SkeletalMeshSocket
// (None)

class UClass* USkeletalMeshSocket::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkeletalMeshSocket");

	return Clss;
}


// SkeletalMeshSocket Engine.Default__SkeletalMeshSocket
// (Public, ClassDefaultObject, ArchetypeObject)

class USkeletalMeshSocket* USkeletalMeshSocket::GetDefaultObj()
{
	static class USkeletalMeshSocket* Default = nullptr;

	if (!Default)
		Default = static_cast<USkeletalMeshSocket*>(USkeletalMeshSocket::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*      SkelComp                                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldLocation                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     WorldNormal                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshSocket::InitializeSocketFromLocation(class USkeletalMeshComponent* SkelComp, const struct FVector& WorldLocation, const struct FVector& WorldNormal)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshSocket", "InitializeSocketFromLocation");

	Params::USkeletalMeshSocket_InitializeSocketFromLocation_Params Parms{};

	Parms.SkelComp = SkelComp;
	Parms.WorldLocation = WorldLocation;
	Parms.WorldNormal = WorldNormal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkeletalMeshSocket.GetSocketLocation
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*      SkelComp                                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USkeletalMeshSocket::GetSocketLocation(class USkeletalMeshComponent* SkelComp)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkeletalMeshSocket", "GetSocketLocation");

	Params::USkeletalMeshSocket_GetSocketLocation_Params Parms{};

	Parms.SkelComp = SkelComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.SkyLightComponent
// (SceneComponent)

class UClass* USkyLightComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SkyLightComponent");

	return Clss;
}


// SkyLightComponent Engine.Default__SkyLightComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USkyLightComponent* USkyLightComponent::GetDefaultObj()
{
	static class USkyLightComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USkyLightComponent*>(USkyLightComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SkyLightComponent.SetVolumetricScatteringIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewIntensity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetVolumetricScatteringIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetVolumetricScatteringIntensity");

	Params::USkyLightComponent_SetVolumetricScatteringIntensity_Params Parms{};

	Parms.NewIntensity = NewIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetOcclusionTint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                      InTint                                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetOcclusionTint(struct FColor& InTint)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetOcclusionTint");

	Params::USkyLightComponent_SetOcclusionTint_Params Parms{};

	Parms.InTint = InTint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetOcclusionExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InOcclusionExponent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetOcclusionExponent(float InOcclusionExponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetOcclusionExponent");

	Params::USkyLightComponent_SetOcclusionExponent_Params Parms{};

	Parms.InOcclusionExponent = InOcclusionExponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetOcclusionContrast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InOcclusionContrast                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetOcclusionContrast(float InOcclusionContrast)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetOcclusionContrast");

	Params::USkyLightComponent_SetOcclusionContrast_Params Parms{};

	Parms.InOcclusionContrast = InOcclusionContrast;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetMinOcclusion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InMinOcclusion                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetMinOcclusion(float InMinOcclusion)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetMinOcclusion");

	Params::USkyLightComponent_SetMinOcclusion_Params Parms{};

	Parms.InMinOcclusion = InMinOcclusion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetLowerHemisphereColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                InLowerHemisphereColor                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetLowerHemisphereColor(struct FLinearColor& InLowerHemisphereColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetLowerHemisphereColor");

	Params::USkyLightComponent_SetLowerHemisphereColor_Params Parms{};

	Parms.InLowerHemisphereColor = InLowerHemisphereColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                NewLightColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetLightColor(const struct FLinearColor& NewLightColor)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetLightColor");

	Params::USkyLightComponent_SetLightColor_Params Parms{};

	Parms.NewLightColor = NewLightColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewIntensity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetIntensity");

	Params::USkyLightComponent_SetIntensity_Params Parms{};

	Parms.NewIntensity = NewIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetIndirectLightingIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewIntensity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetIndirectLightingIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetIndirectLightingIntensity");

	Params::USkyLightComponent_SetIndirectLightingIntensity_Params Parms{};

	Parms.NewIntensity = NewIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetCubemapBlend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureCube*                SourceCubemap                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureCube*                DestinationCubemap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              InBlendFraction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetCubemapBlend(class UTextureCube* SourceCubemap, class UTextureCube* DestinationCubemap, float InBlendFraction)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetCubemapBlend");

	Params::USkyLightComponent_SetCubemapBlend_Params Parms{};

	Parms.SourceCubemap = SourceCubemap;
	Parms.DestinationCubemap = DestinationCubemap;
	Parms.InBlendFraction = InBlendFraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.SetCubemap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureCube*                NewCubemap                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetCubemap(class UTextureCube* NewCubemap)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "SetCubemap");

	Params::USkyLightComponent_SetCubemap_Params Parms{};

	Parms.NewCubemap = NewCubemap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SkyLightComponent.RecaptureSky
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USkyLightComponent::RecaptureSky()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SkyLightComponent", "RecaptureSky");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SlateBrushAsset
// (None)

class UClass* USlateBrushAsset::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SlateBrushAsset");

	return Clss;
}


// SlateBrushAsset Engine.Default__SlateBrushAsset
// (Public, ClassDefaultObject, ArchetypeObject)

class USlateBrushAsset* USlateBrushAsset::GetDefaultObj()
{
	static class USlateBrushAsset* Default = nullptr;

	if (!Default)
		Default = static_cast<USlateBrushAsset*>(USlateBrushAsset::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SlateTextureAtlasInterface
// (None)

class UClass* ISlateTextureAtlasInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SlateTextureAtlasInterface");

	return Clss;
}


// SlateTextureAtlasInterface Engine.Default__SlateTextureAtlasInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class ISlateTextureAtlasInterface* ISlateTextureAtlasInterface::GetDefaultObj()
{
	static class ISlateTextureAtlasInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<ISlateTextureAtlasInterface*>(ISlateTextureAtlasInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SmokeTestCommandlet
// (None)

class UClass* USmokeTestCommandlet::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SmokeTestCommandlet");

	return Clss;
}


// SmokeTestCommandlet Engine.Default__SmokeTestCommandlet
// (Public, ClassDefaultObject, ArchetypeObject)

class USmokeTestCommandlet* USmokeTestCommandlet::GetDefaultObj()
{
	static class USmokeTestCommandlet* Default = nullptr;

	if (!Default)
		Default = static_cast<USmokeTestCommandlet*>(USmokeTestCommandlet::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundAttenuation
// (None)

class UClass* USoundAttenuation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundAttenuation");

	return Clss;
}


// SoundAttenuation Engine.Default__SoundAttenuation
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundAttenuation* USoundAttenuation::GetDefaultObj()
{
	static class USoundAttenuation* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundAttenuation*>(USoundAttenuation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundClass
// (None)

class UClass* USoundClass::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundClass");

	return Clss;
}


// SoundClass Engine.Default__SoundClass
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundClass* USoundClass::GetDefaultObj()
{
	static class USoundClass* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundClass*>(USoundClass::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundConcurrency
// (None)

class UClass* USoundConcurrency::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundConcurrency");

	return Clss;
}


// SoundConcurrency Engine.Default__SoundConcurrency
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundConcurrency* USoundConcurrency::GetDefaultObj()
{
	static class USoundConcurrency* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundConcurrency*>(USoundConcurrency::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundCue
// (None)

class UClass* USoundCue::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundCue");

	return Clss;
}


// SoundCue Engine.Default__SoundCue
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundCue* USoundCue::GetDefaultObj()
{
	static class USoundCue* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundCue*>(USoundCue::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundEffectSourcePresetChain
// (None)

class UClass* USoundEffectSourcePresetChain::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundEffectSourcePresetChain");

	return Clss;
}


// SoundEffectSourcePresetChain Engine.Default__SoundEffectSourcePresetChain
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundEffectSourcePresetChain* USoundEffectSourcePresetChain::GetDefaultObj()
{
	static class USoundEffectSourcePresetChain* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundEffectSourcePresetChain*>(USoundEffectSourcePresetChain::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundGroups
// (None)

class UClass* USoundGroups::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundGroups");

	return Clss;
}


// SoundGroups Engine.Default__SoundGroups
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundGroups* USoundGroups::GetDefaultObj()
{
	static class USoundGroups* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundGroups*>(USoundGroups::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundMix
// (None)

class UClass* USoundMix::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundMix");

	return Clss;
}


// SoundMix Engine.Default__SoundMix
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundMix* USoundMix::GetDefaultObj()
{
	static class USoundMix* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundMix*>(USoundMix::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNode
// (None)

class UClass* USoundNode::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNode");

	return Clss;
}


// SoundNode Engine.Default__SoundNode
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNode* USoundNode::GetDefaultObj()
{
	static class USoundNode* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNode*>(USoundNode::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeAssetReferencer
// (None)

class UClass* USoundNodeAssetReferencer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeAssetReferencer");

	return Clss;
}


// SoundNodeAssetReferencer Engine.Default__SoundNodeAssetReferencer
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeAssetReferencer* USoundNodeAssetReferencer::GetDefaultObj()
{
	static class USoundNodeAssetReferencer* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeAssetReferencer*>(USoundNodeAssetReferencer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeAttenuation
// (None)

class UClass* USoundNodeAttenuation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeAttenuation");

	return Clss;
}


// SoundNodeAttenuation Engine.Default__SoundNodeAttenuation
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeAttenuation* USoundNodeAttenuation::GetDefaultObj()
{
	static class USoundNodeAttenuation* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeAttenuation*>(USoundNodeAttenuation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeBranch
// (None)

class UClass* USoundNodeBranch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeBranch");

	return Clss;
}


// SoundNodeBranch Engine.Default__SoundNodeBranch
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeBranch* USoundNodeBranch::GetDefaultObj()
{
	static class USoundNodeBranch* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeBranch*>(USoundNodeBranch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeConcatenator
// (None)

class UClass* USoundNodeConcatenator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeConcatenator");

	return Clss;
}


// SoundNodeConcatenator Engine.Default__SoundNodeConcatenator
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeConcatenator* USoundNodeConcatenator::GetDefaultObj()
{
	static class USoundNodeConcatenator* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeConcatenator*>(USoundNodeConcatenator::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeDelay
// (None)

class UClass* USoundNodeDelay::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeDelay");

	return Clss;
}


// SoundNodeDelay Engine.Default__SoundNodeDelay
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeDelay* USoundNodeDelay::GetDefaultObj()
{
	static class USoundNodeDelay* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeDelay*>(USoundNodeDelay::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeDialoguePlayer
// (None)

class UClass* USoundNodeDialoguePlayer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeDialoguePlayer");

	return Clss;
}


// SoundNodeDialoguePlayer Engine.Default__SoundNodeDialoguePlayer
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeDialoguePlayer* USoundNodeDialoguePlayer::GetDefaultObj()
{
	static class USoundNodeDialoguePlayer* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeDialoguePlayer*>(USoundNodeDialoguePlayer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeDistanceCrossFade
// (None)

class UClass* USoundNodeDistanceCrossFade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeDistanceCrossFade");

	return Clss;
}


// SoundNodeDistanceCrossFade Engine.Default__SoundNodeDistanceCrossFade
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeDistanceCrossFade* USoundNodeDistanceCrossFade::GetDefaultObj()
{
	static class USoundNodeDistanceCrossFade* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeDistanceCrossFade*>(USoundNodeDistanceCrossFade::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeDoppler
// (None)

class UClass* USoundNodeDoppler::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeDoppler");

	return Clss;
}


// SoundNodeDoppler Engine.Default__SoundNodeDoppler
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeDoppler* USoundNodeDoppler::GetDefaultObj()
{
	static class USoundNodeDoppler* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeDoppler*>(USoundNodeDoppler::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeEnveloper
// (None)

class UClass* USoundNodeEnveloper::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeEnveloper");

	return Clss;
}


// SoundNodeEnveloper Engine.Default__SoundNodeEnveloper
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeEnveloper* USoundNodeEnveloper::GetDefaultObj()
{
	static class USoundNodeEnveloper* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeEnveloper*>(USoundNodeEnveloper::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeGroupControl
// (None)

class UClass* USoundNodeGroupControl::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeGroupControl");

	return Clss;
}


// SoundNodeGroupControl Engine.Default__SoundNodeGroupControl
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeGroupControl* USoundNodeGroupControl::GetDefaultObj()
{
	static class USoundNodeGroupControl* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeGroupControl*>(USoundNodeGroupControl::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeLooping
// (None)

class UClass* USoundNodeLooping::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeLooping");

	return Clss;
}


// SoundNodeLooping Engine.Default__SoundNodeLooping
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeLooping* USoundNodeLooping::GetDefaultObj()
{
	static class USoundNodeLooping* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeLooping*>(USoundNodeLooping::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeMature
// (None)

class UClass* USoundNodeMature::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeMature");

	return Clss;
}


// SoundNodeMature Engine.Default__SoundNodeMature
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeMature* USoundNodeMature::GetDefaultObj()
{
	static class USoundNodeMature* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeMature*>(USoundNodeMature::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeMixer
// (None)

class UClass* USoundNodeMixer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeMixer");

	return Clss;
}


// SoundNodeMixer Engine.Default__SoundNodeMixer
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeMixer* USoundNodeMixer::GetDefaultObj()
{
	static class USoundNodeMixer* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeMixer*>(USoundNodeMixer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeModulator
// (None)

class UClass* USoundNodeModulator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeModulator");

	return Clss;
}


// SoundNodeModulator Engine.Default__SoundNodeModulator
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeModulator* USoundNodeModulator::GetDefaultObj()
{
	static class USoundNodeModulator* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeModulator*>(USoundNodeModulator::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeModulatorContinuous
// (None)

class UClass* USoundNodeModulatorContinuous::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeModulatorContinuous");

	return Clss;
}


// SoundNodeModulatorContinuous Engine.Default__SoundNodeModulatorContinuous
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeModulatorContinuous* USoundNodeModulatorContinuous::GetDefaultObj()
{
	static class USoundNodeModulatorContinuous* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeModulatorContinuous*>(USoundNodeModulatorContinuous::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeOscillator
// (None)

class UClass* USoundNodeOscillator::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeOscillator");

	return Clss;
}


// SoundNodeOscillator Engine.Default__SoundNodeOscillator
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeOscillator* USoundNodeOscillator::GetDefaultObj()
{
	static class USoundNodeOscillator* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeOscillator*>(USoundNodeOscillator::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeParamCrossFade
// (None)

class UClass* USoundNodeParamCrossFade::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeParamCrossFade");

	return Clss;
}


// SoundNodeParamCrossFade Engine.Default__SoundNodeParamCrossFade
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeParamCrossFade* USoundNodeParamCrossFade::GetDefaultObj()
{
	static class USoundNodeParamCrossFade* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeParamCrossFade*>(USoundNodeParamCrossFade::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeQualityLevel
// (None)

class UClass* USoundNodeQualityLevel::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeQualityLevel");

	return Clss;
}


// SoundNodeQualityLevel Engine.Default__SoundNodeQualityLevel
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeQualityLevel* USoundNodeQualityLevel::GetDefaultObj()
{
	static class USoundNodeQualityLevel* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeQualityLevel*>(USoundNodeQualityLevel::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeRandom
// (None)

class UClass* USoundNodeRandom::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeRandom");

	return Clss;
}


// SoundNodeRandom Engine.Default__SoundNodeRandom
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeRandom* USoundNodeRandom::GetDefaultObj()
{
	static class USoundNodeRandom* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeRandom*>(USoundNodeRandom::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeSoundClass
// (None)

class UClass* USoundNodeSoundClass::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeSoundClass");

	return Clss;
}


// SoundNodeSoundClass Engine.Default__SoundNodeSoundClass
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeSoundClass* USoundNodeSoundClass::GetDefaultObj()
{
	static class USoundNodeSoundClass* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeSoundClass*>(USoundNodeSoundClass::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeSwitch
// (None)

class UClass* USoundNodeSwitch::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeSwitch");

	return Clss;
}


// SoundNodeSwitch Engine.Default__SoundNodeSwitch
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeSwitch* USoundNodeSwitch::GetDefaultObj()
{
	static class USoundNodeSwitch* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeSwitch*>(USoundNodeSwitch::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeWaveParam
// (None)

class UClass* USoundNodeWaveParam::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeWaveParam");

	return Clss;
}


// SoundNodeWaveParam Engine.Default__SoundNodeWaveParam
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeWaveParam* USoundNodeWaveParam::GetDefaultObj()
{
	static class USoundNodeWaveParam* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeWaveParam*>(USoundNodeWaveParam::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundNodeWavePlayer
// (None)

class UClass* USoundNodeWavePlayer::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundNodeWavePlayer");

	return Clss;
}


// SoundNodeWavePlayer Engine.Default__SoundNodeWavePlayer
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundNodeWavePlayer* USoundNodeWavePlayer::GetDefaultObj()
{
	static class USoundNodeWavePlayer* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundNodeWavePlayer*>(USoundNodeWavePlayer::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundSourceBus
// (None)

class UClass* USoundSourceBus::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundSourceBus");

	return Clss;
}


// SoundSourceBus Engine.Default__SoundSourceBus
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundSourceBus* USoundSourceBus::GetDefaultObj()
{
	static class USoundSourceBus* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundSourceBus*>(USoundSourceBus::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SoundSubmix
// (None)

class UClass* USoundSubmix::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SoundSubmix");

	return Clss;
}


// SoundSubmix Engine.Default__SoundSubmix
// (Public, ClassDefaultObject, ArchetypeObject)

class USoundSubmix* USoundSubmix::GetDefaultObj()
{
	static class USoundSubmix* Default = nullptr;

	if (!Default)
		Default = static_cast<USoundSubmix*>(USoundSubmix::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SoundSubmix.StopRecordingOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// enum class EAudioRecordingExportTypeExportType                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Name                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Path                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                  ExistingSoundWaveToOverwrite                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StopRecordingOutput(class UObject* WorldContextObject, enum class EAudioRecordingExportType ExportType, const class FString& Name, const class FString& Path, class USoundWave* ExistingSoundWaveToOverwrite)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SoundSubmix", "StopRecordingOutput");

	Params::USoundSubmix_StopRecordingOutput_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ExportType = ExportType;
	Parms.Name = Name;
	Parms.Path = Path;
	Parms.ExistingSoundWaveToOverwrite = ExistingSoundWaveToOverwrite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SoundSubmix.StopEnvelopeFollowing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StopEnvelopeFollowing(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SoundSubmix", "StopEnvelopeFollowing");

	Params::USoundSubmix_StopEnvelopeFollowing_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SoundSubmix.StartRecordingOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              ExpectedDuration                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StartRecordingOutput(class UObject* WorldContextObject, float ExpectedDuration)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SoundSubmix", "StartRecordingOutput");

	Params::USoundSubmix_StartRecordingOutput_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ExpectedDuration = ExpectedDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SoundSubmix.StartEnvelopeFollowing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StartEnvelopeFollowing(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SoundSubmix", "StartEnvelopeFollowing");

	Params::USoundSubmix_StartEnvelopeFollowing_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SoundSubmix.AddEnvelopeFollowerDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// UDelegateProperty_                 OnSubmixEnvelopeBP                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USoundSubmix::AddEnvelopeFollowerDelegate(class UObject* WorldContextObject, UDelegateProperty_& OnSubmixEnvelopeBP)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SoundSubmix", "AddEnvelopeFollowerDelegate");

	Params::USoundSubmix_AddEnvelopeFollowerDelegate_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OnSubmixEnvelopeBP = OnSubmixEnvelopeBP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SphereReflectionCapture
// (Actor)

class UClass* ASphereReflectionCapture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SphereReflectionCapture");

	return Clss;
}


// SphereReflectionCapture Engine.Default__SphereReflectionCapture
// (Public, ClassDefaultObject, ArchetypeObject)

class ASphereReflectionCapture* ASphereReflectionCapture::GetDefaultObj()
{
	static class ASphereReflectionCapture* Default = nullptr;

	if (!Default)
		Default = static_cast<ASphereReflectionCapture*>(ASphereReflectionCapture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SphereReflectionCaptureComponent
// (SceneComponent)

class UClass* USphereReflectionCaptureComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SphereReflectionCaptureComponent");

	return Clss;
}


// SphereReflectionCaptureComponent Engine.Default__SphereReflectionCaptureComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USphereReflectionCaptureComponent* USphereReflectionCaptureComponent::GetDefaultObj()
{
	static class USphereReflectionCaptureComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USphereReflectionCaptureComponent*>(USphereReflectionCaptureComponent::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SplineMetadata
// (None)

class UClass* USplineMetadata::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SplineMetadata");

	return Clss;
}


// SplineMetadata Engine.Default__SplineMetadata
// (Public, ClassDefaultObject, ArchetypeObject)

class USplineMetadata* USplineMetadata::GetDefaultObj()
{
	static class USplineMetadata* Default = nullptr;

	if (!Default)
		Default = static_cast<USplineMetadata*>(USplineMetadata::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SplineMeshActor
// (Actor)

class UClass* ASplineMeshActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SplineMeshActor");

	return Clss;
}


// SplineMeshActor Engine.Default__SplineMeshActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ASplineMeshActor* ASplineMeshActor::GetDefaultObj()
{
	static class ASplineMeshActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ASplineMeshActor*>(ASplineMeshActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SplineMeshComponent
// (SceneComponent, PrimitiveComponent, StaticMeshComponent)

class UClass* USplineMeshComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SplineMeshComponent");

	return Clss;
}


// SplineMeshComponent Engine.Default__SplineMeshComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USplineMeshComponent* USplineMeshComponent::GetDefaultObj()
{
	static class USplineMeshComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USplineMeshComponent*>(USplineMeshComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SplineMeshComponent.UpdateMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void USplineMeshComponent::UpdateMesh()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "UpdateMesh");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetStartTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     StartTangent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartTangent(const struct FVector& StartTangent, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetStartTangent");

	Params::USplineMeshComponent_SetStartTangent_Params Parms{};

	Parms.StartTangent = StartTangent;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetStartScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   StartScale                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartScale(const struct FVector2D& StartScale, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetStartScale");

	Params::USplineMeshComponent_SetStartScale_Params Parms{};

	Parms.StartScale = StartScale;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetStartRoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              StartRoll                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartRoll(float StartRoll, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetStartRoll");

	Params::USplineMeshComponent_SetStartRoll_Params Parms{};

	Parms.StartRoll = StartRoll;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetStartPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     StartPos                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartPosition(const struct FVector& StartPos, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetStartPosition");

	Params::USplineMeshComponent_SetStartPosition_Params Parms{};

	Parms.StartPos = StartPos;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetStartOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   StartOffset                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartOffset(const struct FVector2D& StartOffset, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetStartOffset");

	Params::USplineMeshComponent_SetStartOffset_Params Parms{};

	Parms.StartOffset = StartOffset;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetStartAndEnd
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     StartPos                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     StartTangent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     EndPos                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     EndTangent                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartAndEnd(const struct FVector& StartPos, const struct FVector& StartTangent, const struct FVector& EndPos, const struct FVector& EndTangent, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetStartAndEnd");

	Params::USplineMeshComponent_SetStartAndEnd_Params Parms{};

	Parms.StartPos = StartPos;
	Parms.StartTangent = StartTangent;
	Parms.EndPos = EndPos;
	Parms.EndTangent = EndTangent;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetSplineUpDir
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     InSplineUpDir                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetSplineUpDir(struct FVector& InSplineUpDir, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetSplineUpDir");

	Params::USplineMeshComponent_SetSplineUpDir_Params Parms{};

	Parms.InSplineUpDir = InSplineUpDir;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetForwardAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class ESplineMeshAxis         InForwardAxis                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetForwardAxis(enum class ESplineMeshAxis InForwardAxis, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetForwardAxis");

	Params::USplineMeshComponent_SetForwardAxis_Params Parms{};

	Parms.InForwardAxis = InForwardAxis;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetEndTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     EndTangent                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndTangent(const struct FVector& EndTangent, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetEndTangent");

	Params::USplineMeshComponent_SetEndTangent_Params Parms{};

	Parms.EndTangent = EndTangent;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetEndScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   EndScale                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndScale(const struct FVector2D& EndScale, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetEndScale");

	Params::USplineMeshComponent_SetEndScale_Params Parms{};

	Parms.EndScale = EndScale;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetEndRoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              EndRoll                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndRoll(float EndRoll, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetEndRoll");

	Params::USplineMeshComponent_SetEndRoll_Params Parms{};

	Parms.EndRoll = EndRoll;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetEndPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                     EndPos                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndPosition(const struct FVector& EndPos, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetEndPosition");

	Params::USplineMeshComponent_SetEndPosition_Params Parms{};

	Parms.EndPos = EndPos;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetEndOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   EndOffset                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndOffset(const struct FVector2D& EndOffset, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetEndOffset");

	Params::USplineMeshComponent_SetEndOffset_Params Parms{};

	Parms.EndOffset = EndOffset;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetBoundaryMin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InBoundaryMin                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetBoundaryMin");

	Params::USplineMeshComponent_SetBoundaryMin_Params Parms{};

	Parms.InBoundaryMin = InBoundaryMin;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.SetBoundaryMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InBoundaryMax                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bUpdateMesh                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "SetBoundaryMax");

	Params::USplineMeshComponent_SetBoundaryMax_Params Parms{};

	Parms.InBoundaryMax = InBoundaryMax;
	Parms.bUpdateMesh = bUpdateMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SplineMeshComponent.GetStartTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetStartTangent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetStartTangent");

	Params::USplineMeshComponent_GetStartTangent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetStartScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USplineMeshComponent::GetStartScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetStartScale");

	Params::USplineMeshComponent_GetStartScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetStartRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineMeshComponent::GetStartRoll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetStartRoll");

	Params::USplineMeshComponent_GetStartRoll_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetStartPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetStartPosition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetStartPosition");

	Params::USplineMeshComponent_GetStartPosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetStartOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USplineMeshComponent::GetStartOffset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetStartOffset");

	Params::USplineMeshComponent_GetStartOffset_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetSplineUpDir
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetSplineUpDir()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetSplineUpDir");

	Params::USplineMeshComponent_GetSplineUpDir_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetForwardAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ESplineMeshAxis         ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ESplineMeshAxis USplineMeshComponent::GetForwardAxis()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetForwardAxis");

	Params::USplineMeshComponent_GetForwardAxis_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetEndTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetEndTangent()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetEndTangent");

	Params::USplineMeshComponent_GetEndTangent_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetEndScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USplineMeshComponent::GetEndScale()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetEndScale");

	Params::USplineMeshComponent_GetEndScale_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetEndRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineMeshComponent::GetEndRoll()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetEndRoll");

	Params::USplineMeshComponent_GetEndRoll_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetEndPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetEndPosition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetEndPosition");

	Params::USplineMeshComponent_GetEndPosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetEndOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USplineMeshComponent::GetEndOffset()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetEndOffset");

	Params::USplineMeshComponent_GetEndOffset_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetBoundaryMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineMeshComponent::GetBoundaryMin()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetBoundaryMin");

	Params::USplineMeshComponent_GetBoundaryMin_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SplineMeshComponent.GetBoundaryMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineMeshComponent::GetBoundaryMax()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SplineMeshComponent", "GetBoundaryMax");

	Params::USplineMeshComponent_GetBoundaryMax_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.SpotLightComponent
// (SceneComponent)

class UClass* USpotLightComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpotLightComponent");

	return Clss;
}


// SpotLightComponent Engine.Default__SpotLightComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USpotLightComponent* USpotLightComponent::GetDefaultObj()
{
	static class USpotLightComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USpotLightComponent*>(USpotLightComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SpotLightComponent.SetOuterConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewOuterConeAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpotLightComponent::SetOuterConeAngle(float NewOuterConeAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpotLightComponent", "SetOuterConeAngle");

	Params::USpotLightComponent_SetOuterConeAngle_Params Parms{};

	Parms.NewOuterConeAngle = NewOuterConeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.SpotLightComponent.SetInnerConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewInnerConeAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpotLightComponent::SetInnerConeAngle(float NewInnerConeAngle)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpotLightComponent", "SetInnerConeAngle");

	Params::USpotLightComponent_SetInnerConeAngle_Params Parms{};

	Parms.NewInnerConeAngle = NewInnerConeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.SpringArmComponent
// (SceneComponent)

class UClass* USpringArmComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SpringArmComponent");

	return Clss;
}


// SpringArmComponent Engine.Default__SpringArmComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class USpringArmComponent* USpringArmComponent::GetDefaultObj()
{
	static class USpringArmComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<USpringArmComponent*>(USpringArmComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SpringArmComponent.IsCollisionFixApplied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpringArmComponent::IsCollisionFixApplied()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpringArmComponent", "IsCollisionFixApplied");

	Params::USpringArmComponent_IsCollisionFixApplied_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SpringArmComponent.GetUnfixedCameraPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USpringArmComponent::GetUnfixedCameraPosition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpringArmComponent", "GetUnfixedCameraPosition");

	Params::USpringArmComponent_GetUnfixedCameraPosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SpringArmComponent.GetTargetRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USpringArmComponent::GetTargetRotation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SpringArmComponent", "GetTargetRotation");

	Params::USpringArmComponent_GetTargetRotation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.StaticMesh
// (None)

class UClass* UStaticMesh::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StaticMesh");

	return Clss;
}


// StaticMesh Engine.Default__StaticMesh
// (Public, ClassDefaultObject, ArchetypeObject)

class UStaticMesh* UStaticMesh::GetDefaultObj()
{
	static class UStaticMesh* Default = nullptr;

	if (!Default)
		Default = static_cast<UStaticMesh*>(UStaticMesh::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.StaticMesh.GetNumSections
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              InLOD                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStaticMesh::GetNumSections(int32 InLOD)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMesh", "GetNumSections");

	Params::UStaticMesh_GetNumSections_Params Parms{};

	Parms.InLOD = InLOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StaticMesh.GetNumLODs
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStaticMesh::GetNumLODs()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMesh", "GetNumLODs");

	Params::UStaticMesh_GetNumLODs_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StaticMesh.GetMaterialIndex
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        MaterialSlotName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStaticMesh::GetMaterialIndex(class FName MaterialSlotName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMesh", "GetMaterialIndex");

	Params::UStaticMesh_GetMaterialIndex_Params Parms{};

	Parms.MaterialSlotName = MaterialSlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StaticMesh.GetMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              MaterialIndex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*          ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UStaticMesh::GetMaterial(int32 MaterialIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMesh", "GetMaterial");

	Params::UStaticMesh_GetMaterial_Params Parms{};

	Parms.MaterialIndex = MaterialIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StaticMesh.GetBounds
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds UStaticMesh::GetBounds()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMesh", "GetBounds");

	Params::UStaticMesh_GetBounds_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StaticMesh.GetBoundingBox
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                        ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UStaticMesh::GetBoundingBox()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMesh", "GetBoundingBox");

	Params::UStaticMesh_GetBoundingBox_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StaticMesh.FindSocket
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                        InSocketName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshSocket*           ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshSocket* UStaticMesh::FindSocket(class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StaticMesh", "FindSocket");

	Params::UStaticMesh_FindSocket_Params Parms{};

	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.StaticMeshSocket
// (None)

class UClass* UStaticMeshSocket::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StaticMeshSocket");

	return Clss;
}


// StaticMeshSocket Engine.Default__StaticMeshSocket
// (Public, ClassDefaultObject, ArchetypeObject)

class UStaticMeshSocket* UStaticMeshSocket::GetDefaultObj()
{
	static class UStaticMeshSocket* Default = nullptr;

	if (!Default)
		Default = static_cast<UStaticMeshSocket*>(UStaticMeshSocket::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.StereoLayerComponent
// (SceneComponent)

class UClass* UStereoLayerComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StereoLayerComponent");

	return Clss;
}


// StereoLayerComponent Engine.Default__StereoLayerComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UStereoLayerComponent* UStereoLayerComponent::GetDefaultObj()
{
	static class UStereoLayerComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UStereoLayerComponent*>(UStereoLayerComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.StereoLayerComponent.SetUVRect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBox2D                      InUVRect                                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetUVRect(const struct FBox2D& InUVRect)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "SetUVRect");

	Params::UStereoLayerComponent_SetUVRect_Params Parms{};

	Parms.InUVRect = InUVRect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StereoLayerComponent.SetTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                    InTexture                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetTexture(class UTexture* InTexture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "SetTexture");

	Params::UStereoLayerComponent_SetTexture_Params Parms{};

	Parms.InTexture = InTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StereoLayerComponent.SetQuadSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                   InQuadSize                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetQuadSize(const struct FVector2D& InQuadSize)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "SetQuadSize");

	Params::UStereoLayerComponent_SetQuadSize_Params Parms{};

	Parms.InQuadSize = InQuadSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StereoLayerComponent.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                              InPriority                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetPriority(int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "SetPriority");

	Params::UStereoLayerComponent_SetPriority_Params Parms{};

	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StereoLayerComponent.MarkTextureForUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:

void UStereoLayerComponent::MarkTextureForUpdate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "MarkTextureForUpdate");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StereoLayerComponent.GetUVRect
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox2D                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBox2D UStereoLayerComponent::GetUVRect()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "GetUVRect");

	Params::UStereoLayerComponent_GetUVRect_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StereoLayerComponent.GetTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture*                    ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UStereoLayerComponent::GetTexture()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "GetTexture");

	Params::UStereoLayerComponent_GetTexture_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StereoLayerComponent.GetQuadSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UStereoLayerComponent::GetQuadSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "GetQuadSize");

	Params::UStereoLayerComponent_GetQuadSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.StereoLayerComponent.GetPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStereoLayerComponent::GetPriority()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerComponent", "GetPriority");

	Params::UStereoLayerComponent_GetPriority_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.StereoLayerFunctionLibrary
// (None)

class UClass* UStereoLayerFunctionLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StereoLayerFunctionLibrary");

	return Clss;
}


// StereoLayerFunctionLibrary Engine.Default__StereoLayerFunctionLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UStereoLayerFunctionLibrary* UStereoLayerFunctionLibrary::GetDefaultObj()
{
	static class UStereoLayerFunctionLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UStereoLayerFunctionLibrary*>(UStereoLayerFunctionLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.StereoLayerFunctionLibrary.ShowSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UStereoLayerFunctionLibrary::ShowSplashScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerFunctionLibrary", "ShowSplashScreen");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StereoLayerFunctionLibrary.SetSplashScreen
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                    Texture                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                   Scale                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Offset                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShowLoadingMovie                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bShowOnSet                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerFunctionLibrary::SetSplashScreen(class UTexture* Texture, const struct FVector2D& Scale, const struct FVector& Offset, bool bShowLoadingMovie, bool bShowOnSet)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerFunctionLibrary", "SetSplashScreen");

	Params::UStereoLayerFunctionLibrary_SetSplashScreen_Params Parms{};

	Parms.Texture = Texture;
	Parms.Scale = Scale;
	Parms.Offset = Offset;
	Parms.bShowLoadingMovie = bShowLoadingMovie;
	Parms.bShowOnSet = bShowOnSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StereoLayerFunctionLibrary.HideSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:

void UStereoLayerFunctionLibrary::HideSplashScreen()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerFunctionLibrary", "HideSplashScreen");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.StereoLayerFunctionLibrary.EnableAutoLoadingSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               InAutoShowEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerFunctionLibrary::EnableAutoLoadingSplashScreen(bool InAutoShowEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("StereoLayerFunctionLibrary", "EnableAutoLoadingSplashScreen");

	Params::UStereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen_Params Parms{};

	Parms.InAutoShowEnabled = InAutoShowEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.StringTable
// (None)

class UClass* UStringTable::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("StringTable");

	return Clss;
}


// StringTable Engine.Default__StringTable
// (Public, ClassDefaultObject, ArchetypeObject)

class UStringTable* UStringTable::GetDefaultObj()
{
	static class UStringTable* Default = nullptr;

	if (!Default)
		Default = static_cast<UStringTable*>(UStringTable::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SubsurfaceProfile
// (None)

class UClass* USubsurfaceProfile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SubsurfaceProfile");

	return Clss;
}


// SubsurfaceProfile Engine.Default__SubsurfaceProfile
// (Public, ClassDefaultObject, ArchetypeObject)

class USubsurfaceProfile* USubsurfaceProfile::GetDefaultObj()
{
	static class USubsurfaceProfile* Default = nullptr;

	if (!Default)
		Default = static_cast<USubsurfaceProfile*>(USubsurfaceProfile::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.SubsystemBlueprintLibrary
// (None)

class UClass* USubsystemBlueprintLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SubsystemBlueprintLibrary");

	return Clss;
}


// SubsystemBlueprintLibrary Engine.Default__SubsystemBlueprintLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class USubsystemBlueprintLibrary* USubsystemBlueprintLibrary::GetDefaultObj()
{
	static class USubsystemBlueprintLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<USubsystemBlueprintLibrary*>(USubsystemBlueprintLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubSystemFromPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*           PlayerController                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULocalPlayerSubsystem>Class                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULocalPlayerSubsystem*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayerSubsystem* USubsystemBlueprintLibrary::GetLocalPlayerSubSystemFromPlayerController(class APlayerController* PlayerController, TSubclassOf<class ULocalPlayerSubsystem> Class)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubsystemBlueprintLibrary", "GetLocalPlayerSubSystemFromPlayerController");

	Params::USubsystemBlueprintLibrary_GetLocalPlayerSubSystemFromPlayerController_Params Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Class = Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     ContextObject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULocalPlayerSubsystem>Class                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULocalPlayerSubsystem*       ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayerSubsystem* USubsystemBlueprintLibrary::GetLocalPlayerSubsystem(class UObject* ContextObject, TSubclassOf<class ULocalPlayerSubsystem> Class)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubsystemBlueprintLibrary", "GetLocalPlayerSubsystem");

	Params::USubsystemBlueprintLibrary_GetLocalPlayerSubsystem_Params Parms{};

	Parms.ContextObject = ContextObject;
	Parms.Class = Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SubsystemBlueprintLibrary.GetGameInstanceSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                     ContextObject                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameInstanceSubsystem>Class                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameInstanceSubsystem*      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameInstanceSubsystem* USubsystemBlueprintLibrary::GetGameInstanceSubsystem(class UObject* ContextObject, TSubclassOf<class UGameInstanceSubsystem> Class)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubsystemBlueprintLibrary", "GetGameInstanceSubsystem");

	Params::USubsystemBlueprintLibrary_GetGameInstanceSubsystem_Params Parms{};

	Parms.ContextObject = ContextObject;
	Parms.Class = Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.SubsystemBlueprintLibrary.GetEngineSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UEngineSubsystem>Class                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEngineSubsystem*            ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEngineSubsystem* USubsystemBlueprintLibrary::GetEngineSubsystem(TSubclassOf<class UEngineSubsystem> Class)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SubsystemBlueprintLibrary", "GetEngineSubsystem");

	Params::USubsystemBlueprintLibrary_GetEngineSubsystem_Params Parms{};

	Parms.Class = Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.SubUVAnimation
// (None)

class UClass* USubUVAnimation::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SubUVAnimation");

	return Clss;
}


// SubUVAnimation Engine.Default__SubUVAnimation
// (Public, ClassDefaultObject, ArchetypeObject)

class USubUVAnimation* USubUVAnimation::GetDefaultObj()
{
	static class USubUVAnimation* Default = nullptr;

	if (!Default)
		Default = static_cast<USubUVAnimation*>(USubUVAnimation::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TimecodeProvider
// (None)

class UClass* UTimecodeProvider::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TimecodeProvider");

	return Clss;
}


// TimecodeProvider Engine.Default__TimecodeProvider
// (Public, ClassDefaultObject, ArchetypeObject)

class UTimecodeProvider* UTimecodeProvider::GetDefaultObj()
{
	static class UTimecodeProvider* Default = nullptr;

	if (!Default)
		Default = static_cast<UTimecodeProvider*>(UTimecodeProvider::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.TimecodeProvider.GetTimecode
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimecode                   ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimecode UTimecodeProvider::GetTimecode()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimecodeProvider", "GetTimecode");

	Params::UTimecodeProvider_GetTimecode_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TimecodeProvider.GetSynchronizationState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// enum class ETimecodeProviderSynchronizationStateReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

enum class ETimecodeProviderSynchronizationState UTimecodeProvider::GetSynchronizationState()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimecodeProvider", "GetSynchronizationState");

	Params::UTimecodeProvider_GetSynchronizationState_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TimecodeProvider.GetFrameRate
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFrameRate                  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFrameRate UTimecodeProvider::GetFrameRate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimecodeProvider", "GetFrameRate");

	Params::UTimecodeProvider_GetFrameRate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.SystemTimeTimecodeProvider
// (None)

class UClass* USystemTimeTimecodeProvider::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("SystemTimeTimecodeProvider");

	return Clss;
}


// SystemTimeTimecodeProvider Engine.Default__SystemTimeTimecodeProvider
// (Public, ClassDefaultObject, ArchetypeObject)

class USystemTimeTimecodeProvider* USystemTimeTimecodeProvider::GetDefaultObj()
{
	static class USystemTimeTimecodeProvider* Default = nullptr;

	if (!Default)
		Default = static_cast<USystemTimeTimecodeProvider*>(USystemTimeTimecodeProvider::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.SystemTimeTimecodeProvider.SetFrameRate
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FFrameRate                  InFrameRate                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USystemTimeTimecodeProvider::SetFrameRate(struct FFrameRate& InFrameRate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("SystemTimeTimecodeProvider", "SetFrameRate");

	Params::USystemTimeTimecodeProvider_SetFrameRate_Params Parms{};

	Parms.InFrameRate = InFrameRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.TargetPoint
// (Actor)

class UClass* ATargetPoint::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TargetPoint");

	return Clss;
}


// TargetPoint Engine.Default__TargetPoint
// (Public, ClassDefaultObject, ArchetypeObject)

class ATargetPoint* ATargetPoint::GetDefaultObj()
{
	static class ATargetPoint* Default = nullptr;

	if (!Default)
		Default = static_cast<ATargetPoint*>(ATargetPoint::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TextPropertyTestObject
// (None)

class UClass* UTextPropertyTestObject::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextPropertyTestObject");

	return Clss;
}


// TextPropertyTestObject Engine.Default__TextPropertyTestObject
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextPropertyTestObject* UTextPropertyTestObject::GetDefaultObj()
{
	static class UTextPropertyTestObject* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextPropertyTestObject*>(UTextPropertyTestObject::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TextRenderActor
// (Actor)

class UClass* ATextRenderActor::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextRenderActor");

	return Clss;
}


// TextRenderActor Engine.Default__TextRenderActor
// (Public, ClassDefaultObject, ArchetypeObject)

class ATextRenderActor* ATextRenderActor::GetDefaultObj()
{
	static class ATextRenderActor* Default = nullptr;

	if (!Default)
		Default = static_cast<ATextRenderActor*>(ATextRenderActor::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TextRenderComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UTextRenderComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextRenderComponent");

	return Clss;
}


// TextRenderComponent Engine.Default__TextRenderComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextRenderComponent* UTextRenderComponent::GetDefaultObj()
{
	static class UTextRenderComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextRenderComponent*>(UTextRenderComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.TextRenderComponent.SetYScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetYScale(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetYScale");

	Params::UTextRenderComponent_SetYScale_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetXScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetXScale(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetXScale");

	Params::UTextRenderComponent_SetXScale_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetWorldSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetWorldSize(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetWorldSize");

	Params::UTextRenderComponent_SetWorldSize_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetVertSpacingAdjust
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetVertSpacingAdjust(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetVertSpacingAdjust");

	Params::UTextRenderComponent_SetVertSpacingAdjust_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EVerticalTextAligment   Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetVerticalAlignment(enum class EVerticalTextAligment Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetVerticalAlignment");

	Params::UTextRenderComponent_SetVerticalAlignment_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetTextRenderColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                      Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetTextRenderColor(const struct FColor& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetTextRenderColor");

	Params::UTextRenderComponent_SetTextRenderColor_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetTextMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*          Material                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetTextMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetTextMaterial");

	Params::UTextRenderComponent_SetTextMaterial_Params Parms{};

	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                      Value                                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetText(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetText");

	Params::UTextRenderComponent_SetText_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetHorizSpacingAdjust
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetHorizSpacingAdjust(float Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetHorizSpacingAdjust");

	Params::UTextRenderComponent_SetHorizSpacingAdjust_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EHorizTextAligment      Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetHorizontalAlignment(enum class EHorizTextAligment Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetHorizontalAlignment");

	Params::UTextRenderComponent_SetHorizontalAlignment_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.SetFont
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFont*                       Value                                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetFont(class UFont* Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "SetFont");

	Params::UTextRenderComponent_SetFont_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.K2_SetText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                        Value                                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTextRenderComponent::K2_SetText(class FText& Value)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "K2_SetText");

	Params::UTextRenderComponent_K2_SetText_Params Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TextRenderComponent.GetTextWorldSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTextRenderComponent::GetTextWorldSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "GetTextWorldSize");

	Params::UTextRenderComponent_GetTextWorldSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TextRenderComponent.GetTextLocalSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                     ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTextRenderComponent::GetTextLocalSize()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TextRenderComponent", "GetTextLocalSize");

	Params::UTextRenderComponent_GetTextLocalSize_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.Texture2DDynamic
// (None)

class UClass* UTexture2DDynamic::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("Texture2DDynamic");

	return Clss;
}


// Texture2DDynamic Engine.Default__Texture2DDynamic
// (Public, ClassDefaultObject, ArchetypeObject)

class UTexture2DDynamic* UTexture2DDynamic::GetDefaultObj()
{
	static class UTexture2DDynamic* Default = nullptr;

	if (!Default)
		Default = static_cast<UTexture2DDynamic*>(UTexture2DDynamic::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TextureLightProfile
// (None)

class UClass* UTextureLightProfile::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextureLightProfile");

	return Clss;
}


// TextureLightProfile Engine.Default__TextureLightProfile
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextureLightProfile* UTextureLightProfile::GetDefaultObj()
{
	static class UTextureLightProfile* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextureLightProfile*>(UTextureLightProfile::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TextureRenderTargetCube
// (None)

class UClass* UTextureRenderTargetCube::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TextureRenderTargetCube");

	return Clss;
}


// TextureRenderTargetCube Engine.Default__TextureRenderTargetCube
// (Public, ClassDefaultObject, ArchetypeObject)

class UTextureRenderTargetCube* UTextureRenderTargetCube::GetDefaultObj()
{
	static class UTextureRenderTargetCube* Default = nullptr;

	if (!Default)
		Default = static_cast<UTextureRenderTargetCube*>(UTextureRenderTargetCube::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.ThumbnailInfo
// (None)

class UClass* UThumbnailInfo::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("ThumbnailInfo");

	return Clss;
}


// ThumbnailInfo Engine.Default__ThumbnailInfo
// (Public, ClassDefaultObject, ArchetypeObject)

class UThumbnailInfo* UThumbnailInfo::GetDefaultObj()
{
	static class UThumbnailInfo* Default = nullptr;

	if (!Default)
		Default = static_cast<UThumbnailInfo*>(UThumbnailInfo::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TimelineComponent
// (None)

class UClass* UTimelineComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TimelineComponent");

	return Clss;
}


// TimelineComponent Engine.Default__TimelineComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UTimelineComponent* UTimelineComponent::GetDefaultObj()
{
	static class UTimelineComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UTimelineComponent*>(UTimelineComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.TimelineComponent.Stop
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:

void UTimelineComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "Stop");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetVectorCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveVector*                NewVectorCurve                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        VectorTrackName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetVectorCurve(class UCurveVector* NewVectorCurve, class FName VectorTrackName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetVectorCurve");

	Params::UTimelineComponent_SetVectorCurve_Params Parms{};

	Parms.NewVectorCurve = NewVectorCurve;
	Parms.VectorTrackName = VectorTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetTimelineLengthMode
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// enum class ETimelineLengthMode     NewLengthMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetTimelineLengthMode(enum class ETimelineLengthMode NewLengthMode)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetTimelineLengthMode");

	Params::UTimelineComponent_SetTimelineLengthMode_Params Parms{};

	Parms.NewLengthMode = NewLengthMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetTimelineLength
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewLength                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetTimelineLength(float NewLength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetTimelineLength");

	Params::UTimelineComponent_SetTimelineLength_Params Parms{};

	Parms.NewLength = NewLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetPlayRate
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewRate                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetPlayRate(float NewRate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetPlayRate");

	Params::UTimelineComponent_SetPlayRate_Params Parms{};

	Parms.NewRate = NewRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetPlaybackPosition
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewPosition                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFireEvents                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bFireUpdate                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetPlaybackPosition");

	Params::UTimelineComponent_SetPlaybackPosition_Params Parms{};

	Parms.NewPosition = NewPosition;
	Parms.bFireEvents = bFireEvents;
	Parms.bFireUpdate = bFireUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetNewTime
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                              NewTime                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetNewTime(float NewTime)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetNewTime");

	Params::UTimelineComponent_SetNewTime_Params Parms{};

	Parms.NewTime = NewTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetLooping
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewLooping                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetLooping(bool bNewLooping)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetLooping");

	Params::UTimelineComponent_SetLooping_Params Parms{};

	Parms.bNewLooping = bNewLooping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetLinearColorCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveLinearColor*           NewLinearColorCurve                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        LinearColorTrackName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetLinearColorCurve(class UCurveLinearColor* NewLinearColorCurve, class FName LinearColorTrackName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetLinearColorCurve");

	Params::UTimelineComponent_SetLinearColorCurve_Params Parms{};

	Parms.NewLinearColorCurve = NewLinearColorCurve;
	Parms.LinearColorTrackName = LinearColorTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetIgnoreTimeDilation
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                               bNewIgnoreTimeDilation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetIgnoreTimeDilation");

	Params::UTimelineComponent_SetIgnoreTimeDilation_Params Parms{};

	Parms.bNewIgnoreTimeDilation = bNewIgnoreTimeDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.SetFloatCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveFloat*                 NewFloatCurve                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        FloatTrackName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetFloatCurve(class UCurveFloat* NewFloatCurve, class FName FloatTrackName)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "SetFloatCurve");

	Params::UTimelineComponent_SetFloatCurve_Params Parms{};

	Parms.NewFloatCurve = NewFloatCurve;
	Parms.FloatTrackName = FloatTrackName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.ReverseFromEnd
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:

void UTimelineComponent::ReverseFromEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "ReverseFromEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.Reverse
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:

void UTimelineComponent::Reverse()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "Reverse");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.PlayFromStart
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:

void UTimelineComponent::PlayFromStart()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "PlayFromStart");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.Play
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:

void UTimelineComponent::Play()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "Play");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.OnRep_Timeline
// (Final, Native, Public)
// Parameters:

void UTimelineComponent::OnRep_Timeline()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "OnRep_Timeline");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TimelineComponent.IsReversing
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimelineComponent::IsReversing()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "IsReversing");

	Params::UTimelineComponent_IsReversing_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TimelineComponent.IsPlaying
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimelineComponent::IsPlaying()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "IsPlaying");

	Params::UTimelineComponent_IsPlaying_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TimelineComponent.IsLooping
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimelineComponent::IsLooping()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "IsLooping");

	Params::UTimelineComponent_IsLooping_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TimelineComponent.GetTimelineLength
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimelineComponent::GetTimelineLength()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "GetTimelineLength");

	Params::UTimelineComponent_GetTimelineLength_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TimelineComponent.GetPlayRate
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimelineComponent::GetPlayRate()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "GetPlayRate");

	Params::UTimelineComponent_GetPlayRate_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TimelineComponent.GetPlaybackPosition
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimelineComponent::GetPlaybackPosition()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "GetPlaybackPosition");

	Params::UTimelineComponent_GetPlaybackPosition_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TimelineComponent.GetIgnoreTimeDilation
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimelineComponent::GetIgnoreTimeDilation()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TimelineComponent", "GetIgnoreTimeDilation");

	Params::UTimelineComponent_GetIgnoreTimeDilation_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.TimelineTemplate
// (None)

class UClass* UTimelineTemplate::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TimelineTemplate");

	return Clss;
}


// TimelineTemplate Engine.Default__TimelineTemplate
// (Public, ClassDefaultObject, ArchetypeObject)

class UTimelineTemplate* UTimelineTemplate::GetDefaultObj()
{
	static class UTimelineTemplate* Default = nullptr;

	if (!Default)
		Default = static_cast<UTimelineTemplate*>(UTimelineTemplate::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TireType
// (None)

class UClass* UTireType::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TireType");

	return Clss;
}


// TireType Engine.Default__TireType
// (Public, ClassDefaultObject, ArchetypeObject)

class UTireType* UTireType::GetDefaultObj()
{
	static class UTireType* Default = nullptr;

	if (!Default)
		Default = static_cast<UTireType*>(UTireType::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TouchInterface
// (None)

class UClass* UTouchInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TouchInterface");

	return Clss;
}


// TouchInterface Engine.Default__TouchInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class UTouchInterface* UTouchInterface::GetDefaultObj()
{
	static class UTouchInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<UTouchInterface*>(UTouchInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TriggerBase
// (Actor)

class UClass* ATriggerBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TriggerBase");

	return Clss;
}


// TriggerBase Engine.Default__TriggerBase
// (Public, ClassDefaultObject, ArchetypeObject)

class ATriggerBase* ATriggerBase::GetDefaultObj()
{
	static class ATriggerBase* Default = nullptr;

	if (!Default)
		Default = static_cast<ATriggerBase*>(ATriggerBase::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TriggerBox
// (Actor)

class UClass* ATriggerBox::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TriggerBox");

	return Clss;
}


// TriggerBox Engine.Default__TriggerBox
// (Public, ClassDefaultObject, ArchetypeObject)

class ATriggerBox* ATriggerBox::GetDefaultObj()
{
	static class ATriggerBox* Default = nullptr;

	if (!Default)
		Default = static_cast<ATriggerBox*>(ATriggerBox::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TriggerCapsule
// (Actor)

class UClass* ATriggerCapsule::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TriggerCapsule");

	return Clss;
}


// TriggerCapsule Engine.Default__TriggerCapsule
// (Public, ClassDefaultObject, ArchetypeObject)

class ATriggerCapsule* ATriggerCapsule::GetDefaultObj()
{
	static class ATriggerCapsule* Default = nullptr;

	if (!Default)
		Default = static_cast<ATriggerCapsule*>(ATriggerCapsule::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TriggerSphere
// (Actor)

class UClass* ATriggerSphere::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TriggerSphere");

	return Clss;
}


// TriggerSphere Engine.Default__TriggerSphere
// (Public, ClassDefaultObject, ArchetypeObject)

class ATriggerSphere* ATriggerSphere::GetDefaultObj()
{
	static class ATriggerSphere* Default = nullptr;

	if (!Default)
		Default = static_cast<ATriggerSphere*>(ATriggerSphere::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TriggerVolume
// (Actor)

class UClass* ATriggerVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TriggerVolume");

	return Clss;
}


// TriggerVolume Engine.Default__TriggerVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class ATriggerVolume* ATriggerVolume::GetDefaultObj()
{
	static class ATriggerVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<ATriggerVolume*>(ATriggerVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.TwitterIntegrationBase
// (None)

class UClass* UTwitterIntegrationBase::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("TwitterIntegrationBase");

	return Clss;
}


// TwitterIntegrationBase Engine.Default__TwitterIntegrationBase
// (Public, ClassDefaultObject, ArchetypeObject)

class UTwitterIntegrationBase* UTwitterIntegrationBase::GetDefaultObj()
{
	static class UTwitterIntegrationBase* Default = nullptr;

	if (!Default)
		Default = static_cast<UTwitterIntegrationBase*>(UTwitterIntegrationBase::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.TwitterIntegrationBase.TwitterRequest
// (Native, Public, HasOutParams)
// Parameters:
// class FString                      URL                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>              ParamKeysAndValues                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// enum class ETwitterRequestMethod   RequestMethod                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                              AccountIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwitterIntegrationBase::TwitterRequest(const class FString& URL, TArray<class FString>& ParamKeysAndValues, enum class ETwitterRequestMethod RequestMethod, int32 AccountIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwitterIntegrationBase", "TwitterRequest");

	Params::UTwitterIntegrationBase_TwitterRequest_Params Parms{};

	Parms.URL = URL;
	Parms.ParamKeysAndValues = ParamKeysAndValues;
	Parms.RequestMethod = RequestMethod;
	Parms.AccountIndex = AccountIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TwitterIntegrationBase.ShowTweetUI
// (Native, Public)
// Parameters:
// class FString                      InitialMessage                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      URL                                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Picture                                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwitterIntegrationBase::ShowTweetUI(const class FString& InitialMessage, const class FString& URL, const class FString& Picture)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwitterIntegrationBase", "ShowTweetUI");

	Params::UTwitterIntegrationBase_ShowTweetUI_Params Parms{};

	Parms.InitialMessage = InitialMessage;
	Parms.URL = URL;
	Parms.Picture = Picture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TwitterIntegrationBase.Init
// (Native, Public)
// Parameters:

void UTwitterIntegrationBase::Init()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwitterIntegrationBase", "Init");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.TwitterIntegrationBase.GetNumAccounts
// (Native, Public)
// Parameters:
// int32                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTwitterIntegrationBase::GetNumAccounts()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwitterIntegrationBase", "GetNumAccounts");

	Params::UTwitterIntegrationBase_GetNumAccounts_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TwitterIntegrationBase.GetAccountName
// (Native, Public)
// Parameters:
// int32                              AccountIndex                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTwitterIntegrationBase::GetAccountName(int32 AccountIndex)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwitterIntegrationBase", "GetAccountName");

	Params::UTwitterIntegrationBase_GetAccountName_Params Parms{};

	Parms.AccountIndex = AccountIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TwitterIntegrationBase.CanShowTweetUI
// (Native, Public)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwitterIntegrationBase::CanShowTweetUI()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwitterIntegrationBase", "CanShowTweetUI");

	Params::UTwitterIntegrationBase_CanShowTweetUI_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.TwitterIntegrationBase.AuthorizeAccounts
// (Native, Public)
// Parameters:
// bool                               ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwitterIntegrationBase::AuthorizeAccounts()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("TwitterIntegrationBase", "AuthorizeAccounts");

	Params::UTwitterIntegrationBase_AuthorizeAccounts_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Class Engine.UserDefinedEnum
// (Field, Enum)

class UClass* UUserDefinedEnum::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UserDefinedEnum");

	return Clss;
}


// UserDefinedEnum Engine.Default__UserDefinedEnum
// (Public, ClassDefaultObject, ArchetypeObject)

class UUserDefinedEnum* UUserDefinedEnum::GetDefaultObj()
{
	static class UUserDefinedEnum* Default = nullptr;

	if (!Default)
		Default = static_cast<UUserDefinedEnum*>(UUserDefinedEnum::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.UserDefinedStruct
// (Field, Struct, ScriptStruct)

class UClass* UUserDefinedStruct::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UserDefinedStruct");

	return Clss;
}


// UserDefinedStruct Engine.Default__UserDefinedStruct
// (Public, ClassDefaultObject, ArchetypeObject)

class UUserDefinedStruct* UUserDefinedStruct::GetDefaultObj()
{
	static class UUserDefinedStruct* Default = nullptr;

	if (!Default)
		Default = static_cast<UUserDefinedStruct*>(UUserDefinedStruct::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.UserInterfaceSettings
// (None)

class UClass* UUserInterfaceSettings::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("UserInterfaceSettings");

	return Clss;
}


// UserInterfaceSettings Engine.Default__UserInterfaceSettings
// (Public, ClassDefaultObject, ArchetypeObject)

class UUserInterfaceSettings* UUserInterfaceSettings::GetDefaultObj()
{
	static class UUserInterfaceSettings* Default = nullptr;

	if (!Default)
		Default = static_cast<UUserInterfaceSettings*>(UUserInterfaceSettings::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VectorField
// (None)

class UClass* UVectorField::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VectorField");

	return Clss;
}


// VectorField Engine.Default__VectorField
// (Public, ClassDefaultObject, ArchetypeObject)

class UVectorField* UVectorField::GetDefaultObj()
{
	static class UVectorField* Default = nullptr;

	if (!Default)
		Default = static_cast<UVectorField*>(UVectorField::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VectorFieldAnimated
// (None)

class UClass* UVectorFieldAnimated::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VectorFieldAnimated");

	return Clss;
}


// VectorFieldAnimated Engine.Default__VectorFieldAnimated
// (Public, ClassDefaultObject, ArchetypeObject)

class UVectorFieldAnimated* UVectorFieldAnimated::GetDefaultObj()
{
	static class UVectorFieldAnimated* Default = nullptr;

	if (!Default)
		Default = static_cast<UVectorFieldAnimated*>(UVectorFieldAnimated::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VectorFieldComponent
// (SceneComponent, PrimitiveComponent)

class UClass* UVectorFieldComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VectorFieldComponent");

	return Clss;
}


// VectorFieldComponent Engine.Default__VectorFieldComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UVectorFieldComponent* UVectorFieldComponent::GetDefaultObj()
{
	static class UVectorFieldComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UVectorFieldComponent*>(UVectorFieldComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.VectorFieldComponent.SetIntensity
// (Native, Public, BlueprintCallable)
// Parameters:
// float                              NewIntensity                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVectorFieldComponent::SetIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VectorFieldComponent", "SetIntensity");

	Params::UVectorFieldComponent_SetIntensity_Params Parms{};

	Parms.NewIntensity = NewIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.VectorFieldStatic
// (None)

class UClass* UVectorFieldStatic::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VectorFieldStatic");

	return Clss;
}


// VectorFieldStatic Engine.Default__VectorFieldStatic
// (Public, ClassDefaultObject, ArchetypeObject)

class UVectorFieldStatic* UVectorFieldStatic::GetDefaultObj()
{
	static class UVectorFieldStatic* Default = nullptr;

	if (!Default)
		Default = static_cast<UVectorFieldStatic*>(UVectorFieldStatic::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VectorFieldVolume
// (Actor)

class UClass* AVectorFieldVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VectorFieldVolume");

	return Clss;
}


// VectorFieldVolume Engine.Default__VectorFieldVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AVectorFieldVolume* AVectorFieldVolume::GetDefaultObj()
{
	static class AVectorFieldVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AVectorFieldVolume*>(AVectorFieldVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VirtualTexture
// (None)

class UClass* UVirtualTexture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VirtualTexture");

	return Clss;
}


// VirtualTexture Engine.Default__VirtualTexture
// (Public, ClassDefaultObject, ArchetypeObject)

class UVirtualTexture* UVirtualTexture::GetDefaultObj()
{
	static class UVirtualTexture* Default = nullptr;

	if (!Default)
		Default = static_cast<UVirtualTexture*>(UVirtualTexture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightMapVirtualTexture
// (None)

class UClass* ULightMapVirtualTexture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightMapVirtualTexture");

	return Clss;
}


// LightMapVirtualTexture Engine.Default__LightMapVirtualTexture
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightMapVirtualTexture* ULightMapVirtualTexture::GetDefaultObj()
{
	static class ULightMapVirtualTexture* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightMapVirtualTexture*>(ULightMapVirtualTexture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VirtualTextureSpace
// (None)

class UClass* UVirtualTextureSpace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VirtualTextureSpace");

	return Clss;
}


// VirtualTextureSpace Engine.Default__VirtualTextureSpace
// (Public, ClassDefaultObject, ArchetypeObject)

class UVirtualTextureSpace* UVirtualTextureSpace::GetDefaultObj()
{
	static class UVirtualTextureSpace* Default = nullptr;

	if (!Default)
		Default = static_cast<UVirtualTextureSpace*>(UVirtualTextureSpace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.LightMapVirtualTextureSpace
// (None)

class UClass* ULightMapVirtualTextureSpace::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("LightMapVirtualTextureSpace");

	return Clss;
}


// LightMapVirtualTextureSpace Engine.Default__LightMapVirtualTextureSpace
// (Public, ClassDefaultObject, ArchetypeObject)

class ULightMapVirtualTextureSpace* ULightMapVirtualTextureSpace::GetDefaultObj()
{
	static class ULightMapVirtualTextureSpace* Default = nullptr;

	if (!Default)
		Default = static_cast<ULightMapVirtualTextureSpace*>(ULightMapVirtualTextureSpace::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VisualLoggerAutomationTests
// (None)

class UClass* UVisualLoggerAutomationTests::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VisualLoggerAutomationTests");

	return Clss;
}


// VisualLoggerAutomationTests Engine.Default__VisualLoggerAutomationTests
// (Public, ClassDefaultObject, ArchetypeObject)

class UVisualLoggerAutomationTests* UVisualLoggerAutomationTests::GetDefaultObj()
{
	static class UVisualLoggerAutomationTests* Default = nullptr;

	if (!Default)
		Default = static_cast<UVisualLoggerAutomationTests*>(UVisualLoggerAutomationTests::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VisualLoggerDebugSnapshotInterface
// (None)

class UClass* IVisualLoggerDebugSnapshotInterface::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VisualLoggerDebugSnapshotInterface");

	return Clss;
}


// VisualLoggerDebugSnapshotInterface Engine.Default__VisualLoggerDebugSnapshotInterface
// (Public, ClassDefaultObject, ArchetypeObject)

class IVisualLoggerDebugSnapshotInterface* IVisualLoggerDebugSnapshotInterface::GetDefaultObj()
{
	static class IVisualLoggerDebugSnapshotInterface* Default = nullptr;

	if (!Default)
		Default = static_cast<IVisualLoggerDebugSnapshotInterface*>(IVisualLoggerDebugSnapshotInterface::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VisualLoggerKismetLibrary
// (None)

class UClass* UVisualLoggerKismetLibrary::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VisualLoggerKismetLibrary");

	return Clss;
}


// VisualLoggerKismetLibrary Engine.Default__VisualLoggerKismetLibrary
// (Public, ClassDefaultObject, ArchetypeObject)

class UVisualLoggerKismetLibrary* UVisualLoggerKismetLibrary::GetDefaultObj()
{
	static class UVisualLoggerKismetLibrary* Default = nullptr;

	if (!Default)
		Default = static_cast<UVisualLoggerKismetLibrary*>(UVisualLoggerKismetLibrary::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.VisualLoggerKismetLibrary.RedirectVislog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     SourceOwner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                     DestinationOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::RedirectVislog(class UObject* SourceOwner, class UObject* DestinationOwner)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VisualLoggerKismetLibrary", "RedirectVislog");

	Params::UVisualLoggerKismetLibrary_RedirectVislog_Params Parms{};

	Parms.SourceOwner = SourceOwner;
	Parms.DestinationOwner = DestinationOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.VisualLoggerKismetLibrary.LogText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Text                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        LogCategory                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToMessageLog                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::LogText(class UObject* WorldContextObject, const class FString& Text, class FName LogCategory, bool bAddToMessageLog)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VisualLoggerKismetLibrary", "LogText");

	Params::UVisualLoggerKismetLibrary_LogText_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Text = Text;
	Parms.LogCategory = LogCategory;
	Parms.bAddToMessageLog = bAddToMessageLog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.VisualLoggerKismetLibrary.LogSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SegmentStart                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     SegmentEnd                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Text                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ObjectColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Thickness                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        CategoryName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToMessageLog                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::LogSegment(class UObject* WorldContextObject, const struct FVector& SegmentStart, const struct FVector& SegmentEnd, const class FString& Text, const struct FLinearColor& ObjectColor, float Thickness, class FName CategoryName, bool bAddToMessageLog)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VisualLoggerKismetLibrary", "LogSegment");

	Params::UVisualLoggerKismetLibrary_LogSegment_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SegmentStart = SegmentStart;
	Parms.SegmentEnd = SegmentEnd;
	Parms.Text = Text;
	Parms.ObjectColor = ObjectColor;
	Parms.Thickness = Thickness;
	Parms.CategoryName = CategoryName;
	Parms.bAddToMessageLog = bAddToMessageLog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.VisualLoggerKismetLibrary.LogLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                     Location                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                      Text                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ObjectColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                              Radius                                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        LogCategory                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToMessageLog                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::LogLocation(class UObject* WorldContextObject, const struct FVector& Location, const class FString& Text, const struct FLinearColor& ObjectColor, float Radius, class FName LogCategory, bool bAddToMessageLog)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VisualLoggerKismetLibrary", "LogLocation");

	Params::UVisualLoggerKismetLibrary_LogLocation_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = Location;
	Parms.Text = Text;
	Parms.ObjectColor = ObjectColor;
	Parms.Radius = Radius;
	Parms.LogCategory = LogCategory;
	Parms.bAddToMessageLog = bAddToMessageLog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.VisualLoggerKismetLibrary.LogBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                     WorldContextObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                        BoxShape                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                      Text                                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                ObjectColor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                        LogCategory                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                               bAddToMessageLog                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::LogBox(class UObject* WorldContextObject, const struct FBox& BoxShape, const class FString& Text, const struct FLinearColor& ObjectColor, class FName LogCategory, bool bAddToMessageLog)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VisualLoggerKismetLibrary", "LogBox");

	Params::UVisualLoggerKismetLibrary_LogBox_Params Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxShape = BoxShape;
	Parms.Text = Text;
	Parms.ObjectColor = ObjectColor;
	Parms.LogCategory = LogCategory;
	Parms.bAddToMessageLog = bAddToMessageLog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.VisualLoggerKismetLibrary.EnableRecording
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                               bEnabled                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::EnableRecording(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VisualLoggerKismetLibrary", "EnableRecording");

	Params::UVisualLoggerKismetLibrary_EnableRecording_Params Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.VOIPTalker
// (None)

class UClass* UVOIPTalker::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VOIPTalker");

	return Clss;
}


// VOIPTalker Engine.Default__VOIPTalker
// (Public, ClassDefaultObject, ArchetypeObject)

class UVOIPTalker* UVOIPTalker::GetDefaultObj()
{
	static class UVOIPTalker* Default = nullptr;

	if (!Default)
		Default = static_cast<UVOIPTalker*>(UVOIPTalker::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.VOIPTalker.RegisterWithPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                OwningState                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVOIPTalker::RegisterWithPlayerState(class APlayerState* OwningState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VOIPTalker", "RegisterWithPlayerState");

	Params::UVOIPTalker_RegisterWithPlayerState_Params Parms{};

	Parms.OwningState = OwningState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.VOIPTalker.GetVoiceLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVOIPTalker::GetVoiceLevel()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VOIPTalker", "GetVoiceLevel");

	Params::UVOIPTalker_GetVoiceLevel_Params Parms{};


	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.VOIPTalker.CreateTalkerForPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                OwningState                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVOIPTalker*                 ReturnValue                                                      (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVOIPTalker* UVOIPTalker::CreateTalkerForPlayer(class APlayerState* OwningState)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VOIPTalker", "CreateTalkerForPlayer");

	Params::UVOIPTalker_CreateTalkerForPlayer_Params Parms{};

	Parms.OwningState = OwningState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;

}


// Function Engine.VOIPTalker.BPOnTalkingEnd
// (Native, Event, Protected, BlueprintEvent)
// Parameters:

void UVOIPTalker::BPOnTalkingEnd()
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VOIPTalker", "BPOnTalkingEnd");



	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);


	Func->FunctionFlags = Flgs;

}


// Function Engine.VOIPTalker.BPOnTalkingBegin
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UAudioComponent*             AudioComponent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVOIPTalker::BPOnTalkingBegin(class UAudioComponent* AudioComponent)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VOIPTalker", "BPOnTalkingBegin");

	Params::UVOIPTalker_BPOnTalkingBegin_Params Parms{};

	Parms.AudioComponent = AudioComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.VOIPStatics
// (None)

class UClass* UVOIPStatics::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VOIPStatics");

	return Clss;
}


// VOIPStatics Engine.Default__VOIPStatics
// (Public, ClassDefaultObject, ArchetypeObject)

class UVOIPStatics* UVOIPStatics::GetDefaultObj()
{
	static class UVOIPStatics* Default = nullptr;

	if (!Default)
		Default = static_cast<UVOIPStatics*>(UVOIPStatics::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.VOIPStatics.SetMicThreshold
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                              InThreshold                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVOIPStatics::SetMicThreshold(float InThreshold)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("VOIPStatics", "SetMicThreshold");

	Params::UVOIPStatics_SetMicThreshold_Params Parms{};

	Parms.InThreshold = InThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.VolumeTexture
// (None)

class UClass* UVolumeTexture::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VolumeTexture");

	return Clss;
}


// VolumeTexture Engine.Default__VolumeTexture
// (Public, ClassDefaultObject, ArchetypeObject)

class UVolumeTexture* UVolumeTexture::GetDefaultObj()
{
	static class UVolumeTexture* Default = nullptr;

	if (!Default)
		Default = static_cast<UVolumeTexture*>(UVolumeTexture::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.VolumetricLightmapDensityVolume
// (Actor)

class UClass* AVolumetricLightmapDensityVolume::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("VolumetricLightmapDensityVolume");

	return Clss;
}


// VolumetricLightmapDensityVolume Engine.Default__VolumetricLightmapDensityVolume
// (Public, ClassDefaultObject, ArchetypeObject)

class AVolumetricLightmapDensityVolume* AVolumetricLightmapDensityVolume::GetDefaultObj()
{
	static class AVolumetricLightmapDensityVolume* Default = nullptr;

	if (!Default)
		Default = static_cast<AVolumetricLightmapDensityVolume*>(AVolumetricLightmapDensityVolume::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.WindDirectionalSource
// (Actor)

class UClass* AWindDirectionalSource::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WindDirectionalSource");

	return Clss;
}


// WindDirectionalSource Engine.Default__WindDirectionalSource
// (Public, ClassDefaultObject, ArchetypeObject)

class AWindDirectionalSource* AWindDirectionalSource::GetDefaultObj()
{
	static class AWindDirectionalSource* Default = nullptr;

	if (!Default)
		Default = static_cast<AWindDirectionalSource*>(AWindDirectionalSource::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.WindDirectionalSourceComponent
// (SceneComponent)

class UClass* UWindDirectionalSourceComponent::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WindDirectionalSourceComponent");

	return Clss;
}


// WindDirectionalSourceComponent Engine.Default__WindDirectionalSourceComponent
// (Public, ClassDefaultObject, ArchetypeObject)

class UWindDirectionalSourceComponent* UWindDirectionalSourceComponent::GetDefaultObj()
{
	static class UWindDirectionalSourceComponent* Default = nullptr;

	if (!Default)
		Default = static_cast<UWindDirectionalSourceComponent*>(UWindDirectionalSourceComponent::StaticClass()->DefaultObject);

	return Default;
}


// Function Engine.WindDirectionalSourceComponent.SetWindType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// enum class EWindSourceType         InNewType                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetWindType(enum class EWindSourceType InNewType)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WindDirectionalSourceComponent", "SetWindType");

	Params::UWindDirectionalSourceComponent_SetWindType_Params Parms{};

	Parms.InNewType = InNewType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.WindDirectionalSourceComponent.SetStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewStrength                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetStrength(float InNewStrength)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WindDirectionalSourceComponent", "SetStrength");

	Params::UWindDirectionalSourceComponent_SetStrength_Params Parms{};

	Parms.InNewStrength = InNewStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.WindDirectionalSourceComponent.SetSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewSpeed                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetSpeed(float InNewSpeed)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WindDirectionalSourceComponent", "SetSpeed");

	Params::UWindDirectionalSourceComponent_SetSpeed_Params Parms{};

	Parms.InNewSpeed = InNewSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.WindDirectionalSourceComponent.SetRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewRadius                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetRadius(float InNewRadius)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WindDirectionalSourceComponent", "SetRadius");

	Params::UWindDirectionalSourceComponent_SetRadius_Params Parms{};

	Parms.InNewRadius = InNewRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.WindDirectionalSourceComponent.SetMinimumGustAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewMinGust                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetMinimumGustAmount(float InNewMinGust)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WindDirectionalSourceComponent", "SetMinimumGustAmount");

	Params::UWindDirectionalSourceComponent_SetMinimumGustAmount_Params Parms{};

	Parms.InNewMinGust = InNewMinGust;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Function Engine.WindDirectionalSourceComponent.SetMaximumGustAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                              InNewMaxGust                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetMaximumGustAmount(float InNewMaxGust)
{
	static class UFunction* Func = nullptr;

	if (!Func)
		Func = Class->GetFunction("WindDirectionalSourceComponent", "SetMaximumGustAmount");

	Params::UWindDirectionalSourceComponent_SetMaximumGustAmount_Params Parms{};

	Parms.InNewMaxGust = InNewMaxGust;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);


	Func->FunctionFlags = Flgs;

}


// Class Engine.WorldComposition
// (None)

class UClass* UWorldComposition::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("WorldComposition");

	return Clss;
}


// WorldComposition Engine.Default__WorldComposition
// (Public, ClassDefaultObject, ArchetypeObject)

class UWorldComposition* UWorldComposition::GetDefaultObj()
{
	static class UWorldComposition* Default = nullptr;

	if (!Default)
		Default = static_cast<UWorldComposition*>(UWorldComposition::StaticClass()->DefaultObject);

	return Default;
}


// Class Engine.HierarchicalLODSetup
// (None)

class UClass* UHierarchicalLODSetup::StaticClass()
{
	static class UClass* Clss = nullptr;

	if (!Clss)
		Clss = UObject::FindClassFast("HierarchicalLODSetup");

	return Clss;
}


// HierarchicalLODSetup Engine.Default__HierarchicalLODSetup
// (Public, ClassDefaultObject, ArchetypeObject)

class UHierarchicalLODSetup* UHierarchicalLODSetup::GetDefaultObj()
{
	static class UHierarchicalLODSetup* Default = nullptr;

	if (!Default)
		Default = static_cast<UHierarchicalLODSetup*>(UHierarchicalLODSetup::StaticClass()->DefaultObject);

	return Default;
}

}


